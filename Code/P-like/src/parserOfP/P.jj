/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.6";
}
PARSER_BEGIN(P)
package parserOfP;

import java.io.File;
import java.io.FileReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader; 
import java.io.LineNumberReader;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Scanner;

import compiler.components.*;
import compiler.dataTypes.*;
import compiler.exceptions.*;
import compiler.operator.*;
import compiler.util.*;
import compiler.util.Constants.DATA_TYPE;
import compiler.uXMLGenerator.*;

import xvHandler.Executor;
import xvHandler.CodeAnalysis;
import xvHandler.ProcedureCallSeq;

import parserOfP.exceptions.*;
 
public class P { 
	 
	private static UXMLElement currentNode = null;
	private static UXMLElement globalScopeNode = null;
	private static String currentProcedureName = null;
	private static FunctionType currentProcedure = null;
    private static boolean globalVariableDeclaration = false;
    private static boolean isReturnStmtPresent = false;
    private static int nestedLevelOfProcedure = 0; // Represents the nested level of a procedure
	
	public static void main(String args[]) throws ParseException {
		FileInputStream io = null;
		String codeAnalysisFlag = null;
		LineNumberReader loc = null;
     
		String fileName = null;
		String filePath = null;
	    if(args.length == 0) {
	    	Scanner in = new Scanner(System.in);
	    	System.out.print("Enter the file name @ src/samplePLikeProgs/");
	    	fileName = in.nextLine();
	    	while(fileName.trim().length() == 0)
	    		fileName = in.nextLine();
	    	codeAnalysisFlag = in.nextLine();
	    	args = new String[1];
	    	args[0] = fileName;
	    }
	    else {
	        fileName = args[0];
	        if(args.length > 1)
	        	codeAnalysisFlag = args[1];
	    }
	     
	    try { 
	    	filePath = "src" + File.separator + "samplePLikeProgs" + File.separator + fileName + ".Plike"; 
	    	io = new FileInputStream(filePath);
	    	P parser = new P(io);
	    	
	    	// Initialize the environment with ignore dynamic variable flag
	    	Environment.initialize(new ProcedureCallSeq(), true);
	    	// Initialize the uXMLDocument generator
	    	currentNode = UXMLElementFactory.initialize("Plike", Constants.STATIC);
	        
	        Environment.currentActivationRecord.enterTheBlock();
	        parser.PLike();
	        Environment.currentActivationRecord.leaveTheBlock();
	        
	        // Save the uXML document
	        UXMLElementFactory.done(fileName);
	        
	        if("-analysis".equals(codeAnalysisFlag)) {
	        	loc = new LineNumberReader(new FileReader(filePath));
	        	while (loc.readLine() != null) {}
	        	CodeAnalysis.main(args, loc.getLineNumber());
	        }
	        else
	        	Executor.main(args);
	        io.close(); 
        
	    } catch (FileNotFoundException fe) {
	    	System.err.println("File '" + fileName + "' not found.");
	    	System.exit(1);
	    } catch(IOException ie) {
	    	System.err.println("Error reading file '" + fileName + "'.");
	    	System.exit(1);
	    } catch(ParseException e) {
	        String message = e.getMessage();
	        int startIndex = message.indexOf("line ") + 5;
	        int endIndex = message.indexOf(",");
	        String lineNo = message.substring(startIndex, endIndex).trim();
	
	        startIndex = message.indexOf("column ") + 7;
	        endIndex = message.indexOf(".");
	        String columnNo = message.substring(startIndex, endIndex).trim();
	
	        startIndex = message.indexOf("\"") + 1;
	        endIndex = message.lastIndexOf("\" at line");
	        String keyword = message.substring(startIndex, endIndex).replaceAll("\"","").trim();
	        
	        System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
	        StringBuffer expectedTokens = new StringBuffer("Expected tokens : ");
	        String tokenValue = null;
	        tokenValue = tokenImage[e.expectedTokenSequences[0][0]]; 
	    	tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
	    	expectedTokens.append(tokenValue);
	        for(int tokenId = 1; tokenId < e.expectedTokenSequences.length;tokenId++) {
	        	tokenValue = tokenImage[e.expectedTokenSequences[tokenId][0]];
	        	tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
	        	expectedTokens.append(", ")
	        		.append(tokenValue);
	        }
	    	System.err.println(expectedTokens.toString());
	    } catch(TokenMgrError e) {
	    	String message = e.getMessage();
			int startIndex = message.indexOf("line ") + 5;
			int endIndex = message.indexOf(",");
			String lineNo = message.substring(startIndex, endIndex).trim();
			
			startIndex = message.indexOf("column ") + 7;
			endIndex = message.indexOf(".");
			String columnNo = message.substring(startIndex, endIndex).trim();
			
			startIndex = message.indexOf("\"") + 1;
			endIndex = message.indexOf("\"",startIndex);
			String keyword = message.substring(startIndex, endIndex).trim();
			
			System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
	    }
	    catch(CompilationException e) {
	    	System.err.println(e.getMessage());
	    }
  }

    private static void processProcedureHeading(UXMLElement procedureParamNode) {
		HashMap<String, String> attributes = new HashMap<String, String>();
		FunctionType procedureParam = (FunctionType)procedureParamNode.getSymbol();
		FunctionType cloneOfProcParam = (FunctionType)Clone.deepCopySymbol(procedureParam); // Create the clone
		String procedureSignature = cloneOfProcParam.getReturnType()+cloneOfProcParam.getSignature(); // Set its name as the signature
		
		attributes.clear();
		attributes.put(Constants.NAME,procedureParam.getName());
		attributes.put(Constants.TYPE,procedureSignature);
		attributes.put(Constants.MUTABLE,"yes");
		
		currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, procedureParam));
		
		// If present in global scope, then don't add else add it
		if(!Environment.isSymbolPresentInGlobalScope(procedureSignature)) {
			cloneOfProcParam.setName(procedureSignature); // Change the name to proc signature
			procedureParamNode.setAttributeValue(Constants.NAME,procedureSignature); // Change the name to proc signature
			
			Environment.addGlobalSymbol(cloneOfProcParam); // Add the function-type in global table
			globalScopeNode.appendChild(procedureParamNode);
		}
	}
}
PARSER_END(P)

SKIP : { " " | "\r" | "\t" | "\n" }

/* Constants */
TOKEN: { < INT_CONSTANT : ( < DIGIT > ) + > }
TOKEN: { < FLOAT_CONSTANT : ( < DIGIT > ) + "." ( < DIGIT > ) + > }
TOKEN: { < STRING_CONSTANT : "\"" (~["\""])+ "\"" > }
TOKEN: { < BOOL_CONSTANT : "true" | "false" > }
TOKEN: { < CHAR_CONSTANT : "'" ~["'"] "'" > }

/* Comments */
//Cited from : http://en.wikibooks.org/wiki/Compiler_Construction
SPECIAL_TOKEN : {<"{"> : InsideComment}
<InsideComment> SPECIAL_TOKEN :
{
	<"}"> : DEFAULT
}
<InsideComment> MORE: {<~[]>}

SPECIAL_TOKEN : {<"//"> : InsideNewComment}
<InsideNewComment> SPECIAL_TOKEN :
{
	<"\n" | "\r"> : DEFAULT
}
<InsideNewComment> MORE: {<~[]>}

/* OPERATORS */
TOKEN : { < PLUS: "+" > }	
TOKEN : { < MINUS: "-" > }
TOKEN : { < ASTERISK: "*" > }
TOKEN : { < DIVIDE: "/" > } 
TOKEN : { <MOD: "%" > }
TOKEN : { < AMPERSAND : "&" > }
TOKEN : { < BIT_OR : "|" > } 
TOKEN : { < BIT_XOR : "^" > }
TOKEN : { < BIT_COMPLEMENT : "~" > }

/* Logical Operators */
TOKEN: { < AND : "and" > }
TOKEN: { < OR : "or" > }
TOKEN: { < NOT: "not" > }

/* Conditional Operators */
TOKEN: { < EQ : "=" > }
TOKEN: { < NT_EQ : "!=" > }
TOKEN: { < LT: "<" > }
TOKEN: { < LT_EQ : "<=" > }
TOKEN: { < GT_EQ : ">=" > }
TOKEN: { < GT: ">" > }


/* Keywords */
TOKEN : { < PROGRAM : "PROGRAM" > } 
TOKEN : { < IF : "if" > } 
TOKEN : { < THEN : "then" > }
TOKEN : { < ELSE : "else" > } 
//TOKEN : { < ELSEIF : "elseif" > } 
TOKEN : { < DO : "do" > } 
TOKEN : { < WHILE : "while" > } 
TOKEN : { < FOR : "for" > }
TOKEN : { < TO : "to" > }
TOKEN : { < DOWNTO : "downto" > }
TOKEN : { < OF : "of" > }
TOKEN : { <CALL : "call" > }
TOKEN : { <WRITE : "write"> }
TOKEN : { <WRITELN : "writeln"> }
TOKEN : { <CONST : "const"> }
TOKEN : { <PROCEDURE : "procedure"> }
TOKEN : { <RETURN : "return"> }
TOKEN : { < VAR : "var" > }
TOKEN : { < BLOCK_START : "begin" > } 
TOKEN : { < BLOCK_END : "end" > }
TOKEN : { < SQUARE_START : "[" > } 
TOKEN : { < SQUARE_END : "]" > } 
TOKEN : { < ROUND_START : "(" > } 
TOKEN : { < ROUND_END : ")" > }
TOKEN : { < ASSIGN : ":=" > } 
TOKEN : { < COLON : ":" > }
TOKEN : { < COMMA : "," >} 
TOKEN : { < STMT_TERMINATOR : ";" > }
TOKEN : { < PERIOD : "." > }

/* Data types */
TOKEN : { < INT : "int" > } 
TOKEN : { < FLOAT : "float" > } 
TOKEN : { < CHAR : "char" > } 
TOKEN : { < BOOL : "boolean" >  }
TOKEN : { < STRING : "string" >  }
//TOKEN : { < STRUCT : "struct" > }
TOKEN : { < VOID : "void" > }
TOKEN : { < ARRAY : "array" > } 
//TOKEN : { < FUNC_PTR : "funcptr"> }
TOKEN : { <ID : ("_" | <ALPHA>)("_" | <DIGIT> | <ALPHA>)* > }

TOKEN : {<ALPHA : ["a" - "z"] | ["A" - "Z"]>}
TOKEN : {<DIGIT : ["0" - "9"]>}


// Possible allowable constants
Symbol Constants() throws CompilationException : {Token t = null;}
{
	try {
		(t = < INT_CONSTANT > { return new ConstantValue(Constants.INT,t.image);} 
		| t = < FLOAT_CONSTANT > { return new ConstantValue(Constants.FLOAT,t.image);}
		| t = < CHAR_CONSTANT > 
		{
			String ch = t.image.substring(1,2);
			return new ConstantValue(Constants.CHAR,ch);
		}
		| t = < STRING_CONSTANT > 
		{ 
			String str = t.image;
			str = str.substring(1, str.length() - 1);
			return new ConstantValue(Constants.STRING,str);
		}
		| t = < BOOL_CONSTANT >{ return new ConstantValue(Constants.BOOLEAN,t.image);}
		)
	} catch(IllegalSymbolValueException e) {
		throw new CompilationException(e.getMessage());
	}
}

// Possible allowable data-types
String DataType() throws CompilationException :
{
	Token t = null;
	String dataType = null;
	StringBuffer dimSizeType = new StringBuffer();
	Symbol baseElement = null;
	int startIndex, endIndex = 0;
	ArrayList<Integer> dimSize, dimStartIndex = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	UXMLElement arrayNodeElement = null;
}
{
	(
		(t = < INT > | t = < FLOAT > | t = < CHAR > | t = < BOOL > | t = < STRING>) { return  t.image; }
	|
	try {
    	(<ARRAY> 
    	{
    		dimSize = new ArrayList<Integer>(); dimStartIndex = new ArrayList<Integer>();
    		
    		// Create an array-type having blank name and type. Update it once with appropriate name/type. 
    		attributes.put(Constants.NAME, Constants.BLANK);
    		attributes.put(Constants.TYPE, Constants.BLANK);
    		arrayNodeElement = UXMLElementFactory.generateElement(Constants.ARRAY_TYPE, attributes, null);
    	} 
    	<SQUARE_START> 
    	t = <INT_CONSTANT> {startIndex = Integer.parseInt(t.image); dimStartIndex.add(startIndex);} 
    	<PERIOD> <PERIOD> 
    	t = <INT_CONSTANT> 
    	{
    		endIndex = Integer.parseInt(t.image);
    		if(startIndex >= endIndex) {throw new CompilationException("Start-index '" + startIndex + "' can never be greater than equal to end-index '" + endIndex +"'.");}
    		dimSize.add(endIndex - startIndex + 1);
    		dimSizeType.append(startIndex + ".." + endIndex);
    		// Append 'dim'
    		attributes.clear();
    		attributes.put(Constants.SIZE, String.valueOf(endIndex - startIndex + 1));
    		if(startIndex != 0)
    			attributes.put(Constants.START_INDEX, String.valueOf(startIndex));
    		arrayNodeElement.appendChild(UXMLElementFactory.generateElement(Constants.DIM, attributes, null));
    	} 
    	(<COMMA> 
    	t = <INT_CONSTANT> {startIndex = Integer.parseInt(t.image); dimStartIndex.add(startIndex);} 
    	<PERIOD> <PERIOD> 
    	t = <INT_CONSTANT> 
    	{
    		endIndex = Integer.parseInt(t.image);
    		if(startIndex >= endIndex) {throw new CompilationException("Start-index '" + startIndex + "' can never be greater than equal to end-index '" + endIndex +"'.");}
    		dimSize.add(endIndex - startIndex + 1);
    		dimSizeType.append("," + startIndex + ".." + endIndex);
    		// Append 'dim'
    		attributes.clear();
    		attributes.put(Constants.SIZE, String.valueOf(endIndex - startIndex + 1));
    		if(startIndex != 0)
    			attributes.put(Constants.START_INDEX, String.valueOf(startIndex));
    		arrayNodeElement.appendChild(UXMLElementFactory.generateElement(Constants.DIM, attributes, null));
    	} 
    	)*
    	<SQUARE_END> <OF> 
    	dataType = DataType())
    	{
    		baseElement = SymbolMachine.generate(Constants.BLANK, dataType, true);
			ArrayType arrayType = (ArrayType)SymbolMachine.generate(Constants.BLANK, Constants.ARRAY, true);
			arrayType.initializeArray(dimSize, dimStartIndex, baseElement);

			// Set the array element's base-type
			arrayNodeElement.setAttributeValue(Constants.TYPE,dataType);
			
			dataType = DataTypeFinder.getDataType(arrayType) + dimSizeType;
			arrayType.setName(dataType);
			
			// Set the Name of array-type
			arrayNodeElement.setAttributeValue(Constants.NAME,dataType);
			
			// If not yet defined, then append it to currentNode
			if(!Environment.currentActivationRecord.isSymbolPresent(dataType) && 
					!Environment.isSymbolPresentInGlobalScope(dataType)) {
				
				if(globalVariableDeclaration)
					globalScopeNode.appendChild(arrayNodeElement); // Add in global scope
				else
					currentNode.appendChild(arrayNodeElement); // Else add in current node
			}
			
			
			// Add the symbol in global/local scope
			if(globalVariableDeclaration) 
				Environment.addGlobalSymbol(arrayType);
			else 
				Environment.currentActivationRecord.addSymbol(arrayType);
			return dataType;
    	}
	} catch(IllegalSymbolValueException e) {throw new CompilationException(e.getMessage()); } 
	  catch(ImmutableSymbolException e) {throw new CompilationException(e.getMessage()); }
	  catch(TypeMismatchException e) {throw new CompilationException(e.getMessage()); }
	  catch(SymbolNotDefinedException e) {throw new CompilationException(e.getMessage()); }
    ) 
	
}


/**
 * Array Access
 *  ([ Expression() ])* 
 */
UXMLElement ArrayAccess(UXMLElement variableElement) throws CompilationException :
{
	Token t = null;
	int index = 0;
	HashMap<String, String> attributes = new HashMap<String, String> ();
	attributes.put(Constants.VALUE, "[]");
	UXMLElement operator = null, 
	indexElement = null,returnElement = operator;
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	Symbol arrayElementAtIndex = null;
}
{
	try {
		(<SQUARE_START> 
		indexElement = Expression() 
		{
			operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
			operator.appendChild(variableElement);
			operator.appendChild(indexElement);
			operands.clear();
			operands.add(variableElement.getSymbol());
			operands.add(indexElement.getSymbol());
			arrayElementAtIndex = Operator.execute("[]", operands);
			operator.setSymbol(arrayElementAtIndex);
			variableElement = operator;
		}
		(<COMMA> 
		indexElement = Expression()
		{
			operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
			operator.appendChild(variableElement);
			operator.appendChild(indexElement);
			operands.clear();
			operands.add(variableElement.getSymbol());
			operands.add(indexElement.getSymbol());
			arrayElementAtIndex = Operator.execute("[]", operands);
			operator.setSymbol(arrayElementAtIndex);
			variableElement = operator;
		}
		)*
		<SQUARE_END>
		)? {  return variableElement; }
	} catch (IllegalSymbolValueException e) {
		throw new CompilationException(e.getMessage());
	} catch(OperatorNotFoundException e) {
		throw new CompilationException(e.getMessage());
	}

}

void PLike() throws CompilationException : 
{
	UXMLElement savedCurrentNode = currentNode, block = null;
}
{
	HeadingSection()
	{
		globalVariableDeclaration = true; // Switch on the global declaration flag
		block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
		currentNode.appendChild(block);
		currentNode = block;
		globalScopeNode = UXMLElementFactory.generateElement(Constants.GLOBAL_VAR, null, null);
		currentNode.appendChild(globalScopeNode);
	}
	DeclarationSection()
	{
		globalVariableDeclaration = false; // Switch off the global declaration flag
//		block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
//		currentNode.appendChild(block);
//		currentNode = block;
	} 
	ScopeStart() (Statement())* ScopeEnd()
	{
		currentNode = savedCurrentNode;
	}
}

void HeadingSection() :{}
{<PROGRAM> <ID> <STMT_TERMINATOR>
}

void DeclarationSection() throws CompilationException : {}{
	// Optional 
	(ConstantDeclaration())?
	// Optional
	(VariableDeclaration())?
	// Could be many procedures within main program
	(ProcedureDeclaration())*
}

// Constant declaration
void ConstantDeclaration() throws CompilationException :{
	Token t = null;
	UXMLElement savedCurrentNode = currentNode, constantElement = null, constantExprElement = null;
	String paramName = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
	Symbol constantVar = null, constantValue = null;}
{
	try { 
	  < CONST >
	  	(	  	  t = < ID > { paramName = t.image; }  
	  	  <ASSIGN > 
	  	  constantExprElement = Expression()
	  	  {
	  		  constantValue = constantExprElement.getSymbol();
	  		  constantVar = SymbolMachine.generate(paramName, constantValue.getType(), false);
	  		  attributes.clear();
	  		  attributes.put(Constants.NAME, paramName);
	  		  attributes.put(Constants.TYPE, constantValue.getType());
	  		  attributes.put(Constants.MUTABLE, "no"); // Make it non-mutable
	  		  constantElement = UXMLElementFactory.generateElement(Constants.VAR, attributes, constantVar);
	  		  constantElement.appendChild(constantExprElement);
	  		  
	  		// Add the symbol in global/local scope
			  if(globalVariableDeclaration) {
				  Environment.addGlobalSymbol(constantVar);
				  globalScopeNode.appendChild(constantElement); // Add in global scope
			  }
			  else {
				  Environment.currentActivationRecord.addSymbol(constantVar);
				  currentNode.appendChild(constantElement); // Add in current node
			  }
	  	  }
	  	  <STMT_TERMINATOR>	  	)+ 
	}
	catch(IllegalSymbolValueException e) {throw new CompilationException(e.getMessage()); } 
}


// Variable declaration
void VariableDeclaration() throws CompilationException :
{}{
  < VAR >
  (	 VariableDefinition(true) <STMT_TERMINATOR>
  )+}

// Procedure Declaration
void ProcedureDeclaration() throws CompilationException : 
{
	// Save the global variable declaration status
	boolean originalGlobalVariableStatus = globalVariableDeclaration;
	globalVariableDeclaration = false; // Make status false so that variables won't be added at global-level
	UXMLElement procedureNode = null, savedCurrentNode = currentNode, block = null;
	nestedLevelOfProcedure++; // Increase the nested level
	Symbol functionType = null;
	FunctionType savedCurrentProcedure = null;
	String savedCurrentProcedureName = null;
}
{
	{
		// Execute the calling sequence of a caller - 
        Environment.callSequenceProcessor.callAction_caller(nestedLevelOfProcedure);
        // There may be the case that arguments to the function are function-pointers or like that which
        // are needed to add in symbol table, for that the method call 'enterTheBlock()' is necessary so that
        // symbol table will be created.
        Environment.currentActivationRecord.enterTheBlock();
	}
	procedureNode = ProcedureHeading(true)
	<STMT_TERMINATOR>
	{
		currentNode = currentNode.appendChild(procedureNode);
		block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null); 
		currentNode.appendChild(block);
		currentNode = block;
		// Save the currentProcedureName since the value of static variable could be changed in DeclarationSection() 
		savedCurrentProcedureName = currentProcedureName;
		savedCurrentProcedure = currentProcedure;
    }
	DeclarationSection() 
	{ currentProcedureName = savedCurrentProcedureName;  /*Restore the currentProcedureName */ 
	  currentProcedure = savedCurrentProcedure; }
	<BLOCK_START> (Statement())* <BLOCK_END>
	{
		// If function is defined to return a value and return statement is not present in function definition
		// or if function is defined to return void and if return statement is present 
		// then throw error  
		if(!Constants.VOID.equals(currentProcedure.getReturnType()) && !isReturnStmtPresent)
			throw new CompilationException("'" + currentProcedureName + "' should return a value of type '" 
					+ currentProcedure.getReturnType() + "'.");
		else if(Constants.VOID.equals(currentProcedure.getReturnType())&& isReturnStmtPresent )
			throw new CompilationException("'" + currentProcedureName + "' declared as 'void' should not return a value.");
		else
			isReturnStmtPresent = false;

		// Function done
		Environment.callSequenceProcessor.returnAction_caller();
		
		functionType = procedureNode.getSymbol(); // Extract the functiontype that is being defined.
		// If this is the function declaration, then add the function in appropriate symtab
		if(globalVariableDeclaration)
			Environment.addGlobalSymbol(functionType);
		else
			Environment.currentActivationRecord.addSymbol(functionType);
		
		globalVariableDeclaration = originalGlobalVariableStatus; // Restore the global var status
		currentNode = savedCurrentNode;
		nestedLevelOfProcedure--; // Decrease the nested level
	}
}

/*
 * isVarDeclaration - Used to specify if the variable has to be added in the symtab or not.
 * Used when the variables are listed in the procedure signature which itself is a parameter
 * to a procedure.
 */
ArrayList<Symbol> VariableDefinition(boolean isVarDeclaration) throws CompilationException : {
	Token t = null;
	ArrayList<String> variableNameList = new ArrayList<String>();
	ArrayList<Symbol> variableSymbolList = new ArrayList<Symbol>();
	String variableName = null, dataType = null;
	Symbol variableValue = null, variableSymbol;
	UXMLElement variableElement = null, variableValueElement = null;
	HashMap<String, String> attributes = new HashMap<String, String>();}{
  t = < ID > {variableNameList.add(t.image); } 
  ( < COMMA > 
  t = < ID > {variableNameList.add(t.image); } 
  )* < COLON > 
  dataType = DataType() ( < ASSIGN > variableValueElement = Expression() )?
  {
	  attributes.put(Constants.TYPE, dataType);
	  attributes.put(Constants.MUTABLE, "yes");
	  
	  try {
		  for(int variableNo = 0; variableNo < variableNameList.size(); variableNo++) {
			  variableName = variableNameList.get(variableNo);
			  variableSymbol = SymbolMachine.generate(variableName, dataType, true);
			  variableSymbolList.add(variableSymbol);
			  
			  attributes.put(Constants.NAME, variableName);
			  variableElement = UXMLElementFactory.generateElement(Constants.VAR, attributes, variableSymbol);
			  
			  
			  // If initial value is assigned
			  if(variableValueElement != null) {
				  // Extract the value
				  variableValue = variableValueElement.getSymbol();
				  variableElement.appendChild(variableValueElement);
				  variableSymbol.setValue(variableValue instanceof FunctionType? ((FunctionType)(variableValue)).getReturnValue() : variableValue);
			  }
			  
			  // Add the symbol in global/local scope
			  if(globalVariableDeclaration) {
				  // This is used to avoid adding variables that are declared in procedure heading that are
				  // actually one of the parameter to the procedure
				  if(isVarDeclaration) 
					  Environment.addGlobalSymbol(variableSymbol);
				  globalScopeNode.appendChild(variableElement); // Add in global scope
			  }
			  else {
				  if(isVarDeclaration) 
					  Environment.currentActivationRecord.addSymbol(variableSymbol);
				  currentNode.appendChild(variableElement); // Add in current node
			  }
		  }
	  } 
	  catch (ImmutableSymbolException e ) { /* This exception will not come since variable are always mutable */ }
	  catch(IllegalSymbolValueException e) { throw new CompilationException(e.getMessage()); } 
	  catch (TypeMismatchException e) { throw new CompilationException(e.getMessage()); }
	  return variableSymbolList;
  }}

// START : Adding procedure parameters in the list
UXMLElement ProcedureHeading(boolean isFunctionDeclaration) throws CompilationException :
{
	Token t = null;
	UXMLElement savedCurrentNode = currentNode, procedureNode = null, automaticVarNode = null, procedureParamNode = null;
	String procedureName = null, returnType = Constants.VOID;
	FunctionType functionType = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	ArrayList<Symbol>variableSymbolList = new ArrayList<Symbol>();
}
{
  < PROCEDURE > t = <ID > 
  { 
	  procedureName = t.image; 
	  functionType = new FunctionType(procedureName, true, returnType);
	  functionType.setNestedLevel(nestedLevelOfProcedure);
	  if(isFunctionDeclaration) {
		  currentProcedureName = procedureName; // Store the current procedure name
		  currentProcedure = functionType;
	  }
	  attributes.clear();
	  attributes.put(Constants.NAME, procedureName);
	  procedureNode = UXMLElementFactory.generateElement(isFunctionDeclaration? Constants.FUNCTION : Constants.FUNCTION_TYPE, attributes, null);
  }
  (
    < ROUND_START > 
    {
    	currentNode = procedureNode.appendChild(UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null)); 
    }
    (
    	// This is procedure as parameter
    	procedureParamNode =  ProcedureHeading(false) 
    	{ 
    		processProcedureHeading(procedureParamNode);
    		functionType.addSymbol(procedureParamNode.getSymbol()); // Add the procedure as an argument in current procedure
    		 // Add the symbol in global/local scope
			  if(globalVariableDeclaration) 
				  Environment.addGlobalSymbol(procedureParamNode.getSymbol());
			  else 
				  Environment.currentActivationRecord.addSymbol(procedureParamNode.getSymbol());
    	}
    	| 
    	// If isFunctionDeclaration is false, it means this procedure is one of the parameter and hence
    	// the variables that are being declared are actually just to provide signature of this procedure
    	// So skip adding such variables to the activation record.
    	variableSymbolList = VariableDefinition(isFunctionDeclaration)  
    	{
    		// Add the variables to current function 
    		for(int variableNo = 0; variableNo < variableSymbolList.size(); variableNo++) 
    			functionType.addSymbol(variableSymbolList.get(variableNo));
    	}
    ) 
    ( < STMT_TERMINATOR > 
    procedureParamNode =  ProcedureHeading(false) 
    { 
    	processProcedureHeading(procedureParamNode);
    	functionType.addSymbol(procedureParamNode.getSymbol()); // Add the procedure as an argument in current procedure
    	
		 // Add the symbol in global/local scope
		  if(globalVariableDeclaration) 
			  Environment.addGlobalSymbol(procedureParamNode.getSymbol());
		  else
			  Environment.currentActivationRecord.addSymbol(procedureParamNode.getSymbol());

    } 
    |
	// If isFunctionDeclaration is false, it means this procedure is one of the parameter and hence
	// the variables that are being declared are actually just to provide signature of this procedure
	// So skip adding such variables to the activation record.
    variableSymbolList = VariableDefinition(isFunctionDeclaration)
    {
		// Add the variables to current function 
		for(int variableNo = 0; variableNo < variableSymbolList.size(); variableNo++) 
			functionType.addSymbol(variableSymbolList.get(variableNo));
    }		
    )* <ROUND_END >
  )? 
  (<COLON> returnType = DataType())?
  {
	  attributes.clear();
	  attributes.put(Constants.TYPE, returnType);
	  procedureNode.appendChild(UXMLElementFactory.generateElement(Constants.RETURNS, attributes, null));
	  functionType.setReturnType(returnType);
	  try {
		  functionType.setReturnValue(SymbolMachine.generate(Constants.BLANK, returnType, true));
	  } catch(IllegalSymbolValueException e) { throw new CompilationException(e.getMessage()); } 
	  procedureNode.setSymbol(functionType);
	  currentNode = savedCurrentNode;
	  
	  return procedureNode;
  }
}


void Block()throws CompilationException :{
	UXMLElement savedCurrentNode = currentNode, block = null;}
{ 
	ScopeStart()
	{
	  block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
	  currentNode.appendChild(block);
	  currentNode = block;
    }
  	(
  	  Statement()
  	)*
  	ScopeEnd()
  	{
	  currentNode = savedCurrentNode;
  	}}

/**
 * Scope start
 * {
 */
void ScopeStart() : {}
{
	<BLOCK_START>	
	{
		Environment.currentActivationRecord.enterTheBlock();
	}
}

/**
 * Scope end
 * }
 */
void ScopeEnd() : {}
{
	<BLOCK_END>	
	{
		Environment.currentActivationRecord.leaveTheBlock();
	}
}

void Statement() throws CompilationException:{
	UXMLElement procCall = null;}
{
  Assignment() | IfElse() | ForLoop() | DoWhile() | WhileDo() | Write() | (procCall = ProcedureCall() <STMT_TERMINATOR> ) {currentNode.appendChild(procCall);}
  | Return() | <STMT_TERMINATOR>
  }

void Assignment() throws CompilationException :{
	UXMLElement lhsElement = null, rhsElement = null, savedCurrentNode = currentNode, assignment = null;
	Symbol lhsSymbol = null, rhsSymbol = null;
	HashMap<String,String> attributes = new HashMap<String, String>();}{
	lhsElement = VariableAccess(false) 
	<ASSIGN> 
	rhsElement = Expression()
	< STMT_TERMINATOR >
	{
		lhsSymbol = lhsElement.getSymbol();
		rhsSymbol = rhsElement.getSymbol();
		
		try {
			if(lhsSymbol instanceof ArrayType) 
				((ArrayType)lhsSymbol).copyArray(rhsSymbol);	
			else
				lhsSymbol.setValue(rhsSymbol);
		} catch(ImmutableSymbolException e) {
			throw new CompilationException(e.getMessage());
		} catch(TypeMismatchException e) { 
			throw new CompilationException(e.getMessage());
		} catch(IllegalSymbolValueException e) {
			throw new CompilationException(e.getMessage());
		} 
		assignment = UXMLElementFactory.generateElement(Constants.ASSIGN, null ,null);
		attributes.put(Constants.NAME, lhsSymbol.getName());
		if(rhsElement.getElement() == null)
			assignment.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,lhsSymbol));
		else
			assignment.appendChild(lhsElement);
		assignment.appendChild(rhsElement);
		currentNode.appendChild(assignment);
	}}

void IfElse() throws CompilationException :{
	UXMLElement parentNode = currentNode;
}{
  < IF > MultiConditions() < THEN >
  Block()
  (
    < ELSE >
    Block()  )? {  currentNode = parentNode; /*Restore the node*/ }
}

void MultiConditions() throws CompilationException : 
{
	Token t = null;
	UXMLElement parentNode = currentNode, savedCurrentNode = currentNode, not = null, condition = null, lhsCondition = null,rhsCondition = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	Symbol lhsSymbol = null, rhsSymbol = null;
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	String operatorName = null;
}
{
	try {
		/*(
			t = <NOT> {operatorName = t.image;}
		)? */
		lhsCondition = Condition()
		((
		t = <AND> {t.image = "$$";} | t = <OR> ) { operatorName = t.image; }
		rhsCondition = Condition()
		{
			lhsSymbol = lhsCondition.getSymbol();
			rhsSymbol = rhsCondition.getSymbol(); 
			attributes.clear();
			attributes.put(Constants.VALUE, operatorName);
			operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
			operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
			condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
			condition.appendChild(lhsCondition);
			condition.appendChild(rhsCondition);
			
			currentNode = savedCurrentNode;
			currentNode.appendChild(condition);
			
			savedCurrentNode = currentNode;
			lhsCondition = condition;
		}
		)*
		{
			if(condition != null)
				currentNode = condition;
		}
	} catch(IllegalSymbolValueException e) {
		throw new CompilationException(e.getMessage());
	} catch(OperatorNotFoundException e) {
		throw new CompilationException(e.getMessage());
	}
}

UXMLElement Condition() throws CompilationException :{
	Token t = null;
	UXMLElement lhsExpression = null, rhsExpression = null, condition = null;
	Symbol lhsSymbol = null, rhsSymbol = null;
	String operatorName = null;
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	HashMap<String,String> attributes = new HashMap<String, String>();
}{
	lhsExpression = Expression() 
	(( t = <EQ> {t.image = "==";} | t = <NT_EQ> | t = <LT> {t.image = "(";} | t = <LT_EQ> {t.image = "(=";}| t = <GT> {t.image = ")";} | t = <GT_EQ>{t.image = ")=";} ) 
	{ 
		operatorName = t.image;
	} 
	rhsExpression = Expression())?
	{
		lhsSymbol = lhsExpression.getSymbol();
		try {
			// Unary operator
			if(operatorName == null)
			{
				operatorName = "==";
				attributes.clear();
				attributes.put(Constants.VALUE, operatorName);
				operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
				condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
				condition.appendChild(lhsExpression);
				currentNode.appendChild(condition);
				currentNode = condition;
				return condition;
			}
			// Binary operator
			else {
				rhsSymbol = rhsExpression.getSymbol();
				attributes.clear();
				attributes.put(Constants.VALUE, operatorName);
				operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
				operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
				condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
				condition.appendChild(lhsExpression);
				condition.appendChild(rhsExpression);
				currentNode.appendChild(condition);
				currentNode = condition;
				return condition;
			}
		} catch(IllegalSymbolValueException e) {
			throw new CompilationException(e.getMessage());
		} catch(OperatorNotFoundException e) {
			throw new CompilationException(e.getMessage());
		}
	}
}

void ForLoop()throws CompilationException :{
	UXMLElement parentNode = currentNode, for_loop = null, controllerNode = null, savedCurrentNode = null;
	Symbol variableSymbol = null, variableValueSymbol = null, loopIndexSymbol = null;
	UXMLElement variableSymbolElement = null, variableValueElement = null, loopIndexElement = null, 
	initialValueElement = null, finalValueElement = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	boolean isUp = true;
	Token t = null;
}{
  < FOR >
  {
	for_loop = UXMLElementFactory.generateElement(Constants.FOR_LOOP, null, null);
	savedCurrentNode = currentNode; 
	currentNode.appendChild(for_loop);
	currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.FROM, null, null));
  }
  t = <ID >
  {
	  try {
		  loopIndexSymbol = Environment.getSymbol(t.image);
	  } catch(SymbolNotDefinedException e) { throw new CompilationException(e.getMessage());}
	  attributes.clear();
	  attributes.put(Constants.NAME, loopIndexSymbol.getName());
	  loopIndexElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,loopIndexSymbol);
  }
  <ASSIGN > 
  initialValueElement = Expression()
  {
	  // From
	  controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
	  controllerNode.appendChild(loopIndexElement);
	  controllerNode.appendChild(initialValueElement);
	  currentNode.appendChild(controllerNode);
	  try {
		  loopIndexElement.getSymbol().setValue(initialValueElement.getSymbol()); // Initialize the value as it might be used to access the array elements.
	  } catch(ImmutableSymbolException e) {}
	  catch (TypeMismatchException e) {}
	  catch(IllegalSymbolValueException e) {}
	  currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.TILL, null, null));
  }
  ( < TO > | < DOWNTO > {isUp = false;}) 
  finalValueElement = Expression() 
  {
	  // Till
	  attributes.clear();
	  attributes.put(Constants.VALUE, isUp? "(=" : ")="); // If TO then ++, else --
	  controllerNode = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
	  controllerNode.appendChild(loopIndexElement.getClone());
	  controllerNode.appendChild(finalValueElement);
	  currentNode.appendChild(controllerNode);
	  currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.STEP, null, null));
	  // Step
	  controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
	  controllerNode.appendChild(loopIndexElement.getClone());
	  currentNode = currentNode.appendChild(controllerNode);
	  
	  attributes.clear();
	  attributes.put(Constants.VALUE, isUp? "+" : "-"); // If TO then ++, else --
	  controllerNode = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
	  controllerNode.appendChild(loopIndexElement.getClone());
	  attributes.clear();
	  attributes.put(Constants.TYPE, Constants.INT);
	  attributes.put(Constants.VALUE, "1");
	  controllerNode.appendChild(UXMLElementFactory.generateElement(Constants.CONSTANT, attributes, null));
	  currentNode.appendChild(controllerNode);
	  currentNode = for_loop;
  }
  < DO >
  Block() { currentNode = parentNode; /* Restore the node */ }}

void DoWhile()throws CompilationException :{
	UXMLElement parentNode = currentNode, iterate = null, till = null;
}{
  < DO >
  {
	iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
	currentNode.appendChild(iterate);
	currentNode = iterate;
  }
  Block()
  < WHILE >
  {
	till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
	currentNode.appendChild(till);
	currentNode = till;
  }
  MultiConditions() < STMT_TERMINATOR > {currentNode = parentNode;  /*Restore the node*/ } }

void WhileDo() throws CompilationException:{
	UXMLElement parentNode = currentNode, iterate = null, till = null;
}{
  < WHILE >
  {
	iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
	currentNode.appendChild(iterate);
	currentNode = iterate;
	
	till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
	currentNode.appendChild(till);
	currentNode = till;
  }
  MultiConditions() { currentNode = iterate; } 
  < DO >
  Block() {currentNode = parentNode;  /*Restore the node*/ }}

void Return() throws CompilationException :
{
	UXMLElement returnExpression = null, returnElement = null;
	String requiredReturnType = null, foundReturnType = null;
	Symbol returnSymbol = null;
}
{
	<RETURN>
	returnExpression = Expression()
	{
		returnElement = UXMLElementFactory.generateElement(Constants.RETURN, null, null);
		returnSymbol = returnExpression.getSymbol();
		returnSymbol = (returnSymbol instanceof FunctionType)? ((FunctionType)returnSymbol).getReturnValue():returnSymbol;
		returnElement.appendChild(returnExpression);
		currentNode.appendChild(returnElement);
		
		// Try to set the return symbol into the return value of currentfunction. 
		// If the return-type is not compatible then error will be thrown
		try {
			requiredReturnType = DataTypeFinder.getDataType(currentProcedure.getReturnValue());
			foundReturnType = DataTypeFinder.getDataType(returnSymbol);
			if(requiredReturnType.equals(foundReturnType)) {
				Symbol returnValue = currentProcedure.getReturnValue();
				if(returnValue instanceof ArrayType)
					((ArrayType) returnValue).copyArray(returnSymbol);
			}
			else
				throw new TypeMismatchException(foundReturnType,requiredReturnType);
			isReturnStmtPresent = true;
		  } catch(TypeMismatchException e) {
			  throw new CompilationException("Procedure '" + currentProcedureName
					  + "' should return '" + requiredReturnType + "' and not '"  + foundReturnType + "'.",e.getMessage());
		  } catch(SymbolNotDefinedException e) {System.err.println(e.getMessage());}
	}
	<STMT_TERMINATOR>
}

void Write()throws CompilationException :
{
	Token t = null;
	UXMLElement print, expression;
}
{
	(t = <WRITE> | t = <WRITELN>) 
	{
		print = UXMLElementFactory.generateElement(t.image.replaceAll("write","print"), null, null);
	}
	<ROUND_START>
		expression = Expression()
		{
			print.appendChild(expression);
		}
		(
			<COMMA>
			expression = Expression()
			{
				print.appendChild(expression);
			}
		)*
	<ROUND_END>
	<STMT_TERMINATOR>
	{
		currentNode.appendChild(print);
	}
}

UXMLElement ProcedureCall() throws CompilationException:
{
	Token t = null;
	UXMLElement argumentElement = null, call = null, function = null;
	String functionName = null;
	Symbol argumentSymbol = null, functionType = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
	FunctionType functionSymbol = null;
}
{ 
	<CALL> 
	function  = VariableAccess(true) 
	{
		functionType = function.getSymbol();
		functionName = functionType.getName();
		call = UXMLElementFactory.generateElement(Constants.CALL, null, null);
		attributes.clear();
		if(!(Constants.OPERATOR.equals(function.getElementName()) && 
						Constants.VALUE_OF.equals(function.getAttributeValue(Constants.VALUE)))) 
		{
			attributes.put(Constants.NAME, functionName);
			call.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,functionType));
		} else {
			call.appendChild(function);	
		}
	}
	<ROUND_START> argumentElement = Expression() 
	{
		argumentSymbol = argumentElement.getSymbol();
		// Check if expression is void and if yes, then no-argument function call is made
		if(!Constants.VOID.equals(argumentSymbol.getType())) {
			actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
			call.appendChild(argumentElement);
		}
	} 
	(<COMMA> 
	argumentElement = Expression()
	{
		argumentSymbol = argumentElement.getSymbol();
		actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
		call.appendChild(argumentElement);
	}
	
	)* <ROUND_END>
	{
		try {
			// If this is the recursive call, then just extract the current Procedure
			if(functionName.equals(currentProcedureName)) 
				functionSymbol = currentProcedure;
			else {
				/*argumentSymbol = Environment.getSymbol(functionName);
				
				if(!(argumentSymbol instanceof OverloadedFunctionType))
					throw new CompilationException("Type mismatch \n Found    : '" + functionName + DataTypeFinder.getDataType(argumentSymbol) + "' \n Required : '" + functionName + "'");
				
				// Get the function
				functionSymbol = ((OverloadedFunctionType) argumentSymbol).getFunction(actualArgs);*/
				
				if(!(functionType instanceof OverloadedFunctionType))
					throw new CompilationException("Type mismatch \n Found    : '" + functionName + DataTypeFinder.getDataType(functionType) + "' \n Required : '" + functionName + "'");
				
				// Get the function
				functionSymbol = ((OverloadedFunctionType) functionType).getFunction(actualArgs);
				
			}
		} catch (SymbolNotDefinedException e) {
			throw new CompilationException(e.getMessage());
		}
		call.setSymbol(functionSymbol);
		return call;
	}
}

UXMLElement VariableAccess(boolean isFunctionCall) throws CompilationException :
{
	Token t = null;
	String variableName = null;
	Symbol variableSymbol = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
	UXMLElement variableSymbolElement = null;
}
{
	t = <ID>
	{
		try {
			variableName = t.image;
			// If this is a function call, then simply store the current procedure.
			// This trick is to enable recursive calls
			if(isFunctionCall && variableName.equals(currentProcedureName)) 
				variableSymbol = currentProcedure;
			else 
				variableSymbol = Environment.getSymbol(variableName);
			attributes.clear();
			attributes.put(Constants.NAME, variableSymbol.getName());
			variableSymbolElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol);
		} catch(SymbolNotDefinedException e) {throw new CompilationException(e.getMessage());}
	}
	variableSymbolElement = ArrayAccess(variableSymbolElement) { return variableSymbolElement; }
}

/**
 * E -> T1 E_L
 */
UXMLElement Expression() throws CompilationException : 
{
	UXMLElement restOfExpression = null;
}
{
	restOfExpression = Expression_Left(Term1())
	{
		return restOfExpression;
	}
}

/**
 * E_L -> (& | | | ^ ) T1 E_L
 */
UXMLElement Expression_Left(UXMLElement currentLHS)throws CompilationException : 
{
	Token t = null;
	UXMLElement currentRHS = null,restOfExpression = null;
	UXMLElement operator = null;
	Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	String operatorName = null;
}
{
	[
	 (t = <AMPERSAND> {t.image = "$";} | t = <BIT_OR> | t = <BIT_XOR> )
	 {
		 operatorName = t.image;
	 }
	 currentRHS = Term1() 
	 {
		 rhsSymbol = currentRHS.getSymbol();
		 try {
			 attributes.put(Constants.VALUE,operatorName);
			 operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
			 operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
			 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
			 currentNode.appendChild(operator);
			 operator.appendChild(currentLHS);
			 operator.appendChild(currentRHS);
			 currentLHS = operator;
		 } catch(IllegalSymbolValueException e) {
			 throw new CompilationException(e.getMessage());
		 } catch(OperatorNotFoundException e) {
			 throw new CompilationException(e.getMessage());
		 }
	 }
	 restOfExpression = Expression_Left(currentLHS)
	]
	{
		if(restOfExpression == null)
			restOfExpression = currentLHS;
		return restOfExpression;
	 }
}


/**
 * T1 -> T2 T1_L
 */
UXMLElement Term1()throws CompilationException  : 
{
	UXMLElement restOfExpression = null;
}
{	
	restOfExpression = Term1_Left(Term2())
	{
		return restOfExpression;
	}
}

/**
 * T1_L -> (+ | -) T2 T1_L
 */
UXMLElement Term1_Left(UXMLElement currentLHS)throws CompilationException  :  
{
	Token t = null;
	UXMLElement currentRHS = null,restOfExpression = null;
	UXMLElement operator = null;
	Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	String operatorName = null;
}
{
	[
	 (t  = <PLUS> | t  = <MINUS>)
	 {
		 operatorName = t.image;
	 }
	 
	 currentRHS = Term2()  
	 {

		 try {
			 rhsSymbol = currentRHS.getSymbol();
			 attributes.put(Constants.VALUE,operatorName);
			 operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
			 operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
			 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
			 currentNode.appendChild(operator);
			 operator.appendChild(currentLHS);
			 operator.appendChild(currentRHS);
			 currentLHS = operator;
		 } catch(IllegalSymbolValueException e) {
			 throw new CompilationException(e.getMessage());
		 } catch(OperatorNotFoundException e) {
			 throw new CompilationException(e.getMessage());
		 }
	 }
	 restOfExpression = Term1_Left(currentLHS)
	 
	 ]
	 {
		if(restOfExpression == null)
			restOfExpression = currentLHS;
		return restOfExpression;
	 }
}

/**
 * T2 -> F T2_L
 */
UXMLElement Term2() throws CompilationException : 
{
	UXMLElement restOfExpression = null;
}
{
	restOfExpression = Term2_Left( Factor())
	{
		return restOfExpression;
	}
}

/**
 * T2_L -> (* | / | %) F T2_L
 */
UXMLElement Term2_Left(UXMLElement currentLHS) throws CompilationException : 
{
	Token t = null;
	UXMLElement currentRHS = null,restOfExpression = null;
	UXMLElement operator = null;
	Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	String operatorName = null;
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
}
{
	[
	 (t = <ASTERISK> | t = <DIVIDE > | t = <MOD>) 
	 {
		 operatorName = t.image;
	 }
	 currentRHS = Factor()  
	 {
		 try {
			 rhsSymbol = currentRHS.getSymbol();
			 attributes.put(Constants.VALUE,operatorName);
			 operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
			 operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
			 // Make sure that div doesn't give divide by zero error
			 try {
				 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
			 } catch(RuntimeException e) 
			 {
				 Symbol param1 = operands.get(0);
				 Symbol param2 = operands.get(1);
				 if(param1.getDataType() == DATA_TYPE.FLOAT || param2.getDataType() == DATA_TYPE.FLOAT)
					 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, 
							 SymbolMachine.generate(Constants.BLANK, Constants.FLOAT, true));
				 else 
					 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, 
							 SymbolMachine.generate(Constants.BLANK, Constants.INT, true));
			 }
			 currentNode.appendChild(operator);
			 operator.appendChild(currentLHS);
			 operator.appendChild(currentRHS);
			 currentLHS = operator;
		 } catch(IllegalSymbolValueException e) {
			 throw new CompilationException(e.getMessage());
		 } catch(OperatorNotFoundException e) {
			 throw new CompilationException(e.getMessage());
		 }
	 }
	 restOfExpression = Term2_Left(currentLHS)
	 ]
	 {
		if(restOfExpression == null)
			restOfExpression = currentLHS;
		return restOfExpression;
	 }
} 

/** 
 * F -> (E) | VariableAccess() | Constant() | <VOID> | FunctionCall()
 */
UXMLElement Factor() throws CompilationException : 
{
	Token t = null;
	String typeCast = null;
	Symbol value = null;
	UXMLElement expressionValue = null, returnFactorValue = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
}
{
	(<SQUARE_START> ( t = < INT > | t = < FLOAT > | t  = < CHAR > | t  =< BOOL > ) {typeCast = t.image; }  <SQUARE_END>)?
	(
	<ROUND_START> expressionValue = Expression() { returnFactorValue =  expressionValue ;  } <ROUND_END>
	| expressionValue = VariableAccess(false) 
		{
			value = expressionValue.getSymbol();
			
			if((!(Constants.OPERATOR.equals(expressionValue.getElementName()) && 
							Constants.VALUE_AT_INDEX.equals(expressionValue.getAttributeValue(Constants.VALUE))))) {
				attributes.clear();
				attributes.put(Constants.NAME, expressionValue.getSymbol().getName());
				expressionValue = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,expressionValue.getSymbol());
			}
			returnFactorValue = expressionValue;
		}
	| value = Constants() { returnFactorValue =  new UXMLElement(null,value); }
	| expressionValue = ProcedureCall() { returnFactorValue = expressionValue; }
	| <VOID> {try { returnFactorValue =  new UXMLElement(null,SymbolMachine.generate(Constants.BLANK,Constants.VOID, false));  } catch(Exception e ){}} 
	
	)
	{
		try {
			if(typeCast != null) {
				attributes.put(Constants.TYPE, typeCast);
				expressionValue = UXMLElementFactory.generateElement(Constants.CAST ,attributes, SymbolMachine.cast(returnFactorValue.getSymbol(), typeCast));
				expressionValue.appendChild(returnFactorValue);
				returnFactorValue = expressionValue;
			}
		} catch(TypeMismatchException e) {
			throw new CompilationException(e.getMessage());
		} catch (SymbolNotDefinedException e) {
			throw new CompilationException(e.getMessage());
		} catch (IllegalSymbolValueException e) {
			throw new CompilationException(e.getMessage());
		}
		return returnFactorValue;
	}
	
}
