/* Generated By:JavaCC: Do not edit this line. P.java */
package parserOfP;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Scanner;

import compiler.components.*;
import compiler.dataTypes.*;
import compiler.exceptions.*;
import compiler.operator.*;
import compiler.util.*;
import compiler.util.Constants.DATA_TYPE;
import compiler.uXMLGenerator.*;

import xvHandler.Executor;
import xvHandler.CodeAnalysis;
import xvHandler.ProcedureCallSeq;

import parserOfP.exceptions.*;

@SuppressWarnings("all")
public class P implements PConstants {

        private static UXMLElement currentNode = null;
        private static UXMLElement globalScopeNode = null;
        private static String currentProcedureName = null;
        private static FunctionType currentProcedure = null;
    private static boolean globalVariableDeclaration = false;
    private static boolean isReturnStmtPresent = false;
    private static int nestedLevelOfProcedure = 0; // Represents the nested level of a procedure

        public static void main(String args[]) throws ParseException {
                FileInputStream io = null;
                String codeAnalysisFlag = null;

                String fileName = null;
            if(args.length == 0) {
                Scanner in = new Scanner(System.in);
                System.out.print("Enter the file name @ src/samplePLikeProgs/");
                fileName = in.nextLine();
                while(fileName.trim().length() == 0)
                        fileName = in.nextLine();
                codeAnalysisFlag = in.nextLine();
                args = new String[1];
                args[0] = fileName;
            }
            else {
                fileName = args[0];
                if(args.length > 1)
                        codeAnalysisFlag = args[1];
            }

            try {
                io = new FileInputStream("src/samplePLikeProgs/" + fileName + ".Plike");
                P parser = new P(io);

                // Initialize the environment with ignore dynamic variable flag
                Environment.initialize(new ProcedureCallSeq(), true);
                // Initialize the uXMLDocument generator
                currentNode = UXMLElementFactory.initialize("Plike", Constants.STATIC);

                Environment.currentActivationRecord.enterTheBlock();
                parser.PLike();
                Environment.currentActivationRecord.leaveTheBlock();

                // Save the uXML document
                UXMLElementFactory.done(fileName);

                if("-analysis".equals(codeAnalysisFlag))
                        CodeAnalysis.main(args);
                else
                        Executor.main(args);

            } catch (FileNotFoundException fe) {
                System.err.println("File '" + fileName + "' not found.");
                System.exit(1);
            } catch(ParseException e) {
                String message = e.getMessage();
                int startIndex = message.indexOf("line ") + 5;
                int endIndex = message.indexOf(",");
                String lineNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("column ") + 7;
                endIndex = message.indexOf(".");
                String columnNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("\"") + 1;
                endIndex = message.lastIndexOf("\" at line");
                String keyword = message.substring(startIndex, endIndex).replaceAll("\"","").trim();

                System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
                StringBuffer expectedTokens = new StringBuffer("Expected tokens : ");
                String tokenValue = null;
                tokenValue = tokenImage[e.expectedTokenSequences[0][0]];
                tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                expectedTokens.append(tokenValue);
                for(int tokenId = 1; tokenId < e.expectedTokenSequences.length;tokenId++) {
                        tokenValue = tokenImage[e.expectedTokenSequences[tokenId][0]];
                        tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                        expectedTokens.append(", ")
                                .append(tokenValue);
                }
                System.err.println(expectedTokens.toString());
            } catch(TokenMgrError e) {
                String message = e.getMessage();
                        int startIndex = message.indexOf("line ") + 5;
                        int endIndex = message.indexOf(",");
                        String lineNo = message.substring(startIndex, endIndex).trim();

                        startIndex = message.indexOf("column ") + 7;
                        endIndex = message.indexOf(".");
                        String columnNo = message.substring(startIndex, endIndex).trim();

                        startIndex = message.indexOf("\"") + 1;
                        endIndex = message.indexOf("\"",startIndex);
                        String keyword = message.substring(startIndex, endIndex).trim();

                        System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
            }
            catch(CompilationException e) {
                System.err.println(e.getMessage());
            }
  }

    private static void processProcedureHeading(UXMLElement procedureParamNode) {
                HashMap<String, String> attributes = new HashMap<String, String>();
                FunctionType procedureParam = (FunctionType)procedureParamNode.getSymbol();
                FunctionType cloneOfProcParam = (FunctionType)Clone.deepCopySymbol(procedureParam); // Create the clone
                String procedureSignature = cloneOfProcParam.getReturnType()+cloneOfProcParam.getSignature(); // Set its name as the signature

                attributes.clear();
                attributes.put(Constants.NAME,procedureParam.getName());
                attributes.put(Constants.TYPE,procedureSignature);
                attributes.put(Constants.MUTABLE,"yes");

                currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, procedureParam));

                // If present in global scope, then don't add else add it
                if(!Environment.isSymbolPresentInGlobalScope(procedureSignature)) {
                        cloneOfProcParam.setName(procedureSignature); // Change the name to proc signature
                        procedureParamNode.setAttributeValue(Constants.NAME,procedureSignature); // Change the name to proc signature

                        Environment.addGlobalSymbol(cloneOfProcParam); // Add the function-type in global table
                        globalScopeNode.appendChild(procedureParamNode);
                }
        }

// Possible allowable constants
  final public Symbol Constants() throws ParseException, CompilationException {
                                                  Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_CONSTANT:
        t = jj_consume_token(INT_CONSTANT);
                                        {if (true) return new ConstantValue(Constants.INT,t.image);}
        break;
      case FLOAT_CONSTANT:
        t = jj_consume_token(FLOAT_CONSTANT);
                                           {if (true) return new ConstantValue(Constants.FLOAT,t.image);}
        break;
      case CHAR_CONSTANT:
        t = jj_consume_token(CHAR_CONSTANT);
                        String ch = t.image.substring(1,2);
                        {if (true) return new ConstantValue(Constants.CHAR,ch);}
        break;
      case STRING_CONSTANT:
        t = jj_consume_token(STRING_CONSTANT);
                        String str = t.image;
                        str = str.substring(1, str.length() - 1);
                        {if (true) return new ConstantValue(Constants.STRING,str);}
        break;
      case BOOL_CONSTANT:
        t = jj_consume_token(BOOL_CONSTANT);
                                         {if (true) return new ConstantValue(Constants.BOOLEAN,t.image);}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

// Possible allowable data-types
  final public String DataType() throws ParseException, CompilationException {
        Token t = null;
        String dataType = null;
        StringBuffer dimSizeType = new StringBuffer();
        Symbol baseElement = null;
        int startIndex, endIndex = 0;
        ArrayList<Integer> dimSize, dimStartIndex = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        UXMLElement arrayNodeElement = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
    case FLOAT:
    case CHAR:
    case BOOL:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
        break;
      case CHAR:
        t = jj_consume_token(CHAR);
        break;
      case BOOL:
        t = jj_consume_token(BOOL);
        break;
      case STRING:
        t = jj_consume_token(STRING);
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                                              {if (true) return  t.image;}
      break;
    case ARRAY:
      try {
        jj_consume_token(ARRAY);
                dimSize = new ArrayList<Integer>(); dimStartIndex = new ArrayList<Integer>();

                // Create an array-type having blank name and type. Update it once with appropriate name/type. 
                attributes.put(Constants.NAME, Constants.BLANK);
                attributes.put(Constants.TYPE, Constants.BLANK);
                arrayNodeElement = UXMLElementFactory.generateElement(Constants.ARRAY_TYPE, attributes, null);
        jj_consume_token(SQUARE_START);
        t = jj_consume_token(INT_CONSTANT);
                            startIndex = Integer.parseInt(t.image); dimStartIndex.add(startIndex);
        jj_consume_token(PERIOD);
        jj_consume_token(PERIOD);
        t = jj_consume_token(INT_CONSTANT);
                endIndex = Integer.parseInt(t.image);
                if(startIndex >= endIndex) {{if (true) throw new CompilationException("Start-index '" + startIndex + "' can never be greater than equal to end-index '" + endIndex +"'.");}}
                dimSize.add(endIndex - startIndex + 1);
                dimSizeType.append(startIndex + ".." + endIndex);
                // Append 'dim'
                attributes.clear();
                attributes.put(Constants.SIZE, String.valueOf(endIndex - startIndex + 1));
                if(startIndex != 0)
                        attributes.put(Constants.START_INDEX, String.valueOf(startIndex));
                arrayNodeElement.appendChild(UXMLElementFactory.generateElement(Constants.DIM, attributes, null));
        label_1:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[2] = jj_gen;
            break label_1;
          }
          jj_consume_token(COMMA);
          t = jj_consume_token(INT_CONSTANT);
                            startIndex = Integer.parseInt(t.image); dimStartIndex.add(startIndex);
          jj_consume_token(PERIOD);
          jj_consume_token(PERIOD);
          t = jj_consume_token(INT_CONSTANT);
                endIndex = Integer.parseInt(t.image);
                if(startIndex >= endIndex) {{if (true) throw new CompilationException("Start-index '" + startIndex + "' can never be greater than equal to end-index '" + endIndex +"'.");}}
                dimSize.add(endIndex - startIndex + 1);
                dimSizeType.append("," + startIndex + ".." + endIndex);
                // Append 'dim'
                attributes.clear();
                attributes.put(Constants.SIZE, String.valueOf(endIndex - startIndex + 1));
                if(startIndex != 0)
                        attributes.put(Constants.START_INDEX, String.valueOf(startIndex));
                arrayNodeElement.appendChild(UXMLElementFactory.generateElement(Constants.DIM, attributes, null));
        }
        jj_consume_token(SQUARE_END);
        jj_consume_token(OF);
        dataType = DataType();
                baseElement = SymbolMachine.generate(Constants.BLANK, dataType, true);
                        ArrayType arrayType = (ArrayType)SymbolMachine.generate(Constants.BLANK, Constants.ARRAY, true);
                        arrayType.initializeArray(dimSize, dimStartIndex, baseElement);

                        // Set the array element's base-type
                        arrayNodeElement.setAttributeValue(Constants.TYPE,dataType);

                        dataType = DataTypeFinder.getDataType(arrayType) + dimSizeType;
                        arrayType.setName(dataType);

                        // Set the Name of array-type
                        arrayNodeElement.setAttributeValue(Constants.NAME,dataType);

                        // If not yet defined, then append it to currentNode
                        if(!Environment.currentActivationRecord.isSymbolPresent(dataType) &&
                                        !Environment.isSymbolPresentInGlobalScope(dataType)) {

                                if(globalVariableDeclaration)
                                        globalScopeNode.appendChild(arrayNodeElement); // Add in global scope
                                else
                                        currentNode.appendChild(arrayNodeElement); // Else add in current node
                        }


                        // Add the symbol in global/local scope
                        if(globalVariableDeclaration)
                                Environment.addGlobalSymbol(arrayType);
                        else
                                Environment.currentActivationRecord.addSymbol(arrayType);
                        {if (true) return dataType;}
      } catch (IllegalSymbolValueException e) {
                                                {if (true) throw new CompilationException(e.getMessage());}
      } catch (ImmutableSymbolException e) {
                                             {if (true) throw new CompilationException(e.getMessage());}
      } catch (TypeMismatchException e) {
                                          {if (true) throw new CompilationException(e.getMessage());}
      } catch (SymbolNotDefinedException e) {
                                              {if (true) throw new CompilationException(e.getMessage());}
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Array Access
 *  ([ Expression() ])* 
 */
  final public UXMLElement ArrayAccess(UXMLElement variableElement) throws ParseException, CompilationException {
        Token t = null;
        int index = 0;
        HashMap<String, String> attributes = new HashMap<String, String> ();
        attributes.put(Constants.VALUE, "[]");
        UXMLElement operator = null,
        indexElement = null,returnElement = operator;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        Symbol arrayElementAtIndex = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQUARE_START:
        jj_consume_token(SQUARE_START);
        indexElement = Expression();
                        operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
                        operator.appendChild(variableElement);
                        operator.appendChild(indexElement);
                        operands.clear();
                        operands.add(variableElement.getSymbol());
                        operands.add(indexElement.getSymbol());
                        arrayElementAtIndex = Operator.execute("[]", operands);
                        operator.setSymbol(arrayElementAtIndex);
                        variableElement = operator;
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_2;
          }
          jj_consume_token(COMMA);
          indexElement = Expression();
                        operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
                        operator.appendChild(variableElement);
                        operator.appendChild(indexElement);
                        operands.clear();
                        operands.add(variableElement.getSymbol());
                        operands.add(indexElement.getSymbol());
                        arrayElementAtIndex = Operator.execute("[]", operands);
                        operator.setSymbol(arrayElementAtIndex);
                        variableElement = operator;
        }
        jj_consume_token(SQUARE_END);
        break;
      default:
        jj_la1[5] = jj_gen;
        ;
      }
                      {if (true) return variableElement;}
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    } catch (OperatorNotFoundException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

  final public void PLike() throws ParseException, CompilationException {
        UXMLElement savedCurrentNode = currentNode, block = null;
    HeadingSection();
                globalVariableDeclaration = true; // Switch on the global declaration flag
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
                globalScopeNode = UXMLElementFactory.generateElement(Constants.GLOBAL_VAR, null, null);
                currentNode.appendChild(globalScopeNode);
    DeclarationSection();
                globalVariableDeclaration = false; // Switch off the global declaration flag
//		block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
//		currentNode.appendChild(block);
//		currentNode = block;

    ScopeStart();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case DO:
      case WHILE:
      case FOR:
      case CALL:
      case WRITE:
      case WRITELN:
      case RETURN:
      case STMT_TERMINATOR:
      case ID:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      Statement();
    }
    ScopeEnd();
                currentNode = savedCurrentNode;
  }

  final public void HeadingSection() throws ParseException {
    jj_consume_token(PROGRAM);
    jj_consume_token(ID);
    jj_consume_token(STMT_TERMINATOR);
  }

  final public void DeclarationSection() throws ParseException, CompilationException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
      ConstantDeclaration();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
      VariableDeclaration();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROCEDURE:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
      ProcedureDeclaration();
    }
  }

// Constant declaration
  final public void ConstantDeclaration() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement savedCurrentNode = currentNode, constantElement = null, constantExprElement = null;
        String paramName = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        Symbol constantVar = null, constantValue = null;
    try {
      jj_consume_token(CONST);
      label_5:
      while (true) {
        t = jj_consume_token(ID);
                               paramName = t.image;
        jj_consume_token(ASSIGN);
        constantExprElement = Expression();
                          constantValue = constantExprElement.getSymbol();
                          constantVar = SymbolMachine.generate(paramName, constantValue.getType(), false);
                          attributes.clear();
                          attributes.put(Constants.NAME, paramName);
                          attributes.put(Constants.TYPE, constantValue.getType());
                          attributes.put(Constants.MUTABLE, "no"); // Make it non-mutable
                          constantElement = UXMLElementFactory.generateElement(Constants.VAR, attributes, constantVar);
                          constantElement.appendChild(constantExprElement);

                        // Add the symbol in global/local scope
                          if(globalVariableDeclaration) {
                                  Environment.addGlobalSymbol(constantVar);
                                  globalScopeNode.appendChild(constantElement); // Add in global scope
                          }
                          else {
                                  Environment.currentActivationRecord.addSymbol(constantVar);
                                  currentNode.appendChild(constantElement); // Add in current node
                          }
        jj_consume_token(STMT_TERMINATOR);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
      }
    } catch (IllegalSymbolValueException e) {
                                              {if (true) throw new CompilationException(e.getMessage());}
    }
  }

// Variable declaration
  final public void VariableDeclaration() throws ParseException, CompilationException {
    jj_consume_token(VAR);
    label_6:
    while (true) {
      VariableDefinition(true);
      jj_consume_token(STMT_TERMINATOR);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_6;
      }
    }
  }

// Procedure Declaration
  final public void ProcedureDeclaration() throws ParseException, CompilationException {
        // Save the global variable declaration status
        boolean originalGlobalVariableStatus = globalVariableDeclaration;
        globalVariableDeclaration = false; // Make status false so that variables won't be added at global-level
        UXMLElement procedureNode = null, savedCurrentNode = currentNode, block = null;
        nestedLevelOfProcedure++; // Increase the nested level
        Symbol functionType = null;
        FunctionType savedCurrentProcedure = null;
        String savedCurrentProcedureName = null;
                // Execute the calling sequence of a caller - 
        Environment.callSequenceProcessor.callAction_caller(nestedLevelOfProcedure);
        // There may be the case that arguments to the function are function-pointers or like that which
        // are needed to add in symbol table, for that the method call 'enterTheBlock()' is necessary so that
        // symbol table will be created.
        Environment.currentActivationRecord.enterTheBlock();
    procedureNode = ProcedureHeading(true);
    jj_consume_token(STMT_TERMINATOR);
                currentNode = currentNode.appendChild(procedureNode);
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
                // Save the currentProcedureName since the value of static variable could be changed in DeclarationSection() 
                savedCurrentProcedureName = currentProcedureName;
                savedCurrentProcedure = currentProcedure;
    DeclarationSection();
          currentProcedureName = savedCurrentProcedureName;  /*Restore the currentProcedureName */
          currentProcedure = savedCurrentProcedure;
    jj_consume_token(BLOCK_START);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case DO:
      case WHILE:
      case FOR:
      case CALL:
      case WRITE:
      case WRITELN:
      case RETURN:
      case STMT_TERMINATOR:
      case ID:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_7;
      }
      Statement();
    }
    jj_consume_token(BLOCK_END);
                // If function is defined to return a value and return statement is not present in function definition
                // or if function is defined to return void and if return statement is present 
                // then throw error  
                if(!Constants.VOID.equals(currentProcedure.getReturnType()) && !isReturnStmtPresent)
                        {if (true) throw new CompilationException("'" + currentProcedureName + "' should return a value of type '"
                                        + currentProcedure.getReturnType() + "'.");}
                else if(Constants.VOID.equals(currentProcedure.getReturnType())&& isReturnStmtPresent )
                        {if (true) throw new CompilationException("'" + currentProcedureName + "' declared as 'void' should not return a value.");}
                else
                        isReturnStmtPresent = false;

                // Function done
                Environment.callSequenceProcessor.returnAction_caller();

                functionType = procedureNode.getSymbol(); // Extract the functiontype that is being defined.
                // If this is the function declaration, then add the function in appropriate symtab
                if(globalVariableDeclaration)
                        Environment.addGlobalSymbol(functionType);
                else
                        Environment.currentActivationRecord.addSymbol(functionType);

                globalVariableDeclaration = originalGlobalVariableStatus; // Restore the global var status
                currentNode = savedCurrentNode;
                nestedLevelOfProcedure--; // Decrease the nested level

  }

/*
 * isVarDeclaration - Used to specify if the variable has to be added in the symtab or not.
 * Used when the variables are listed in the procedure signature which itself is a parameter
 * to a procedure.
 */
  final public ArrayList<Symbol> VariableDefinition(boolean isVarDeclaration) throws ParseException, CompilationException {
        Token t = null;
        ArrayList<String> variableNameList = new ArrayList<String>();
        ArrayList<Symbol> variableSymbolList = new ArrayList<Symbol>();
        String variableName = null, dataType = null;
        Symbol variableValue = null, variableSymbol;
        UXMLElement variableElement = null, variableValueElement = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
    t = jj_consume_token(ID);
              variableNameList.add(t.image);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      t = jj_consume_token(ID);
              variableNameList.add(t.image);
    }
    jj_consume_token(COLON);
    dataType = DataType();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      variableValueElement = Expression();
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
          attributes.put(Constants.TYPE, dataType);
          attributes.put(Constants.MUTABLE, "yes");

          try {
                  for(int variableNo = 0; variableNo < variableNameList.size(); variableNo++) {
                          variableName = variableNameList.get(variableNo);
                          variableSymbol = SymbolMachine.generate(variableName, dataType, true);
                          variableSymbolList.add(variableSymbol);

                          attributes.put(Constants.NAME, variableName);
                          variableElement = UXMLElementFactory.generateElement(Constants.VAR, attributes, variableSymbol);


                          // If initial value is assigned
                          if(variableValueElement != null) {
                                  // Extract the value
                                  variableValue = variableValueElement.getSymbol();
                                  variableElement.appendChild(variableValueElement);
                                  variableSymbol.setValue(variableValue instanceof FunctionType? ((FunctionType)(variableValue)).getReturnValue() : variableValue);
                          }

                          // Add the symbol in global/local scope
                          if(globalVariableDeclaration) {
                                  // This is used to avoid adding variables that are declared in procedure heading that are
                                  // actually one of the parameter to the procedure
                                  if(isVarDeclaration)
                                          Environment.addGlobalSymbol(variableSymbol);
                                  globalScopeNode.appendChild(variableElement); // Add in global scope
                          }
                          else {
                                  if(isVarDeclaration)
                                          Environment.currentActivationRecord.addSymbol(variableSymbol);
                                  currentNode.appendChild(variableElement); // Add in current node
                          }
                  }
          }
          catch (ImmutableSymbolException e ) { /* This exception will not come since variable are always mutable */ }
          catch(IllegalSymbolValueException e) { {if (true) throw new CompilationException(e.getMessage());} }
          catch (TypeMismatchException e) { {if (true) throw new CompilationException(e.getMessage());} }
          {if (true) return variableSymbolList;}
    throw new Error("Missing return statement in function");
  }

// START : Adding procedure parameters in the list
  final public UXMLElement ProcedureHeading(boolean isFunctionDeclaration) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement savedCurrentNode = currentNode, procedureNode = null, automaticVarNode = null, procedureParamNode = null;
        String procedureName = null, returnType = Constants.VOID;
        FunctionType functionType = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol>variableSymbolList = new ArrayList<Symbol>();
    jj_consume_token(PROCEDURE);
    t = jj_consume_token(ID);
          procedureName = t.image;
          functionType = new FunctionType(procedureName, true, returnType);
          functionType.setNestedLevel(nestedLevelOfProcedure);
          if(isFunctionDeclaration) {
                  currentProcedureName = procedureName; // Store the current procedure name
                  currentProcedure = functionType;
          }
          attributes.clear();
          attributes.put(Constants.NAME, procedureName);
          procedureNode = UXMLElementFactory.generateElement(isFunctionDeclaration? Constants.FUNCTION : Constants.FUNCTION_TYPE, attributes, null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROUND_START:
      jj_consume_token(ROUND_START);
        currentNode = procedureNode.appendChild(UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROCEDURE:
        // This is procedure as parameter
                procedureParamNode = ProcedureHeading(false);
                processProcedureHeading(procedureParamNode);
                functionType.addSymbol(procedureParamNode.getSymbol()); // Add the procedure as an argument in current procedure
                 // Add the symbol in global/local scope
                          if(globalVariableDeclaration)
                                  Environment.addGlobalSymbol(procedureParamNode.getSymbol());
                          else
                                  Environment.currentActivationRecord.addSymbol(procedureParamNode.getSymbol());
        break;
      case ID:
        // If isFunctionDeclaration is false, it means this procedure is one of the parameter and hence
                // the variables that are being declared are actually just to provide signature of this procedure
                // So skip adding such variables to the activation record.
                variableSymbolList = VariableDefinition(isFunctionDeclaration);
                // Add the variables to current function 
                for(int variableNo = 0; variableNo < variableSymbolList.size(); variableNo++)
                        functionType.addSymbol(variableSymbolList.get(variableNo));
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STMT_TERMINATOR:
        case ID:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_9;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STMT_TERMINATOR:
          jj_consume_token(STMT_TERMINATOR);
          procedureParamNode = ProcedureHeading(false);
        processProcedureHeading(procedureParamNode);
        functionType.addSymbol(procedureParamNode.getSymbol()); // Add the procedure as an argument in current procedure

                 // Add the symbol in global/local scope
                  if(globalVariableDeclaration)
                          Environment.addGlobalSymbol(procedureParamNode.getSymbol());
                  else
                          Environment.currentActivationRecord.addSymbol(procedureParamNode.getSymbol());
          break;
        case ID:
          // If isFunctionDeclaration is false, it means this procedure is one of the parameter and hence
                  // the variables that are being declared are actually just to provide signature of this procedure
                  // So skip adding such variables to the activation record.
              variableSymbolList = VariableDefinition(isFunctionDeclaration);
                // Add the variables to current function 
                for(int variableNo = 0; variableNo < variableSymbolList.size(); variableNo++)
                        functionType.addSymbol(variableSymbolList.get(variableNo));
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(ROUND_END);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      returnType = DataType();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
          attributes.clear();
          attributes.put(Constants.TYPE, returnType);
          procedureNode.appendChild(UXMLElementFactory.generateElement(Constants.RETURNS, attributes, null));
          functionType.setReturnType(returnType);
          try {
                  functionType.setReturnValue(SymbolMachine.generate(Constants.BLANK, returnType, true));
          } catch(IllegalSymbolValueException e) { {if (true) throw new CompilationException(e.getMessage());} }
          procedureNode.setSymbol(functionType);
          currentNode = savedCurrentNode;

          {if (true) return procedureNode;}
    throw new Error("Missing return statement in function");
  }

  final public void Block() throws ParseException, CompilationException {
        UXMLElement savedCurrentNode = currentNode, block = null;
    ScopeStart();
          block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
          currentNode.appendChild(block);
          currentNode = block;
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case DO:
      case WHILE:
      case FOR:
      case CALL:
      case WRITE:
      case WRITELN:
      case RETURN:
      case STMT_TERMINATOR:
      case ID:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_10;
      }
      Statement();
    }
    ScopeEnd();
          currentNode = savedCurrentNode;
  }

/**
 * Scope start
 * {
 */
  final public void ScopeStart() throws ParseException {
    jj_consume_token(BLOCK_START);
                Environment.currentActivationRecord.enterTheBlock();
  }

/**
 * Scope end
 * }
 */
  final public void ScopeEnd() throws ParseException {
    jj_consume_token(BLOCK_END);
                Environment.currentActivationRecord.leaveTheBlock();
  }

  final public void Statement() throws ParseException, CompilationException {
        UXMLElement procCall = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      Assignment();
      break;
    case IF:
      IfElse();
      break;
    case FOR:
      ForLoop();
      break;
    case DO:
      DoWhile();
      break;
    case WHILE:
      WhileDo();
      break;
    case WRITE:
    case WRITELN:
      Write();
      break;
    case CALL:
      procCall = ProcedureCall();
      jj_consume_token(STMT_TERMINATOR);
                                                                                                                           currentNode.appendChild(procCall);
      break;
    case RETURN:
      Return();
      break;
    case STMT_TERMINATOR:
      jj_consume_token(STMT_TERMINATOR);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Assignment() throws ParseException, CompilationException {
        UXMLElement lhsElement = null, rhsElement = null, savedCurrentNode = currentNode, assignment = null;
        Symbol lhsSymbol = null, rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
    lhsElement = VariableAccess(false);
    jj_consume_token(ASSIGN);
    rhsElement = Expression();
    jj_consume_token(STMT_TERMINATOR);
                lhsSymbol = lhsElement.getSymbol();
                rhsSymbol = rhsElement.getSymbol();

                try {
                        if(lhsSymbol instanceof ArrayType)
                                ((ArrayType)lhsSymbol).copyArray(rhsSymbol);
                        else
                                lhsSymbol.setValue(rhsSymbol);
                } catch(ImmutableSymbolException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(TypeMismatchException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                assignment = UXMLElementFactory.generateElement(Constants.ASSIGN, null ,null);
                attributes.put(Constants.NAME, lhsSymbol.getName());
                if(rhsElement.getElement() == null)
                        assignment.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,lhsSymbol));
                else
                        assignment.appendChild(lhsElement);
                assignment.appendChild(rhsElement);
                currentNode.appendChild(assignment);
  }

  final public void IfElse() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode;
    jj_consume_token(IF);
    MultiConditions();
    jj_consume_token(THEN);
    Block();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      Block();
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
        currentNode = parentNode; /*Restore the node*/
  }

  final public void MultiConditions() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement parentNode = currentNode, savedCurrentNode = currentNode, not = null, condition = null, lhsCondition = null,rhsCondition = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        Symbol lhsSymbol = null, rhsSymbol = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    try {
      /*(
      			t = <NOT> {operatorName = t.image;}
      		)? */
                      lhsCondition = Condition();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
        case OR:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_11;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          t = jj_consume_token(AND);
                           t.image = "$$";
          break;
        case OR:
          t = jj_consume_token(OR);
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                           operatorName = t.image;
        rhsCondition = Condition();
                        lhsSymbol = lhsCondition.getSymbol();
                        rhsSymbol = rhsCondition.getSymbol();
                        attributes.clear();
                        attributes.put(Constants.VALUE, operatorName);
                        operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                        operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                        condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                        condition.appendChild(lhsCondition);
                        condition.appendChild(rhsCondition);

                        currentNode = savedCurrentNode;
                        currentNode.appendChild(condition);

                        savedCurrentNode = currentNode;
                        lhsCondition = condition;
      }
                        if(condition != null)
                                currentNode = condition;
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    } catch (OperatorNotFoundException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
  }

  final public UXMLElement Condition() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement lhsExpression = null, rhsExpression = null, condition = null;
        Symbol lhsSymbol = null, rhsSymbol = null;
        String operatorName = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        HashMap<String,String> attributes = new HashMap<String, String>();
    lhsExpression = Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
    case NT_EQ:
    case LT:
    case LT_EQ:
    case GT_EQ:
    case GT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
                     t.image = "==";
        break;
      case NT_EQ:
        t = jj_consume_token(NT_EQ);
        break;
      case LT:
        t = jj_consume_token(LT);
                                                                t.image = "(";
        break;
      case LT_EQ:
        t = jj_consume_token(LT_EQ);
                                                                                               t.image = "(=";
        break;
      case GT:
        t = jj_consume_token(GT);
                                                                                                                           t.image = ")";
        break;
      case GT_EQ:
        t = jj_consume_token(GT_EQ);
                                                                                                                                                         t.image = ")=";
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                operatorName = t.image;
      rhsExpression = Expression();
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
                lhsSymbol = lhsExpression.getSymbol();
                try {
                        // Unary operator
                        if(operatorName == null)
                        {
                                operatorName = "==";
                                attributes.clear();
                                attributes.put(Constants.VALUE, operatorName);
                                operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                                condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                                condition.appendChild(lhsExpression);
                                currentNode.appendChild(condition);
                                currentNode = condition;
                                {if (true) return condition;}
                        }
                        // Binary operator
                        else {
                                rhsSymbol = rhsExpression.getSymbol();
                                attributes.clear();
                                attributes.put(Constants.VALUE, operatorName);
                                operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                                operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                                condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                                condition.appendChild(lhsExpression);
                                condition.appendChild(rhsExpression);
                                currentNode.appendChild(condition);
                                currentNode = condition;
                                {if (true) return condition;}
                        }
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(OperatorNotFoundException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
    throw new Error("Missing return statement in function");
  }

  final public void ForLoop() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, for_loop = null, controllerNode = null, savedCurrentNode = null;
        Symbol variableSymbol = null, variableValueSymbol = null, loopIndexSymbol = null;
        UXMLElement variableSymbolElement = null, variableValueElement = null, loopIndexElement = null,
        initialValueElement = null, finalValueElement = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        boolean isUp = true;
        Token t = null;
    jj_consume_token(FOR);
        for_loop = UXMLElementFactory.generateElement(Constants.FOR_LOOP, null, null);
        savedCurrentNode = currentNode;
        currentNode.appendChild(for_loop);
        currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.FROM, null, null));
    t = jj_consume_token(ID);
          try {
                  loopIndexSymbol = Environment.getSymbol(t.image);
          } catch(SymbolNotDefinedException e) { {if (true) throw new CompilationException(e.getMessage());}}
          attributes.clear();
          attributes.put(Constants.NAME, loopIndexSymbol.getName());
          loopIndexElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,loopIndexSymbol);
    jj_consume_token(ASSIGN);
    initialValueElement = Expression();
          // From
          controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
          controllerNode.appendChild(loopIndexElement);
          controllerNode.appendChild(initialValueElement);
          currentNode.appendChild(controllerNode);
          try {
                  loopIndexElement.getSymbol().setValue(initialValueElement.getSymbol()); // Initialize the value as it might be used to access the array elements.
          } catch(ImmutableSymbolException e) {}
          catch (TypeMismatchException e) {}
          catch(IllegalSymbolValueException e) {}
          currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.TILL, null, null));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TO:
      jj_consume_token(TO);
      break;
    case DOWNTO:
      jj_consume_token(DOWNTO);
                         isUp = false;
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    finalValueElement = Expression();
          // Till
          attributes.clear();
          attributes.put(Constants.VALUE, isUp? "(=" : ")="); // If TO then ++, else --
          controllerNode = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
          controllerNode.appendChild(loopIndexElement.getClone());
          controllerNode.appendChild(finalValueElement);
          currentNode.appendChild(controllerNode);
          currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.STEP, null, null));
          // Step
          controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
          controllerNode.appendChild(loopIndexElement.getClone());
          currentNode = currentNode.appendChild(controllerNode);

          attributes.clear();
          attributes.put(Constants.VALUE, isUp? "+" : "-"); // If TO then ++, else --
          controllerNode = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
          controllerNode.appendChild(loopIndexElement.getClone());
          attributes.clear();
          attributes.put(Constants.TYPE, Constants.INT);
          attributes.put(Constants.VALUE, "1");
          controllerNode.appendChild(UXMLElementFactory.generateElement(Constants.CONSTANT, attributes, null));
          currentNode.appendChild(controllerNode);
          currentNode = for_loop;
    jj_consume_token(DO);
    Block();
            currentNode = parentNode; /* Restore the node */
  }

  final public void DoWhile() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, iterate = null, till = null;
    jj_consume_token(DO);
        iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
        currentNode.appendChild(iterate);
        currentNode = iterate;
    Block();
    jj_consume_token(WHILE);
        till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
        currentNode.appendChild(till);
        currentNode = till;
    MultiConditions();
    jj_consume_token(STMT_TERMINATOR);
                                         currentNode = parentNode;  /*Restore the node*/
  }

  final public void WhileDo() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, iterate = null, till = null;
    jj_consume_token(WHILE);
        iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
        currentNode.appendChild(iterate);
        currentNode = iterate;

        till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
        currentNode.appendChild(till);
        currentNode = till;
    MultiConditions();
                      currentNode = iterate;
    jj_consume_token(DO);
    Block();
           currentNode = parentNode;  /*Restore the node*/
  }

  final public void Return() throws ParseException, CompilationException {
        UXMLElement returnExpression = null, returnElement = null;
        String requiredReturnType = null, foundReturnType = null;
        Symbol returnSymbol = null;
    jj_consume_token(RETURN);
    returnExpression = Expression();
                returnElement = UXMLElementFactory.generateElement(Constants.RETURN, null, null);
                returnSymbol = returnExpression.getSymbol();
                returnSymbol = (returnSymbol instanceof FunctionType)? ((FunctionType)returnSymbol).getReturnValue():returnSymbol;
                returnElement.appendChild(returnExpression);
                currentNode.appendChild(returnElement);

                // Try to set the return symbol into the return value of currentfunction. 
                // If the return-type is not compatible then error will be thrown
                try {
                        requiredReturnType = DataTypeFinder.getDataType(currentProcedure.getReturnValue());
                        foundReturnType = DataTypeFinder.getDataType(returnSymbol);
                        if(requiredReturnType.equals(foundReturnType)) {
                                Symbol returnValue = currentProcedure.getReturnValue();
                                if(returnValue instanceof ArrayType)
                                        ((ArrayType) returnValue).copyArray(returnSymbol);
                        }
                        else
                                {if (true) throw new TypeMismatchException(foundReturnType,requiredReturnType);}
                        isReturnStmtPresent = true;
                  } catch(TypeMismatchException e) {
                          {if (true) throw new CompilationException("Procedure '" + currentProcedureName
                                          + "' should return '" + requiredReturnType + "' and not '"  + foundReturnType + "'.",e.getMessage());}
                  } catch(SymbolNotDefinedException e) {System.err.println(e.getMessage());}
    jj_consume_token(STMT_TERMINATOR);
  }

  final public void Write() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement print, expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WRITE:
      t = jj_consume_token(WRITE);
      break;
    case WRITELN:
      t = jj_consume_token(WRITELN);
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                print = UXMLElementFactory.generateElement(t.image.replaceAll("write","print"), null, null);
    jj_consume_token(ROUND_START);
    expression = Expression();
                        print.appendChild(expression);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_12;
      }
      jj_consume_token(COMMA);
      expression = Expression();
                                print.appendChild(expression);
    }
    jj_consume_token(ROUND_END);
    jj_consume_token(STMT_TERMINATOR);
                currentNode.appendChild(print);
  }

  final public UXMLElement ProcedureCall() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement argumentElement = null, call = null, function = null;
        String functionName = null;
        Symbol argumentSymbol = null, functionType = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
        FunctionType functionSymbol = null;
    jj_consume_token(CALL);
    function = VariableAccess(true);
                functionType = function.getSymbol();
                functionName = functionType.getName();
                call = UXMLElementFactory.generateElement(Constants.CALL, null, null);
                attributes.clear();
                if(!(Constants.OPERATOR.equals(function.getElementName()) &&
                                                Constants.VALUE_OF.equals(function.getAttributeValue(Constants.VALUE))))
                {
                        attributes.put(Constants.NAME, functionName);
                        call.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,functionType));
                } else {
                        call.appendChild(function);
                }
    jj_consume_token(ROUND_START);
    argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                // Check if expression is void and if yes, then no-argument function call is made
                if(!Constants.VOID.equals(argumentSymbol.getType())) {
                        actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                        call.appendChild(argumentElement);
                }
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_13;
      }
      jj_consume_token(COMMA);
      argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                call.appendChild(argumentElement);
    }
    jj_consume_token(ROUND_END);
                try {
                        // If this is the recursive call, then just extract the current Procedure
                        if(functionName.equals(currentProcedureName))
                                functionSymbol = currentProcedure;
                        else {
                                /*argumentSymbol = Environment.getSymbol(functionName);
				
				if(!(argumentSymbol instanceof OverloadedFunctionType))
					throw new CompilationException("Type mismatch \n Found    : '" + functionName + DataTypeFinder.getDataType(argumentSymbol) + "' \n Required : '" + functionName + "'");
				
				// Get the function
				functionSymbol = ((OverloadedFunctionType) argumentSymbol).getFunction(actualArgs);*/

                                if(!(functionType instanceof OverloadedFunctionType))
                                        {if (true) throw new CompilationException("Type mismatch \n Found    : '" + functionName + DataTypeFinder.getDataType(functionType) + "' \n Required : '" + functionName + "'");}

                                // Get the function
                                functionSymbol = ((OverloadedFunctionType) functionType).getFunction(actualArgs);

                        }
                } catch (SymbolNotDefinedException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                call.setSymbol(functionSymbol);
                {if (true) return call;}
    throw new Error("Missing return statement in function");
  }

  final public UXMLElement VariableAccess(boolean isFunctionCall) throws ParseException, CompilationException {
        Token t = null;
        String variableName = null;
        Symbol variableSymbol = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        UXMLElement variableSymbolElement = null;
    t = jj_consume_token(ID);
                try {
                        variableName = t.image;
                        // If this is a function call, then simply store the current procedure.
                        // This trick is to enable recursive calls
                        if(isFunctionCall && variableName.equals(currentProcedureName))
                                variableSymbol = currentProcedure;
                        else
                                variableSymbol = Environment.getSymbol(variableName);
                        attributes.clear();
                        attributes.put(Constants.NAME, variableSymbol.getName());
                        variableSymbolElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol);
                } catch(SymbolNotDefinedException e) {{if (true) throw new CompilationException(e.getMessage());}}
    variableSymbolElement = ArrayAccess(variableSymbolElement);
                                                                     {if (true) return variableSymbolElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * E -> T1 E_L
 */
  final public UXMLElement Expression() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Expression_Left(Term1());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * E_L -> (& | | | ^ ) T1 E_L
 */
  final public UXMLElement Expression_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AMPERSAND:
    case BIT_OR:
    case BIT_XOR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
        t = jj_consume_token(AMPERSAND);
                           t.image = "$";
        break;
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_XOR:
        t = jj_consume_token(BIT_XOR);
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Term1();
                 rhsSymbol = currentRHS.getSymbol();
                 try {
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Expression_Left(currentLHS);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T1 -> T2 T1_L
 */
  final public UXMLElement Term1() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Term1_Left(Term2());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T1_L -> (+ | -) T2 T1_L
 */
  final public UXMLElement Term1_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Term2();
                 try {
                         rhsSymbol = currentRHS.getSymbol();
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Term1_Left(currentLHS);
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T2 -> F T2_L
 */
  final public UXMLElement Term2() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Term2_Left(Factor());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T2_L -> (* | / | %) F T2_L
 */
  final public UXMLElement Term2_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        String operatorName = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
    case DIVIDE:
    case MOD:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        t = jj_consume_token(ASTERISK);
        break;
      case DIVIDE:
        t = jj_consume_token(DIVIDE);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Factor();
                 try {
                         rhsSymbol = currentRHS.getSymbol();
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         // Make sure that div doesn't give divide by zero error
                         try {
                                 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         } catch(RuntimeException e)
                         {
                                 Symbol param1 = operands.get(0);
                                 Symbol param2 = operands.get(1);
                                 if(param1.getDataType() == DATA_TYPE.FLOAT || param2.getDataType() == DATA_TYPE.FLOAT)
                                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes,
                                                         SymbolMachine.generate(Constants.BLANK, Constants.FLOAT, true));
                                 else
                                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes,
                                                         SymbolMachine.generate(Constants.BLANK, Constants.INT, true));
                         }
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Term2_Left(currentLHS);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/** 
 * F -> (E) | VariableAccess() | Constant() | <VOID> | FunctionCall()
 */
  final public UXMLElement Factor() throws ParseException, CompilationException {
        Token t = null;
        String typeCast = null;
        Symbol value = null;
        UXMLElement expressionValue = null, returnFactorValue = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQUARE_START:
      jj_consume_token(SQUARE_START);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
        break;
      case CHAR:
        t = jj_consume_token(CHAR);
        break;
      case BOOL:
        t = jj_consume_token(BOOL);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                                        typeCast = t.image;
      jj_consume_token(SQUARE_END);
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROUND_START:
      jj_consume_token(ROUND_START);
      expressionValue = Expression();
                                                       returnFactorValue =  expressionValue ;
      jj_consume_token(ROUND_END);
      break;
    case ID:
      expressionValue = VariableAccess(false);
                        value = expressionValue.getSymbol();

                        if((!(Constants.OPERATOR.equals(expressionValue.getElementName()) &&
                                                        Constants.VALUE_AT_INDEX.equals(expressionValue.getAttributeValue(Constants.VALUE))))) {
                                attributes.clear();
                                attributes.put(Constants.NAME, expressionValue.getSymbol().getName());
                                expressionValue = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,expressionValue.getSymbol());
                        }
                        returnFactorValue = expressionValue;
      break;
    case INT_CONSTANT:
    case FLOAT_CONSTANT:
    case STRING_CONSTANT:
    case BOOL_CONSTANT:
    case CHAR_CONSTANT:
      value = Constants();
                                returnFactorValue =  new UXMLElement(null,value);
      break;
    case CALL:
      expressionValue = ProcedureCall();
                                              returnFactorValue = expressionValue;
      break;
    case VOID:
      jj_consume_token(VOID);
                  try { returnFactorValue =  new UXMLElement(null,SymbolMachine.generate(Constants.BLANK,Constants.VOID, false));  } catch(Exception e ){}
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                try {
                        if(typeCast != null) {
                                attributes.put(Constants.TYPE, typeCast);
                                expressionValue = UXMLElementFactory.generateElement(Constants.CAST ,attributes, SymbolMachine.cast(returnFactorValue.getSymbol(), typeCast));
                                expressionValue.appendChild(returnFactorValue);
                                returnFactorValue = expressionValue;
                        }
                } catch(TypeMismatchException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch (SymbolNotDefinedException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch (IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                {if (true) return returnFactorValue;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public PTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[40];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000000,0x6000000,0xf0000000,0xf0000000,0x0,0x0,0x0,0x0,0xe00000,0xe00000,0x30000,0x30000,0x1c0000,0x1c0000,0x0,0x0,0x3e0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0xc0000000,0x8000000,0xc0000000,0x8000000,0x200000,0x100271c8,0x8000,0x40000,0x10000,0x0,0x0,0x100271c8,0x8000000,0x2000000,0x10000,0x10000000,0x10000000,0x800000,0x4000000,0x100271c8,0x100271c8,0x20,0x0,0x0,0x3,0x3,0x600,0x6000,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x200000,0x801000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x7,0x0,0x17,0x0,0x0,0x20,0x0,0x0,0x0,0x20,0x20,0x20,0x0,0x0,0x20,0x20,0x20,0x0,0x0,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x28,};
   }

  /** Constructor with InputStream. */
  public P(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public P(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new PTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public P(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public P(PTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(PTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 40; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[72];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 40; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 72; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
