/* Generated By:JavaCC: Do not edit this line. Y.java */
package parserOfY;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Scanner;

import compiler.components.*;
import compiler.dataTypes.*;
import compiler.exceptions.*;
import compiler.operator.*;
import compiler.util.*;
import compiler.util.Constants.DATA_TYPE;
import compiler.uXMLGenerator.*;

import xvHandler.Executor;
import xvHandler.CodeAnalysis;
import xvHandler.ProcedureCallSeq;

import parserOfY.exceptions.*;
import sun.font.CreatedFontTracker;
import sun.security.smartcardio.SunPCSC.Factory;

@SuppressWarnings("all")
public class Y implements YConstants {

        private static UXMLElement currentNode = null;
        private static String currentFunctionName = null;
        private static FunctionType currentFunction = null;
        private static boolean globalVariableDeclaration = false;

        public static void main(String args[]) throws ParseException {
                FileInputStream io = null;
                String codeAnalysisFlag = null;

                String fileName = null;
            if(args.length == 0) {
                Scanner in = new Scanner(System.in);
                System.out.print("Enter the file name @ src/sampleYLikeProgs/");
                fileName = in.nextLine();
                while(fileName.trim().length() == 0)
                        fileName = in.nextLine();
                codeAnalysisFlag = in.nextLine();
                args = new String[1];
                args[0] = fileName;
            }
            else {
                fileName = args[0];
                if(args.length > 1)
                        codeAnalysisFlag = args[1];
            }

            try {
                io = new FileInputStream("src" + File.separator + "sampleYLikeProgs" + File.separator + fileName + ".Ylike");
                Y parser = new Y(io);

                // Initialize the environment
                Environment.initialize(new ProcedureCallSeq(), false);
                Environment.isVarMandatory = false;
                // Initialize the uXMLDocument generator
                currentNode = UXMLElementFactory.initialize("Ylike", Constants.STATIC);
                // Make Variable declaration as optional
                currentNode.setAttributeValue(Constants.VAR_DECLARATION, Constants.NO);

                Environment.currentActivationRecord.enterTheBlock();
                parser.YLike();
                Environment.currentActivationRecord.leaveTheBlock();

                // Save the uXML document
                UXMLElementFactory.done(fileName);

                if("-analysis".equals(codeAnalysisFlag))
                        CodeAnalysis.main(args);
                else
                        Executor.main(args);

            } catch (FileNotFoundException fe) {
                System.err.println("File '" + fileName + "' not found.");
                System.exit(1);
            } catch(ParseException e) {
                String message = e.getMessage();
                int startIndex = message.indexOf("line ") + 5;
                int endIndex = message.indexOf(",");
                String lineNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("column ") + 7;
                endIndex = message.indexOf(".");
                String columnNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("\u005c"") + 1;
                endIndex = message.lastIndexOf("\u005c" at line");
                String keyword = message.substring(startIndex, endIndex).replaceAll("\u005c"","").trim();

                System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
                StringBuffer expectedTokens = new StringBuffer("Expected tokens : ");
                String tokenValue = null;
                tokenValue = tokenImage[e.expectedTokenSequences[0][0]];
                tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                expectedTokens.append(tokenValue);
                for(int tokenId = 1; tokenId < e.expectedTokenSequences.length;tokenId++) {
                        tokenValue = tokenImage[e.expectedTokenSequences[tokenId][0]];
                        tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                        expectedTokens.append(", ")
                                .append(tokenValue);
                }
                System.err.println(expectedTokens.toString());
            } catch(TokenMgrError e) {
                String message = e.getMessage();
                        int startIndex = message.indexOf("line ") + 5;
                        int endIndex = message.indexOf(",");
                        String lineNo = message.substring(startIndex, endIndex).trim();

                        startIndex = message.indexOf("column ") + 7;
                        endIndex = message.indexOf(".");
                        String columnNo = message.substring(startIndex, endIndex).trim();

                        startIndex = message.indexOf("\u005c"") + 1;
                        endIndex = message.indexOf("\u005c"",startIndex);
                        String keyword = message.substring(startIndex, endIndex).trim();

                        System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
            }
            catch(CompilationException e) {
                System.err.println(e.getMessage());
            }
  }

//Possible allowable constants
  final public Symbol Constants() throws ParseException, CompilationException {
                                                  Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_CONSTANT:
        t = jj_consume_token(INT_CONSTANT);
                                        UXMLElementFactory.eat(t.image);{if (true) return new ConstantValue(Constants.INT,t.image);}
        break;
      case FLOAT_CONSTANT:
        t = jj_consume_token(FLOAT_CONSTANT);
                                           UXMLElementFactory.eat(t.image);{if (true) return new ConstantValue(Constants.FLOAT,t.image);}
        break;
      case CHAR_CONSTANT:
        t = jj_consume_token(CHAR_CONSTANT);
                        UXMLElementFactory.eat(t.image);
                        String ch = t.image.substring(1,2);
                        {if (true) return new ConstantValue(Constants.CHAR,ch);}
        break;
      case STRING_CONSTANT:
        t = jj_consume_token(STRING_CONSTANT);
                        String str = t.image;
                        UXMLElementFactory.eat(str);
                        str = str.substring(1, str.length() - 1);
                        {if (true) return new ConstantValue(Constants.STRING,str);}
        break;
      case BOOL_CONSTANT:
        t = jj_consume_token(BOOL_CONSTANT);
                                         UXMLElementFactory.eat(t.image);{if (true) return new ConstantValue(Constants.BOOLEAN,t.image);}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

  final public void YLike() throws ParseException, CompilationException {
                                             UXMLElement block = null;
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case WHILE:
      case FOR:
      case CALL:
      case WRITE:
      case WRITELN:
      case DEF:
      case RETURN:
      case ID:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case WHILE:
      case FOR:
      case CALL:
      case WRITE:
      case WRITELN:
      case RETURN:
      case ID:
        Statements();
        break;
      case DEF:
        FunctionDef();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/**
 * Statements
 */
  final public void Statements() throws ParseException, CompilationException {
        UXMLElement funcCall = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      Assign();
      break;
    case IF:
      IfElse();
      break;
    case FOR:
      ForLoop();
      break;
    case WHILE:
      WhileDo();
      break;
    case CALL:
      funcCall = FunctionCall();
                               currentNode.appendComment(); currentNode.appendChild(funcCall);
      break;
    case WRITE:
    case WRITELN:
      Write();
      break;
    case RETURN:
      Return();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
 * Assignment
 */
  final public void Assign() throws ParseException, CompilationException {
        UXMLElement lhsElement = null, rhsElement = null, savedCurrentNode = currentNode, assignment = null;
        Symbol lhsSymbol = null, rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        Token t = null;
    lhsElement = VariableAccess(false, false);
    t = jj_consume_token(ASSIGN);
                      UXMLElementFactory.eat(t.image);
    rhsElement = Expression();
                lhsSymbol = lhsElement.getSymbol();
                rhsSymbol = rhsElement.getSymbol();

                try {
                        if(lhsSymbol instanceof ArrayType)
                                ((ArrayType)lhsSymbol).copyArray(rhsSymbol);
                        else
                                lhsSymbol.setValue(rhsSymbol);
                } catch(ImmutableSymbolException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(TypeMismatchException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                assignment = UXMLElementFactory.generateElement(Constants.ASSIGN, null ,null);
                attributes.put(Constants.NAME, lhsSymbol.getName());
                if(rhsElement.getElement() == null)
                        assignment.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,lhsSymbol));
                else
                        assignment.appendChild(lhsElement);
                assignment.appendChild(rhsElement);
                currentNode.appendComment();
                currentNode.appendChild(assignment);
  }

/**
 * If else
 */
  final public void IfElse() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode;
        Token t = null;
    t = jj_consume_token(IF);
               UXMLElementFactory.eat(t.image);
    MultiConditions(true);
    Block();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      t = jj_consume_token(ELSE);
                   UXMLElementFactory.eat(t.image); currentNode.appendComment();
      Block();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
        currentNode = parentNode; /*Restore the node*/
  }

/**
 * Logical operators
 * isIfCond attribute decides if comments need to be appended or not.
 */
  final public void MultiConditions(boolean isIfCond) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement parentNode = currentNode, savedCurrentNode = currentNode, not = null, condition = null, lhsCondition = null,rhsCondition = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        Symbol lhsSymbol = null, rhsSymbol = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    lhsCondition = Condition(isIfCond);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
      case OR:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        t = jj_consume_token(AND);
                   t.image = "$$";
        break;
      case OR:
        t = jj_consume_token(OR);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                   UXMLElementFactory.eat(t.image); operatorName = t.image;
      rhsCondition = Condition(isIfCond);
                lhsSymbol = lhsCondition.getSymbol();
                rhsSymbol = rhsCondition.getSymbol();
                attributes.clear();
                attributes.put(Constants.VALUE, operatorName);
                operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, new ConstantValue(Constants.BLANK,Constants.NO_TYPE,true));
                condition.appendChild(lhsCondition);
                condition.appendChild(rhsCondition);

                currentNode = savedCurrentNode;
                if(isIfCond)
                        currentNode.appendComment();
                currentNode.appendChild(condition);

                savedCurrentNode = currentNode;
                lhsCondition = condition;
    }
                if(condition != null)
                        currentNode = condition;
  }

/**
 * Conditional operators
 * isIfCond attribute decides if comments need to be appended or not.
 */
  final public UXMLElement Condition(boolean isIfCond) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement lhsExpression = null, rhsExpression = null, condition = null;
        Symbol lhsSymbol = null, rhsSymbol = null;
        String operatorName = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        HashMap<String,String> attributes = new HashMap<String, String>();
    lhsExpression = Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
    case NT_EQ:
    case LT:
    case LT_EQ:
    case GT_EQ:
    case GT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
                     UXMLElementFactory.eat(t.image); t.image = "==";
        break;
      case NT_EQ:
        t = jj_consume_token(NT_EQ);
                        UXMLElementFactory.eat(t.image);
        break;
      case LT:
        t = jj_consume_token(LT);
                     UXMLElementFactory.eat(t.image); t.image = "(";
        break;
      case LT_EQ:
        t = jj_consume_token(LT_EQ);
                        UXMLElementFactory.eat(t.image); t.image = "(=";
        break;
      case GT:
        t = jj_consume_token(GT);
                     UXMLElementFactory.eat(t.image); t.image = ")";
        break;
      case GT_EQ:
        t = jj_consume_token(GT_EQ);
                       UXMLElementFactory.eat(t.image); t.image = ")=";
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                operatorName = t.image;
      rhsExpression = Expression();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
                lhsSymbol = lhsExpression.getSymbol();
                // Unary operator
                if(operatorName == null)
                {
                        operatorName = "==";
                        attributes.clear();
                        attributes.put(Constants.VALUE, operatorName);
                        operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                        condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, new ConstantValue(Constants.BLANK,Constants.NO_TYPE,true));
                        condition.appendChild(lhsExpression);
                        if(isIfCond)
                                currentNode.appendComment();
                        currentNode.appendChild(condition);
                        currentNode = condition;
                        {if (true) return condition;}
                }
                // Binary operator
                else {
                        rhsSymbol = rhsExpression.getSymbol();
                        attributes.clear();
                        attributes.put(Constants.VALUE, operatorName);
                        operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                        operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                        condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, new ConstantValue(Constants.BLANK,Constants.NO_TYPE,true));
                        condition.appendChild(lhsExpression);
                        condition.appendChild(rhsExpression);
                        if(isIfCond)
                                currentNode.appendComment();
                        currentNode.appendChild(condition);
                        currentNode = condition;
                        {if (true) return condition;}
                }
    throw new Error("Missing return statement in function");
  }

/**
 * for loop
 */
  final public void ForLoop() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, for_loop = null, controllerNode = null, savedCurrentNode = null;
        Symbol variableSymbol = null, variableValueSymbol = null, loopIndexSymbol = null;
        UXMLElement variableSymbolElement = null, variableValueElement = null, loopIndexElement = null,
        initialValueElement = null, finalValueElement = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        boolean isUp = true;
        Token t = null;
    t = jj_consume_token(FOR);
               UXMLElementFactory.eat(t.image);
        for_loop = UXMLElementFactory.generateElement(Constants.FOR_LOOP, null, null);
        savedCurrentNode = currentNode;
        currentNode.appendChild(for_loop);
        currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.FROM, null, null));
    t = jj_consume_token(ID);
          UXMLElementFactory.eat(t.image);
          try {
                  loopIndexSymbol = Environment.createSymbol(t.image); // This might be the undeclared symbol, hence need to create it
          } catch(SymbolNotDefinedException e) { {if (true) throw new CompilationException(e.getMessage());}}
          attributes.clear();
          attributes.put(Constants.NAME, loopIndexSymbol.getName());
          loopIndexElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,loopIndexSymbol);
    t = jj_consume_token(ASSIGN);
                 UXMLElementFactory.eat(t.image);
    initialValueElement = Expression();
          // From
          controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
          controllerNode.appendChild(loopIndexElement);
          controllerNode.appendChild(initialValueElement);
          currentNode.appendChild(controllerNode);
          try {
                  loopIndexElement.getSymbol().setValue(initialValueElement.getSymbol()); // Initialize the value as it might be used to access the array elements.
          } catch(ImmutableSymbolException e) {}
          catch (TypeMismatchException e) {}
          catch(IllegalSymbolValueException e) {}
          currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.TILL, null, null));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TO:
      t = jj_consume_token(TO);
                UXMLElementFactory.eat(t.image);
      break;
    case DOWNTO:
      t = jj_consume_token(DOWNTO);
                    UXMLElementFactory.eat(t.image); isUp = false;
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    finalValueElement = Expression();
          // Till
          attributes.clear();
          attributes.put(Constants.VALUE, isUp? "(=" : ")="); // If TO then ++, else --
          controllerNode = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
          controllerNode.appendChild(loopIndexElement.getClone());
          controllerNode.appendChild(finalValueElement);
          currentNode.appendChild(controllerNode);
          currentNode = for_loop.appendChild(UXMLElementFactory.generateElement(Constants.STEP, null, null));
          // Step
          controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
          controllerNode.appendChild(loopIndexElement.getClone());
          currentNode = currentNode.appendChild(controllerNode);

          attributes.clear();
          attributes.put(Constants.VALUE, isUp? "+" : "-"); // If TO then ++, else --
          controllerNode = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
          controllerNode.appendChild(loopIndexElement.getClone());
          attributes.clear();
          attributes.put(Constants.TYPE, Constants.INT);
          attributes.put(Constants.VALUE, "1");
          controllerNode.appendChild(UXMLElementFactory.generateElement(Constants.CONSTANT, attributes, null));
          currentNode.appendChild(controllerNode);
          for_loop.insertComment();
          currentNode = for_loop;
    Block();
            currentNode = parentNode; /* Restore the node */
  }

/**
 * While do
 */
  final public void WhileDo() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, savedCurrentNode = null, iterate = null, till = null;
        Token t = null;
    t = jj_consume_token(WHILE);
                 UXMLElementFactory.eat(t.image);
        iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);

        till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
        iterate.appendChild(till);
        savedCurrentNode = currentNode;
        currentNode = till;
    MultiConditions(false);
          currentNode = savedCurrentNode;
          currentNode.appendComment();
          currentNode.appendChild(iterate);
          currentNode = iterate;
    Block();
           currentNode = parentNode;  /*Restore the node*/
  }

/**
 * Function call
 */
  final public UXMLElement FunctionCall() throws ParseException, CompilationException {
        UXMLElement argumentElement = null, call = null, function = null;
        String functionName = null;
        Symbol argumentSymbol = null, functionType = null;
        ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
        HashMap<String, String> attributes = new HashMap<String, String>();
        FunctionType functionSymbol = null;
        Token t = null;
    // Function call	
            t = jj_consume_token(CALL);
                    UXMLElementFactory.eat(t.image);
    function = VariableAccess(true, true);
                functionType = function.getSymbol();
                functionName = functionType.getName();
                call = UXMLElementFactory.generateElement(Constants.CALL, null, null);
                attributes.clear();
                call.appendChild(function);
    t = jj_consume_token(ROUND_START);
                           UXMLElementFactory.eat(t.image);
    argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                // Check if expression is void and if yes, then no-argument function call is made
                if(!Constants.VOID.equals(argumentSymbol.getType())) {
                        actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                        call.appendChild(argumentElement);
                }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_3;
      }
      t = jj_consume_token(COMMA);
                      UXMLElementFactory.eat(t.image);
      argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                call.appendChild(argumentElement);
    }
    t = jj_consume_token(ROUND_END);
                         UXMLElementFactory.eat(t.image);
                try {
                        // If this is the recursive call, then just extract the current Procedure
                        if(functionName.equals(currentFunctionName))
                                functionSymbol = currentFunction;
                        else {

                                if(!(functionType instanceof OverloadedFunctionType || functionType.getDataType() == DATA_TYPE.DYNAMIC) )
                                        {if (true) throw new CompilationException("Type mismatch \u005cn Found    : '" + functionName + DataTypeFinder.getDataType(functionType) + "' \u005cn Required : '" + functionName + "'");}

                                // Get the function
                                if(functionType.getDataType() == DATA_TYPE.DYNAMIC) {
                                        call.setSymbol(functionType);
                                }
                                else {
                                        functionSymbol = ((OverloadedFunctionType) functionType).getFunction(actualArgs);
                                        call.setSymbol(functionSymbol);
                                }
                        }
                } catch (SymbolNotDefinedException e) { {if (true) throw new CompilationException(e.getMessage());} }

                {if (true) return call;}
    throw new Error("Missing return statement in function");
  }

/**
 * Print
 */
  final public void Write() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement print, expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WRITE:
      t = jj_consume_token(WRITE);
      break;
    case WRITELN:
      t = jj_consume_token(WRITELN);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                UXMLElementFactory.eat(t.image);
                print = UXMLElementFactory.generateElement(t.image.replaceAll("write","print"), null, null);
    expression = Expression();
                print.appendChild(expression);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_4;
      }
      t = jj_consume_token(COMMA);
                             UXMLElementFactory.eat(t.image);
      expression = Expression();
                        print.appendChild(expression);
    }
                currentNode.appendComment();
                currentNode.appendChild(print);
  }

/**
 * Return
 */
  final public void Return() throws ParseException, CompilationException {
        UXMLElement returnExpression = null, returnElement = null;
        String requiredReturnType = null, foundReturnType = null;
        Symbol returnSymbol = null;
        Token t = null;
    t = jj_consume_token(RETURN);
                      UXMLElementFactory.eat(t.image);
    returnExpression = Expression();
                returnElement = UXMLElementFactory.generateElement(Constants.RETURN, null, null);
                returnSymbol = returnExpression.getSymbol();
                returnSymbol = (returnSymbol instanceof FunctionType)? ((FunctionType)returnSymbol).getReturnValue():returnSymbol;
                returnElement.appendChild(returnExpression);
                currentNode.appendComment();
                currentNode.appendChild(returnElement);
  }

/**
 * Function definition
 */
  final public void FunctionDef() throws ParseException, CompilationException {
        Token t = null;
        String functionName = null, paramName = null;
        UXMLElement savedCurrentNode = currentNode, procedureNode , automaticVarNode , block, paramNode = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        Symbol paramSymbol = null;
    t = jj_consume_token(DEF);
                UXMLElementFactory.eat(t.image);
                // Execute the calling sequence of a caller - 
            Environment.callSequenceProcessor.callAction_caller(0);
            Environment.currentActivationRecord.enterTheBlock();
            // Everything apart from function definition is global
            globalVariableDeclaration = false;
    t = jj_consume_token(ID);
                UXMLElementFactory.eat(t.image);
                functionName = t.image;
                currentFunction = new FunctionType(functionName, true, Constants.VOID);
                // Nested level of function will be '0' since nested functions are not 
                // allowed in Ylike
                currentFunction.setNestedLevel(0);
                attributes.clear();
                attributes.put(Constants.NAME, functionName);
                procedureNode = UXMLElementFactory.generateElement(Constants.FUNCTION , attributes, null);
    t = jj_consume_token(ROUND_START);
                         UXMLElementFactory.eat(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
                        automaticVarNode = procedureNode.appendChild(UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null));
      t = jj_consume_token(ID);
                        UXMLElementFactory.eat(t.image);
                        paramName = t.image;
                        paramSymbol = new ConstantValue(paramName,Constants.NO_TYPE,true);
                        currentFunction.addSymbol(paramSymbol);
                        attributes.clear();
                        attributes.put(Constants.NAME, paramName);
                        attributes.put(Constants.TYPE, Constants.NO_TYPE);
                        attributes.put(Constants.MUTABLE, Constants.YES);
                        automaticVarNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[13] = jj_gen;
          break label_5;
        }
        t = jj_consume_token(COMMA);
                           UXMLElementFactory.eat(t.image);
        t = jj_consume_token(ID);
                        UXMLElementFactory.eat(t.image);
                        paramName = t.image;
                        paramSymbol = new ConstantValue(paramName,Constants.NO_TYPE,true);
                        currentFunction.addSymbol(paramSymbol);
                        attributes.clear();
                        attributes.put(Constants.NAME, paramName);
                        attributes.put(Constants.TYPE, Constants.NO_TYPE);
                        attributes.put(Constants.MUTABLE, Constants.YES);
                        automaticVarNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
      }
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
    t = jj_consume_token(ROUND_END);
                            UXMLElementFactory.eat(t.image);
                currentNode.appendComment();
                currentNode = currentNode.appendChild(procedureNode);
                // Save the function in global symbol table
                Environment.addGlobalSymbol(currentFunction);
                // Copy the formal params in current symbol table
                for(Symbol formalArg : currentFunction.getFormalParameters())
                        Environment.currentActivationRecord.addSymbol(formalArg);
    Block();
                // Function done
                Environment.callSequenceProcessor.returnAction_caller();
                globalVariableDeclaration = true;
                currentNode = savedCurrentNode;
  }

/**
 * Scope start
 * {
 */
  final public void ScopeStart() throws ParseException {
    jj_consume_token(BLOCK_START);
                Environment.currentActivationRecord.enterTheBlock();
  }

/**
 * Scope end
 * }
 */
  final public void ScopeEnd() throws ParseException {
    jj_consume_token(BLOCK_END);
                Environment.currentActivationRecord.leaveTheBlock();
  }

/**
 * Block
 */
  final public void Block() throws ParseException, CompilationException {
        UXMLElement savedCurrentNode = currentNode, block = null;
    ScopeStart();
          block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
          currentNode.appendChild(block);
          currentNode = block;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case WHILE:
      case FOR:
      case CALL:
      case WRITE:
      case WRITELN:
      case RETURN:
      case ID:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_6;
      }
      Statements();
    }
    ScopeEnd();
          currentNode = savedCurrentNode;
  }

/**
 * isFunctionCall - If this access refers to the function call
 * isVarDeclared - If this access refers to the already defined variable (true) or first-time usage (false)
 */
  final public UXMLElement VariableAccess(boolean isFunctionCall, boolean isVarDeclared) throws ParseException, CompilationException {
        Token t = null;
        String variableName = null;
        Symbol variableSymbol = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        UXMLElement variableSymbolElement = null;
    t = jj_consume_token(ID);
                try {
                        variableName = t.image;
                        UXMLElementFactory.eat(t.image);
                        // If this is a function call, then simply store the current procedure.
                        // This trick is to enable recursive calls
                        if(isFunctionCall && variableName.equals(currentFunctionName))
                                variableSymbol = currentFunction;
                        else {
                                // If the variable is already declared then get it from Environment
                                // else create the symbol, add it in current Activation record and
                                // return it.
                                variableSymbol = isVarDeclared? Environment.getSymbol(variableName) :
                                        Environment.createSymbol(variableName);
                        }

                        attributes.clear();
                        attributes.put(Constants.NAME, variableSymbol.getName());
                        variableSymbolElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol);
                } catch(SymbolNotDefinedException e) {{if (true) throw new CompilationException(e.getMessage());}}
    variableSymbolElement = ArrayAccess(variableSymbolElement);
                                                                     {if (true) return variableSymbolElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * Create Array
 */
  final public UXMLElement CreateArray() throws ParseException, CompilationException {
        Symbol constantSymbol = null;
        UXMLElement savedCurrentNode = currentNode, arrayNode, elementNode = null;
        ArrayType array = null;
        Token t = null;
        HashMap<String,String> attributes = new HashMap<String,String>();
                try {
                        array = (ArrayType)SymbolMachine.generate(Constants.BLANK, Constants.ARRAY, false);
                } catch(IllegalSymbolValueException e) { {if (true) throw new CompilationException(e.getMessage());} }
                arrayNode = UXMLElementFactory.generateElement(Constants.ARRAY, null, array);
    t = jj_consume_token(SQUARE_START);
                          UXMLElementFactory.eat(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQUARE_START:
      elementNode = CreateArray();
      break;
    case ID:
      elementNode = VariableAccess(false,true);
      break;
    case MAP:
    case REDUCE:
      elementNode = MapOrReduce();
      break;
    case INT_CONSTANT:
    case FLOAT_CONSTANT:
    case STRING_CONSTANT:
    case BOOL_CONSTANT:
    case CHAR_CONSTANT:
      constantSymbol = Constants();
                        attributes.clear();
                        attributes.put(Constants.TYPE,constantSymbol.getType());
                        attributes.put(Constants.VALUE,constantSymbol.getValue());
                        elementNode = UXMLElementFactory.generateElement(Constants.CONSTANT, attributes, constantSymbol);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                arrayNode.appendChild(elementNode);
                array.appendElement(elementNode.getSymbol());
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_7;
      }
      t = jj_consume_token(COMMA);
                    UXMLElementFactory.eat(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQUARE_START:
        elementNode = CreateArray();
        break;
      case ID:
        elementNode = VariableAccess(false,true);
        break;
      case MAP:
      case REDUCE:
        elementNode = MapOrReduce();
        break;
      case INT_CONSTANT:
      case FLOAT_CONSTANT:
      case STRING_CONSTANT:
      case BOOL_CONSTANT:
      case CHAR_CONSTANT:
        constantSymbol = Constants();
                        attributes.clear();
                        attributes.put(Constants.TYPE,constantSymbol.getType());
                        attributes.put(Constants.VALUE,constantSymbol.getValue());
                        elementNode = UXMLElementFactory.generateElement(Constants.CONSTANT, attributes, constantSymbol);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                arrayNode.appendChild(elementNode);
                array.appendElement(elementNode.getSymbol());
    }
    t = jj_consume_token(SQUARE_END);
                          UXMLElementFactory.eat(t.image);
                {if (true) return arrayNode;}
    throw new Error("Missing return statement in function");
  }

/**
 * Array Access
 *  ([ Expression() ])* 
 */
  final public UXMLElement ArrayAccess(UXMLElement variableElement) throws ParseException, CompilationException {
        Token t = null;
        int index = 0;
        HashMap<String, String> attributes = new HashMap<String, String> ();
        attributes.put(Constants.VALUE, "[]");
        UXMLElement operator = null,
        indexElement = null,returnElement = operator;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        Symbol arrayElementAtIndex = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQUARE_START:
      t = jj_consume_token(SQUARE_START);
                           UXMLElementFactory.eat(t.image);
      indexElement = Expression();
                operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
                operator.appendChild(variableElement);
                operator.appendChild(indexElement);
                operands.clear();
                operands.add(variableElement.getSymbol());
                operands.add(indexElement.getSymbol());
                arrayElementAtIndex = new ConstantValue(Constants.BLANK,Constants.NO_TYPE,true);
                operator.setSymbol(arrayElementAtIndex);
                variableElement = operator;
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_8;
        }
        t = jj_consume_token(COMMA);
                    UXMLElementFactory.eat(t.image);
        indexElement = Expression();
                operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
                operator.appendChild(variableElement);
                operator.appendChild(indexElement);
                operands.clear();
                operands.add(variableElement.getSymbol());
                operands.add(indexElement.getSymbol());
                arrayElementAtIndex = new ConstantValue(Constants.BLANK,Constants.NO_TYPE,true);
                operator.setSymbol(arrayElementAtIndex);
                variableElement = operator;
      }
      t = jj_consume_token(SQUARE_END);
                       UXMLElementFactory.eat(t.image);
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
              {if (true) return variableElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * Map or Reduce
 */
  final public UXMLElement MapOrReduce() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement operator, function, data = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        ArrayType dataArray = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAP:
      t = jj_consume_token(MAP);
                    UXMLElementFactory.eat(t.image); t.image = Constants.MAP_FUNCTION;
      break;
    case REDUCE:
      t = jj_consume_token(REDUCE);
                       UXMLElementFactory.eat(t.image); t.image = Constants.REDUCE_FUNCTION;
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                attributes.put(Constants.VALUE,t.image);
                operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
    t = jj_consume_token(ROUND_START);
                           UXMLElementFactory.eat(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      function = VariableAccess(false,true);
      break;
    case LAMBDA:
      function = LambdaFunction();
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         operator.appendChild(function);
    t = jj_consume_token(COMMA);
                                                     UXMLElementFactory.eat(t.image);
    /* Data */
            data = CreateArray();
                ArrayList<UXMLElement> children = data.getChildren();
                for(int childNo = 0; childNo < children.size(); childNo++) {
                        operator.appendChild(children.get(childNo));
                }
    t = jj_consume_token(ROUND_END);
                      UXMLElementFactory.eat(t.image);
                operator.setSymbol(data.getSymbol());
                {if (true) return operator;}
    throw new Error("Missing return statement in function");
  }

/**
 * Lambda function
 */
  final public UXMLElement LambdaFunction() throws ParseException, CompilationException {
        Token t = null;
        String paramName = null;
        UXMLElement functionElement,automaticVarNode, functionBodyElement,block  = null;
        Symbol paramSymbol = null;
        FunctionType function = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
    t = jj_consume_token(LAMBDA);
                UXMLElementFactory.eat(t.image);
                // Execute the calling sequence of a caller - 
            Environment.callSequenceProcessor.callAction_caller(0);
            Environment.currentActivationRecord.enterTheBlock();

                function = new FunctionType(Constants.BLANK, true, Constants.VOID);
                // Nested level of function will be '0' since nested functions are not 
                // allowed in Ylike
                function.setNestedLevel(0);
                functionElement = UXMLElementFactory.generateElement(Constants.FUNCTION, null, function);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
                        automaticVarNode = functionElement.appendChild(UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null));
      t = jj_consume_token(ID);
                        paramName = t.image;
                        UXMLElementFactory.eat(t.image);
                        paramSymbol = new ConstantValue(paramName,Constants.NO_TYPE,true);
                        function.addSymbol(paramSymbol);
                        attributes.clear();
                        attributes.put(Constants.NAME, paramName);
                        attributes.put(Constants.TYPE, Constants.NO_TYPE);
                        attributes.put(Constants.MUTABLE, Constants.YES);
                        automaticVarNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_9;
        }
        t = jj_consume_token(COMMA);
                              UXMLElementFactory.eat(t.image);
        t = jj_consume_token(ID);
                        paramName = t.image;
                        UXMLElementFactory.eat(t.image);
                        paramSymbol = new ConstantValue(paramName,Constants.NO_TYPE,true);
                        function.addSymbol(paramSymbol);
                        attributes.clear();
                        attributes.put(Constants.NAME, paramName);
                        attributes.put(Constants.TYPE, Constants.NO_TYPE);
                        attributes.put(Constants.MUTABLE, Constants.YES);
                        automaticVarNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    t = jj_consume_token(COLON);
                           UXMLElementFactory.eat(t.image);
                // Save the function in global symbol table
//		Environment.currentActivationRecord.addSymbol(currentFunction);
                // Copy the formal params in current symbol table
                for(Symbol formalArg : function.getFormalParameters())
                        Environment.currentActivationRecord.addSymbol(formalArg);
    functionBodyElement = Expression();
                // Function done
                Environment.callSequenceProcessor.returnAction_caller();
                block = UXMLElementFactory.generateElement(Constants.BLOCK,null,null);
                block.appendChild(functionBodyElement);
                functionElement.appendChild(block);
                {if (true) return functionElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * E -> T1 E_L
 */
  final public UXMLElement Expression() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Expression_Left(Term1());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * E_L -> (& | | | ^ ) T1 E_L
 */
  final public UXMLElement Expression_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AMPERSAND:
    case BIT_OR:
    case BIT_XOR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
        t = jj_consume_token(AMPERSAND);
                           t.image = "$";
        break;
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_XOR:
        t = jj_consume_token(BIT_XOR);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
                 UXMLElementFactory.eat(t.image);
      currentRHS = Term1();
                 rhsSymbol = currentRHS.getSymbol();
                 attributes.put(Constants.VALUE,operatorName);
                 operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                 operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, new ConstantValue(Constants.BLANK,Constants.NO_TYPE,true));
                 currentNode.appendChild(operator);
                 operator.appendChild(currentLHS);
                 operator.appendChild(currentRHS);
                 currentLHS = operator;
      restOfExpression = Expression_Left(currentLHS);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T1 -> T2 T1_L
 */
  final public UXMLElement Term1() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Term1_Left(Term2());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T1_L -> (+ | -) T2 T1_L
 */
  final public UXMLElement Term1_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
                 UXMLElementFactory.eat(t.image);
      currentRHS = Term2();
                 rhsSymbol = currentRHS.getSymbol();
                 attributes.put(Constants.VALUE,operatorName);
                 operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                 operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, new ConstantValue(Constants.BLANK,Constants.NO_TYPE,true)
                 );
                 currentNode.appendChild(operator);
                 operator.appendChild(currentLHS);
                 operator.appendChild(currentRHS);
                 currentLHS = operator;
      restOfExpression = Term1_Left(currentLHS);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T2 -> F T2_L
 */
  final public UXMLElement Term2() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Term2_Left(Factor());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T2_L -> (* | / | %) F T2_L
 */
  final public UXMLElement Term2_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        String operatorName = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
    case DIVIDE:
    case MOD:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        t = jj_consume_token(ASTERISK);
        break;
      case DIVIDE:
        t = jj_consume_token(DIVIDE);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
                 UXMLElementFactory.eat(t.image);
      currentRHS = Factor();
                 try {
                         rhsSymbol = currentRHS.getSymbol();
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         // Make sure that div doesn't give divide by zero error
                         try {
                                 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, new ConstantValue(Constants.BLANK,Constants.NO_TYPE,true));
                         } catch(RuntimeException e)
                         {
                                 Symbol param1 = operands.get(0);
                                 Symbol param2 = operands.get(1);
                                 if(param1.getDataType() == DATA_TYPE.FLOAT || param2.getDataType() == DATA_TYPE.FLOAT)
                                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes,
                                                         SymbolMachine.generate(Constants.BLANK, Constants.FLOAT, true));
                                 else
                                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes,
                                                         SymbolMachine.generate(Constants.BLANK, Constants.INT, true));
                         }
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Term2_Left(currentLHS);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/** 
 * F -> (E) | VariableAccess() | Constant() | <VOID> | FunctionCall()
 */
  final public UXMLElement Factor() throws ParseException, CompilationException {
        Token t = null;
        String typeCast = null;
        Symbol value = null;
        UXMLElement expressionValue = null, returnFactorValue = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROUND_START:
      t = jj_consume_token(ROUND_START);
                           UXMLElementFactory.eat(t.image);
      expressionValue = Expression();
                                         returnFactorValue =  expressionValue ;
      t = jj_consume_token(ROUND_END);
                         UXMLElementFactory.eat(t.image);
      break;
    case ID:
      expressionValue = VariableAccess(false, true);
                        value = expressionValue.getSymbol();

                        if((!(Constants.OPERATOR.equals(expressionValue.getElementName()) &&
                                                        Constants.VALUE_AT_INDEX.equals(expressionValue.getAttributeValue(Constants.VALUE))))) {
                                attributes.clear();
                                attributes.put(Constants.NAME, expressionValue.getSymbol().getName());
                                expressionValue = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,expressionValue.getSymbol());
                        }
                        returnFactorValue = expressionValue;
      break;
    case INT_CONSTANT:
    case FLOAT_CONSTANT:
    case STRING_CONSTANT:
    case BOOL_CONSTANT:
    case CHAR_CONSTANT:
      value = Constants();
                                returnFactorValue =  new UXMLElement(null,value);
      break;
    case CALL:
      expressionValue = FunctionCall();
                                             returnFactorValue = expressionValue;
      break;
    case VOID:
      jj_consume_token(VOID);
                try {
                        returnFactorValue =  new UXMLElement(null,SymbolMachine.generate(Constants.BLANK,Constants.VOID, false));
                        UXMLElementFactory.eat(Constants.VOID);
                } catch(Exception e ){}
      break;
    case SQUARE_START:
      expressionValue = CreateArray();
                                           returnFactorValue = expressionValue;
      break;
    case MAP:
    case REDUCE:
      expressionValue = MapOrReduce();
                                           returnFactorValue = expressionValue;
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return returnFactorValue;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public YTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[32];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3e0,0x0,0x0,0x0,0x0,0xc00000,0xc00000,0x7e000000,0x7e000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800003e0,0x0,0x800003e0,0x0,0x0,0x80000000,0x0,0x0,0x0,0x1c0000,0x1c0000,0x6000,0x6000,0x38000,0x38000,0x800003e0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x1003e68,0x1003e68,0x1002e68,0x10,0x0,0x0,0x0,0x0,0x180,0x200000,0xc00,0x200000,0x200000,0x1000000,0x1002e68,0x1010001,0x200000,0x1010001,0x200000,0x10000,0x1,0x1000002,0x200000,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x1850201,};
   }

  /** Constructor with InputStream. */
  public Y(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Y(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new YTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Y(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new YTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Y(YTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(YTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 32; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[59];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 32; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 59; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
