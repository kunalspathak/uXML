/* Generated By:JavaCC: Do not edit this line. J.java */
package parserOfJ;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Scanner;

import compiler.components.*;
import compiler.dataTypes.*;
import compiler.exceptions.*;
import compiler.operator.*;
import compiler.util.*;
import compiler.util.Constants.DATA_TYPE;
import compiler.uXMLGenerator.*;

import xvHandler.Executor;
import xvHandler.CodeAnalysis;
import xvHandler.ProcedureCallSeq;

import parserOfJ.exceptions.*;

@SuppressWarnings("all")
public class J implements JConstants {

        private static UXMLElement currentNode = null;
        private static UXMLElement globalScopeNode = null;
        private static String mainClassName = null;
        private static String currentClassName = null;
        private static ClassType currentClass = null;
        private static String currentProcedureName = null;
        private static FunctionType currentProcedure = null;
    private static boolean isReturnStmtPresent = false;
    private static boolean isMemberVarDeclaration = false;
    // Used to check if parent constructor of same signature is present or not.
    // If not present, call to super is checked and if that is not present then error is thrown
    // if(!present(ancestor_Constructor(args))) isParentConstructorPresent = false;
    // if(!present(super_call) && !isParentConstructorPresent) throw error;
    private static boolean isParentConstructorPresent = false;
    private static FunctionType deferedConstructor = null;
    private static int nestedLevelOfProcedure = 0; // Represents the nested level of a procedure
    //private static OOVariableAccess ooVariableAccess = new OOVariableAccess(null,null);

        public static void main(String args[]) throws ParseException {
                FileInputStream io = null;
                String codeAnalysisFlag = null;

                String fileName = null;
            if(args.length == 0) {
                Scanner in = new Scanner(System.in);
                System.out.print("Enter the file name @ src/sampleJLikeProgs/");
                fileName = in.nextLine();
                while(fileName.trim().length() == 0)
                        fileName = in.nextLine();
                codeAnalysisFlag = in.nextLine();
                args = new String[1];
                args[0] = fileName;
            }
            else {
                fileName = args[0];
                if(args.length > 1)
                        codeAnalysisFlag = args[1];
            }

            try {
                io = new FileInputStream("src/sampleJLikeProgs/" + fileName + ".Jlike");
                J parser = new J(io);

                // Initialize the environment with ignore dynamic variable flag
                Environment.initialize(new ProcedureCallSeq(), true);
                // Initialize the uXMLDocument generator
                currentNode = UXMLElementFactory.initialize("Jlike", Constants.STATIC);
                currentNode.setAttributeValue("poly", Constants.YES);

                Environment.currentActivationRecord.enterTheBlock();
                parser.JLike();
                Environment.currentActivationRecord.leaveTheBlock();

                // Save the uXML document
                UXMLElementFactory.done(fileName);

                if("-analysis".equals(codeAnalysisFlag))
                        CodeAnalysis.main(args);
                else
                        Executor.main(args);

            } catch (FileNotFoundException fe) {
                System.err.println("File '" + fileName + "' not found.");
                System.exit(1);
            } catch(ParseException e) {
                String message = e.getMessage();
                int startIndex = message.indexOf("line ") + 5;
                int endIndex = message.indexOf(",");
                String lineNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("column ") + 7;
                endIndex = message.indexOf(".");
                String columnNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("\"") + 1;
                endIndex = message.lastIndexOf("\" at line");
                String keyword = message.substring(startIndex, endIndex).replaceAll("\"","").trim();

                System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
                StringBuffer expectedTokens = new StringBuffer("Expected tokens : ");
                String tokenValue = null;
                tokenValue = tokenImage[e.expectedTokenSequences[0][0]];
                tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                expectedTokens.append(tokenValue);
                for(int tokenId = 1; tokenId < e.expectedTokenSequences.length;tokenId++) {
                        tokenValue = tokenImage[e.expectedTokenSequences[tokenId][0]];
                        tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                        expectedTokens.append(", ")
                                .append(tokenValue);
                }
                System.err.println(expectedTokens.toString());
            } catch(TokenMgrError e) {
                String message = e.getMessage();
                        int startIndex = message.indexOf("line ") + 5;
                        int endIndex = message.indexOf(",");
                        String lineNo = message.substring(startIndex, endIndex).trim();

                        startIndex = message.indexOf("column ") + 7;
                        endIndex = message.indexOf(".");
                        String columnNo = message.substring(startIndex, endIndex).trim();

                        startIndex = message.indexOf("\"") + 1;
                        endIndex = message.indexOf("\"",startIndex);
                        String keyword = message.substring(startIndex, endIndex).trim();

                        System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
            }
            catch(CompilationException e) {
                System.err.println(e.getMessage());
            }
  }

  /**
   * Class that returns class used to access the variable
   */
  private static class OOVariableAccess {
          private ClassType classUsed = null;
          private UXMLElement variableElement = null;

          public OOVariableAccess(ClassType classUsed, UXMLElement variableElement) {
                this.classUsed = classUsed;
                this.variableElement = variableElement;
          }

          public ClassType getClassUsed() {
                  return classUsed;
          }

          public void setClassUsed(ClassType classUsed) {
                  this.classUsed = classUsed;
          }

          public UXMLElement getVariableElement() {
                  return variableElement;
          }

          public void setVariableElement(UXMLElement variableElement) {
                  this.variableElement = variableElement;
          }
  }

// Possible allowable constants
  final public Symbol Constants() throws ParseException, CompilationException {
                                                  Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_CONSTANT:
        t = jj_consume_token(INT_CONSTANT);
                                        {if (true) return new ConstantValue(Constants.INT,t.image);}
        break;
      case FLOAT_CONSTANT:
        t = jj_consume_token(FLOAT_CONSTANT);
                                           {if (true) return new ConstantValue(Constants.FLOAT,t.image);}
        break;
      case CHAR_CONSTANT:
        t = jj_consume_token(CHAR_CONSTANT);
                        String ch = t.image.substring(1,2);
                        {if (true) return new ConstantValue(Constants.CHAR,ch);}
        break;
      case STRING_CONSTANT:
        t = jj_consume_token(STRING_CONSTANT);
                        String str = t.image;
                        str = str.substring(1, str.length() - 1);
                        {if (true) return new ConstantValue(Constants.STRING,str);}
        break;
      case BOOL_CONSTANT:
        t = jj_consume_token(BOOL_CONSTANT);
                                         {if (true) return new ConstantValue(Constants.BOOLEAN,t.image);}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

// Possible allowable data-types
  final public String DataType() throws ParseException, CompilationException {
        String dataType = null;
        Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      t = jj_consume_token(INT);
      break;
    case FLOAT:
      t = jj_consume_token(FLOAT);
      break;
    case CHAR:
      t = jj_consume_token(CHAR);
      break;
    case BOOL:
      t = jj_consume_token(BOOL);
      break;
    case STRING:
      t = jj_consume_token(STRING);
      break;
    case CLASS:
      jj_consume_token(CLASS);
      t = jj_consume_token(ID);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                                                                                 dataType = t.image;
    dataType = CreateArray(dataType);
     {if (true) return dataType;}
    throw new Error("Missing return statement in function");
  }

  final public String CreateArray(String dataType) throws ParseException, CompilationException {
        Token t = null;
        StringBuffer dimSizeType = new StringBuffer();
        ArrayList<Integer> dimSize = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        UXMLElement arrayNodeElement = null;
        int currentDimSize = -1;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQUARE_START:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
                        if(dimSize == null) {
                                dimSize = new ArrayList<Integer>();
                        // Create an array-type having blank name and type. Update it once with appropriate name/type. 
                        attributes.put(Constants.NAME, Constants.BLANK);
                        attributes.put(Constants.TYPE, Constants.BLANK);
                        arrayNodeElement = UXMLElementFactory.generateElement(Constants.ARRAY_TYPE, attributes, null);
                        }
      jj_consume_token(SQUARE_START);
      t = jj_consume_token(INT_CONSTANT);
                        currentDimSize = Integer.parseInt(t.image); dimSize.add(currentDimSize);
                        dimSizeType.append(t.image);
                // Append 'dim'
                attributes.clear();
                attributes.put(Constants.SIZE, String.valueOf(currentDimSize));
                arrayNodeElement.appendChild(UXMLElementFactory.generateElement(Constants.DIM, attributes, null));
      jj_consume_token(SQUARE_END);
    }
                try {

                        if(dimSize != null) {
                                Symbol baseElement = SymbolMachine.generate(Constants.BLANK, dataType, true);
                                ArrayType arrayType = (ArrayType)SymbolMachine.generate(Constants.BLANK, Constants.ARRAY, true);
                                arrayType.initializeArray(dimSize, null, baseElement);

                                // Set the array element's base-type
                                arrayNodeElement.setAttributeValue(Constants.TYPE,dataType);

                                dataType = DataTypeFinder.getDataType(arrayType) + dimSizeType;
                                arrayType.setName(dataType);

                                // Set the Name of array-type
                                arrayNodeElement.setAttributeValue(Constants.NAME,dataType);

                                // If not yet defined, then append it to currentNode
                                if(!Environment.isSymbolPresentInGlobalScope(dataType)) {
                                        globalScopeNode.appendChild(arrayNodeElement);

                                        // Add the symbol in global scope
                                        Environment.addGlobalSymbol(arrayType);
                                }
                        }
                        {if (true) return dataType;}
                } catch(ImmutableSymbolException e) { {if (true) throw new CompilationException(e.getMessage());} }
                catch(SymbolNotDefinedException e) { {if (true) throw new CompilationException(e.getMessage());} }
                catch(IllegalSymbolValueException e) { {if (true) throw new CompilationException(e.getMessage());} }
                catch(TypeMismatchException e) { {if (true) throw new CompilationException(e.getMessage());} }
    throw new Error("Missing return statement in function");
  }

/**
 * Array Access
 *  ([ Expression() ])* 
 */
  final public UXMLElement ArrayAccess(UXMLElement variableElement) throws ParseException, CompilationException {
        Token t = null;
        int index = 0;
        HashMap<String, String> attributes = new HashMap<String, String> ();
        attributes.put(Constants.VALUE, "[]");
        UXMLElement operator = null,
        indexElement = null,returnElement = operator;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        Symbol arrayElementAtIndex = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQUARE_START:
        jj_consume_token(SQUARE_START);
        indexElement = Expression();
                        operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
                        operator.appendChild(variableElement);
                        operator.appendChild(indexElement);
                        operands.clear();
                        operands.add(variableElement.getSymbol());
                        operands.add(indexElement.getSymbol());
                        arrayElementAtIndex = Operator.execute("[]", operands);
                        operator.setSymbol(arrayElementAtIndex);
                        variableElement = operator;
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[3] = jj_gen;
            break label_2;
          }
          jj_consume_token(COMMA);
          indexElement = Expression();
                        operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
                        operator.appendChild(variableElement);
                        operator.appendChild(indexElement);
                        operands.clear();
                        operands.add(variableElement.getSymbol());
                        operands.add(indexElement.getSymbol());
                        arrayElementAtIndex = Operator.execute("[]", operands);
                        operator.setSymbol(arrayElementAtIndex);
                        variableElement = operator;
        }
        jj_consume_token(SQUARE_END);
        break;
      default:
        jj_la1[4] = jj_gen;
        ;
      }
                      {if (true) return variableElement;}
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    } catch (OperatorNotFoundException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

  final public void JLike() throws ParseException, CompilationException {
UXMLElement callToMain = null, callToConstructor = null;
HashMap<String,String> attributes = new HashMap<String, String>();
    HeadingSection();
    label_3:
    while (true) {
      ClassDefinition();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
    }
                callToMain = UXMLElementFactory.generateElement(Constants.CALL, null, null);
                attributes.put(Constants.NAME, "main");
                callToMain.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                callToConstructor = UXMLElementFactory.generateElement(Constants.CALL, null, null);
                attributes.clear();
                attributes.put(Constants.NAME, Constants.CONSTRUCTOR);
                callToConstructor.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                attributes.clear();
                attributes.put(Constants.NAME, mainClassName);
                callToConstructor.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                callToMain.appendChild(callToConstructor);
                currentNode.appendChild(callToMain);
  }

  final public void HeadingSection() throws ParseException {
        UXMLElement block = null; Token t = null;
    jj_consume_token(PROGRAM);
    t = jj_consume_token(ID);
                            mainClassName = t.image;
    jj_consume_token(STMT_TERMINATOR);
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
                globalScopeNode = UXMLElementFactory.generateElement(Constants.GLOBAL_VAR, null, null);
                currentNode.appendChild(globalScopeNode);
  }

// This method temporary instantiates the class
// remove it once 'new' is developed.
  final public void ClassDefinition() throws ParseException, CompilationException {
        UXMLElement savedCurrentNode = currentNode, block = null, classElement = null, memberVarElement = null,inheritsElement = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        Token t = null;
    jj_consume_token(CLASS);
    t = jj_consume_token(ID);
                try {
                        currentClassName = t.image;
                        currentClass = (ClassType)SymbolMachine.generate(currentClassName, Constants.CLASS, false);
                        currentClass.setClassName(currentClassName); // Set the class name
                        Environment.addGlobalSymbol(currentClass); // Add the class in current activation record
                        attributes.put(Constants.NAME,currentClassName);
                        classElement = UXMLElementFactory.generateElement(Constants.CLASS_TYPE, attributes, currentClass);
                        memberVarElement = UXMLElementFactory.generateElement(Constants.MEMBER_VAR, null, null);
                        currentNode.appendChild(classElement);
                        isMemberVarDeclaration = true;
                } catch(IllegalSymbolValueException e) { {if (true) throw new CompilationException(e.getMessage());} }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INHERITS:
      jj_consume_token(INHERITS);
                inheritsElement = UXMLElementFactory.generateElement(Constants.INHERITS, null, null);
                classElement.appendChild(inheritsElement);
      t = jj_consume_token(ID);
                attributes.clear(); attributes.put(Constants.NAME,t.image);
                inheritsElement.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                try {
                        currentClass.addAncestor((ClassType)Environment.getSymbol(t.image)); // Add the ancestor
                } catch(ClassCastException e) {{if (true) throw new CompilationException("'" + t.image + "' is not a class.");}}
                catch(SymbolNotDefinedException e) {{if (true) throw new CompilationException(e.getMessage());}}
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_4;
        }
        jj_consume_token(COMMA);
        t = jj_consume_token(ID);
                attributes.clear(); attributes.put(Constants.NAME,t.image);
                inheritsElement.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
      }
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
                classElement.appendChild(memberVarElement);
                currentNode = memberVarElement;
    ScopeStart();
    DeclarationSection();
                               currentNode = classElement; isMemberVarDeclaration = false;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONSTRUCTOR:
      case FUNCTION:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_5;
      }
      FunctionDeclaration();
    }
    ScopeEnd();
                currentNode = savedCurrentNode;
  }

  final public void DeclarationSection() throws ParseException, CompilationException {
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINAL:
      case CLASS:
      case INT:
      case FLOAT:
      case CHAR:
      case BOOL:
      case STRING:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINAL:
        ConstantDeclaration();
        break;
      case CLASS:
      case INT:
      case FLOAT:
      case CHAR:
      case BOOL:
      case STRING:
        VariableDeclaration();
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

// Constant declaration
  final public void ConstantDeclaration() throws ParseException, CompilationException {
        String dataType = null;
    jj_consume_token(FINAL);
    dataType = DataType();
    InitializeVariable(dataType);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_7;
      }
      jj_consume_token(COMMA);
      InitializeVariable(dataType);
    }
    jj_consume_token(STMT_TERMINATOR);
  }

// initialization of variables
  final public void InitializeVariable(String dataType) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement savedCurrentNode = currentNode, constantElement = null, constantExprElement = null;
        String paramName = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        Symbol constantVar = null, constantValue = null;
    t = jj_consume_token(ID);
                      paramName = t.image;
    jj_consume_token(ASSIGN);
    constantExprElement = Expression();
                  try {
                          constantValue = constantExprElement.getSymbol();
                          constantVar = SymbolMachine.generate(paramName, dataType, true);
                          constantVar.setValue(constantValue); // Set the constant value
                          constantVar.setMutableStatus(true);
                          attributes.clear();
                          attributes.put(Constants.NAME, paramName);
                          attributes.put(Constants.TYPE, dataType);
                          attributes.put(Constants.MUTABLE, "no"); // Make it non-mutable
                          constantElement = UXMLElementFactory.generateElement(Constants.VAR, attributes, constantVar);
                          constantElement.appendChild(constantExprElement);

                          // Add the symbol in member-var/local scope
                          if(isMemberVarDeclaration)
                                  currentClass.addSymbol(constantVar);
                          else
                                  Environment.currentActivationRecord.addSymbol(constantVar);
                          currentNode.appendChild(constantElement); // Add in current node
                  } catch (IllegalSymbolValueException e) {{if (true) throw new CompilationException(e.getMessage());}}
                  catch(TypeMismatchException e) {{if (true) throw new CompilationException(e.getMessage());}}
                  catch(ImmutableSymbolException e) {} // Exception won't come since the variable is mutable initially

  }

// Variable declaration
  final public void VariableDeclaration() throws ParseException, CompilationException {
  String dataType = null;
    dataType = DataType();
    OptionalInitializeVariable(dataType);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_8;
      }
      jj_consume_token(COMMA);
      OptionalInitializeVariable(dataType);
    }
    jj_consume_token(STMT_TERMINATOR);
  }

// Optional initialization of variables
  final public void OptionalInitializeVariable(String dataType) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement savedCurrentNode = currentNode, constantElement = null, constantExprElement = null;
        String paramName = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        Symbol constantVar = null, constantValue = null;
    t = jj_consume_token(ID);
                     paramName = t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      constantExprElement = Expression();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
                try {
                        constantVar = SymbolMachine.generate(paramName, dataType, true);
                        attributes.clear();
                        attributes.put(Constants.NAME, paramName);
                        attributes.put(Constants.TYPE, dataType);
                        attributes.put(Constants.MUTABLE, "yes"); // Make it mutable
                        constantElement = UXMLElementFactory.generateElement(Constants.VAR, attributes, constantVar);
                        if(constantExprElement != null) { // If assignment is present
                                constantValue = constantExprElement.getSymbol();
                                constantVar.setValue(constantValue); // Set the constant value
                                constantElement.appendChild(constantExprElement);
                        }
                        // Add the symbol in member-var/local scope
                        if(isMemberVarDeclaration)
                                currentClass.addSymbol(constantVar);
                        else
                                Environment.currentActivationRecord.addSymbol(constantVar);
                        currentNode.appendChild(constantElement); // Add in current node

                } catch (IllegalSymbolValueException e) {{if (true) throw new CompilationException(e.getMessage());}}
                  catch(TypeMismatchException e) {{if (true) throw new CompilationException(e.getMessage());}}
                  catch(ImmutableSymbolException e) {} // Exception won't come since the variable is mutable

  }

// Procedure Declaration
  final public void FunctionDeclaration() throws ParseException, CompilationException {
        UXMLElement savedCurrentNode = currentNode, block = null, procedureNode = null;
        boolean isConstructor = false;
                // Execute the calling sequence of a caller - 
        Environment.callSequenceProcessor.callAction_caller(nestedLevelOfProcedure);
        // There may be the case that arguments to the function are needed to add in symbol table, 
        // for that the method call 'enterTheBlock()' is necessary so that symbol table will be created.
        Environment.currentActivationRecord.enterTheBlock();
    procedureNode = FunctionHeading();
                if(Constants.CONSTRUCTOR_ELEMENT.equals(procedureNode.getElementName())) isConstructor = true;
                currentNode = currentNode.appendChild(procedureNode);
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
    FunctionBody(isConstructor);
                // If function is defined to return a value and return statement is not present in function definition
                // or if function is defined to return void and if return statement is present 
                // then throw error
                if(!isConstructor) {
                        if(!Constants.VOID.equals(currentProcedure.getReturnType()) && !isReturnStmtPresent)
                                {if (true) throw new CompilationException("'" + currentProcedureName + "' should return a value of type '"
                                                + currentProcedure.getReturnType() + "'.");}
                        else if(Constants.VOID.equals(currentProcedure.getReturnType())&& isReturnStmtPresent )
                                {if (true) throw new CompilationException("'" + currentProcedureName + "' declared as 'void' should not return a value.");}
                        else
                                isReturnStmtPresent = false;
                }

                // Function done
                Environment.callSequenceProcessor.returnAction_caller();
                currentNode = savedCurrentNode;
  }

  final public void FunctionBody(boolean isConstructor) throws ParseException, CompilationException {
        boolean isSuperCallPresent = false;
        UXMLElement superClassCallElement = null;
    jj_consume_token(BLOCK_START);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUPER_CALL:
      superClassCallElement = SuperClassCall();
                if(!isConstructor) {
                        {if (true) throw new CompilationException("Call to super() is only allowed inside a constructor.");}
                }
                currentNode.appendChild(superClassCallElement);
                isSuperCallPresent = true;
      break;
    default:
      jj_la1[14] = jj_gen;
      ;
    }
                // If this is a constructor call AND if there is NO parent class constructor matching this constructor's
                // signature AND if there is NO super class call, then throw compilation exception.
                if(isConstructor && !isParentConstructorPresent && !isSuperCallPresent) {
                        {if (true) throw new CompilationException("No call to super class's constructor.");}
                }

                // If this is a constructor call AND if there is NO parent class constructor matching this constructor's
                // signature (set 'false' in FunctionHeading() method) AND if this is a super class constructor then
                // add the deferred constructor now....reason : it was not added earlier because parent class constructor 
                // was not found.
                if(isConstructor && !isParentConstructorPresent && isSuperCallPresent) {
                        currentClass.addSymbol(deferedConstructor);
                }
    DeclarationSection();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case DO:
      case WHILE:
      case FOR:
      case CALL:
      case PRINT:
      case PRINTLN:
      case NEW:
      case RETURN:
      case STMT_TERMINATOR:
      case ID:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_9;
      }
      Statement();
    }
    jj_consume_token(BLOCK_END);
  }

  final public UXMLElement FunctionHeading() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement savedCurrentNode = currentNode, procedureNode = null, automaticVarNode = null, procedureParamNode = null;
        boolean isConstructor = false;
        String returnType = Constants.VOID, nameOfHeading = null, paramType = null, paramName = null;
        FunctionType functionType = null;
        Symbol paramSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> paramList = new ArrayList<Symbol>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTRUCTOR:
      jj_consume_token(CONSTRUCTOR);
                  isConstructor = true;
      break;
    case FUNCTION:
      jj_consume_token(FUNCTION);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
      case INT:
      case FLOAT:
      case CHAR:
      case BOOL:
      case STRING:
        returnType = DataType();
        break;
      case VOID:
        jj_consume_token(VOID);
        break;
      default:
        jj_la1[16] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(ID);
          nameOfHeading = t.image;
          if(isConstructor && !currentClassName.equals(nameOfHeading))
          {{if (true) throw new CompilationException("Constructor name '" + nameOfHeading + "' is different from the class name '" + currentClassName + "'.");}}
          else {
                  functionType = new FunctionType(isConstructor? Constants.CONSTRUCTOR : nameOfHeading, true, returnType);
                  functionType.setNestedLevel(0);
                  try {
                          functionType.setReturnValue(SymbolMachine.generate(Constants.BLANK, returnType, true));
                  } catch(IllegalSymbolValueException e) { {if (true) throw new CompilationException(e.getMessage());} }
                  if(!isConstructor) {
                          currentProcedureName = nameOfHeading; // Store the current procedure name
                          currentProcedure = functionType;
                  }
                  attributes.clear();
                  attributes.put(Constants.NAME, nameOfHeading);
                  procedureNode = UXMLElementFactory.generateElement(isConstructor? Constants.CONSTRUCTOR_ELEMENT : Constants.FUNCTION, attributes, null);
                  currentNode.appendChild(procedureNode);
          }
    try {
      jj_consume_token(ROUND_START);
                   currentNode = procedureNode.appendChild(UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
      case INT:
      case FLOAT:
      case CHAR:
      case BOOL:
      case STRING:
        paramType = DataType();
        t = jj_consume_token(ID);
        paramName = t.image;
        paramSymbol = SymbolMachine.generate(paramName, paramType, true);
        paramList.add(paramSymbol);
        attributes.clear();
        attributes.put(Constants.TYPE, paramType);
        attributes.put(Constants.MUTABLE, "yes");
        attributes.put(Constants.NAME, paramName);
        currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_10;
          }
          jj_consume_token(COMMA);
          paramType = DataType();
          t = jj_consume_token(ID);
        paramName = t.image;
        paramSymbol = SymbolMachine.generate(paramName, paramType, true);
        paramList.add(paramSymbol);
        attributes.clear();
        attributes.put(Constants.TYPE, paramType);
        attributes.put(Constants.MUTABLE, "yes");
        attributes.put(Constants.NAME, paramName);
        currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
        }
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
      jj_consume_token(ROUND_END);
          // Add the formal parameters in function/activation record
                for(int variableNo = 0; variableNo < paramList.size(); variableNo++) {
                        // Add the variables to current function
                        functionType.addSymbol(paramList.get(variableNo));
                        // Add the variables to current activation record
                        Environment.currentActivationRecord.addSymbol(paramList.get(variableNo));
                }
                if(!isConstructor) {
                        attributes.clear();
                        attributes.put(Constants.TYPE, returnType);
                        procedureNode.appendChild(UXMLElementFactory.generateElement(Constants.RETURNS, attributes, null));
                }
                currentNode = savedCurrentNode;
                // Add current function/constructor in current class
                if(isConstructor) {
                        try {
                                currentClass.addConstructor(functionType, paramList);
                                isParentConstructorPresent = true;
                        } catch (SymbolNotDefinedException s) {
                                // Don't throw the error right now, but check if call to super is present or not.
                                // If !present or if present but there is no ancestor's constructor that matches super call's
                                // argument and if 'isParentConstructorPresent' os also false, then throw error.
                                isParentConstructorPresent = false;
                                // 
                                deferedConstructor = functionType;
                        }
                }
                else currentClass.addSymbol(functionType);
                {if (true) return procedureNode;}
    } catch (IllegalSymbolValueException e) {
                                           {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

  final public void Block() throws ParseException, CompilationException {
        UXMLElement savedCurrentNode = currentNode, block = null;
    ScopeStart();
          block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
          currentNode.appendChild(block);
          currentNode = block;
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IF:
      case DO:
      case WHILE:
      case FOR:
      case CALL:
      case PRINT:
      case PRINTLN:
      case NEW:
      case RETURN:
      case STMT_TERMINATOR:
      case ID:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_11;
      }
      Statement();
    }
    ScopeEnd();
          currentNode = savedCurrentNode;
  }

/**
 * Scope start
 * {
 */
  final public void ScopeStart() throws ParseException {
    jj_consume_token(BLOCK_START);
                Environment.currentActivationRecord.enterTheBlock();
  }

/**
 * Scope end
 * }
 */
  final public void ScopeEnd() throws ParseException {
    jj_consume_token(BLOCK_END);
                Environment.currentActivationRecord.leaveTheBlock();
  }

  final public void Statement() throws ParseException, CompilationException {
        UXMLElement procCall = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      Assignment();
      break;
    case IF:
      IfElse();
      break;
    case FOR:
      ForLoop();
      break;
    case DO:
      DoWhile();
      break;
    case WHILE:
      WhileDo();
      break;
    case PRINT:
    case PRINTLN:
      Print();
      break;
    case CALL:
    case NEW:
      procCall = FunctionCall();
      jj_consume_token(STMT_TERMINATOR);
                                                                                                                          currentNode.appendChild(procCall);
      break;
    case RETURN:
      Return();
      break;
    case STMT_TERMINATOR:
      jj_consume_token(STMT_TERMINATOR);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Assignment() throws ParseException, CompilationException {
        UXMLElement lhsElement = null, rhsElement = null, savedCurrentNode = currentNode, assignment = null;
        Symbol lhsSymbol = null, rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        OOVariableAccess ooVariableAccess = null;
    ooVariableAccess = VariableAccess(false);
                                                   lhsElement = ooVariableAccess.getVariableElement();
    jj_consume_token(ASSIGN);
    rhsElement = Expression();
    jj_consume_token(STMT_TERMINATOR);
                lhsSymbol = lhsElement.getSymbol();
                rhsSymbol = rhsElement.getSymbol();

                try {
                        if(lhsSymbol instanceof ArrayType)
                                ((ArrayType)lhsSymbol).copyArray(rhsSymbol);
                        else
                                lhsSymbol.setValue(rhsSymbol);
                } catch(ImmutableSymbolException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(TypeMismatchException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                assignment = UXMLElementFactory.generateElement(Constants.ASSIGN, null ,null);
                attributes.put(Constants.NAME, lhsSymbol.getName());
                if(rhsElement.getElement() == null)
                        assignment.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,lhsSymbol));
                else
                        assignment.appendChild(lhsElement);
                assignment.appendChild(rhsElement);
                currentNode.appendChild(assignment);
  }

  final public void IfElse() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode;
    jj_consume_token(IF);
    jj_consume_token(ROUND_START);
    MultiConditions();
    jj_consume_token(ROUND_END);
    Block();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      Block();
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    currentNode = parentNode;
  }

  final public void MultiConditions() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement parentNode = currentNode, savedCurrentNode = currentNode, not = null, condition = null, lhsCondition = null,rhsCondition = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        Symbol lhsSymbol = null, rhsSymbol = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    try {
      lhsCondition = Condition();
      label_12:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
        case OR:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_12;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          t = jj_consume_token(AND);
                           t.image = "$$";
          break;
        case OR:
          t = jj_consume_token(OR);
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                        operatorName = t.image;
        rhsCondition = Condition();
                        lhsSymbol = lhsCondition.getSymbol();
                        rhsSymbol = rhsCondition.getSymbol();
                        attributes.clear();
                        attributes.put(Constants.VALUE, operatorName);
                        operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                        operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                        condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                        condition.appendChild(lhsCondition);
                        condition.appendChild(rhsCondition);

                        currentNode = savedCurrentNode;
                        currentNode.appendChild(condition);

                        savedCurrentNode = currentNode;
                        lhsCondition = condition;
      }
                        if(condition != null)
                                currentNode = condition;
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    } catch (OperatorNotFoundException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
  }

  final public UXMLElement Condition() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement lhsExpression = null, rhsExpression = null, condition = null;
        Symbol lhsSymbol = null, rhsSymbol = null;
        String operatorName = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        HashMap<String,String> attributes = new HashMap<String, String>();
    lhsExpression = Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
    case NT_EQ:
    case LT:
    case LT_EQ:
    case GT_EQ:
    case GT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NT_EQ:
        t = jj_consume_token(NT_EQ);
        break;
      case LT:
        t = jj_consume_token(LT);
                                              t.image = "(";
        break;
      case LT_EQ:
        t = jj_consume_token(LT_EQ);
                                                                             t.image = "(=";
        break;
      case GT:
        t = jj_consume_token(GT);
                                                                                                         t.image = ")";
        break;
      case GT_EQ:
        t = jj_consume_token(GT_EQ);
                                                                                                                                       t.image = ")=";
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                operatorName = t.image;
      rhsExpression = Expression();
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
                lhsSymbol = lhsExpression.getSymbol();
                try {
                        // Unary operator
                        if(operatorName == null)
                        {
                                operatorName = "==";
                                attributes.clear();
                                attributes.put(Constants.VALUE, operatorName);
                                operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                                condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                                condition.appendChild(lhsExpression);
                                currentNode.appendChild(condition);
                                currentNode = condition;
                                {if (true) return condition;}
                        }
                        // Binary operator
                        else {
                                rhsSymbol = rhsExpression.getSymbol();
                                attributes.clear();
                                attributes.put(Constants.VALUE, operatorName);
                                operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                                operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                                condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                                condition.appendChild(lhsExpression);
                                condition.appendChild(rhsExpression);
                                currentNode.appendChild(condition);
                                currentNode = condition;
                                {if (true) return condition;}
                        }
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(OperatorNotFoundException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
    throw new Error("Missing return statement in function");
  }

  final public void ForLoop() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, for_loop = null, controllerNode = null, savedCurrentNode = null;
        Symbol variableSymbol = null, variableValueSymbol = null;
        UXMLElement variableSymbolElement = null, variableValueElement = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        OOVariableAccess ooVariableAccess = null;
    jj_consume_token(FOR);
        for_loop = UXMLElementFactory.generateElement(Constants.FOR_LOOP, null, null);
        currentNode.appendChild(for_loop);
        currentNode = for_loop;
    jj_consume_token(ROUND_START);
        controllerNode = UXMLElementFactory.generateElement(Constants.FROM, null, null);
        currentNode.appendChild(controllerNode);
        savedCurrentNode = currentNode;
        currentNode = controllerNode;
    Assignment();
        currentNode = savedCurrentNode;

        controllerNode = UXMLElementFactory.generateElement(Constants.TILL, null, null);
        currentNode.appendChild(controllerNode);
        savedCurrentNode = currentNode;
        currentNode = controllerNode;
    MultiConditions();
    jj_consume_token(STMT_TERMINATOR);
        currentNode = savedCurrentNode;

        controllerNode = UXMLElementFactory.generateElement(Constants.STEP, null, null);
        currentNode.appendChild(controllerNode);

        savedCurrentNode = currentNode;
        currentNode = controllerNode;
    ooVariableAccess = VariableAccess(false);
        variableSymbolElement = ooVariableAccess.getVariableElement();
        controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
    jj_consume_token(ASSIGN);
    variableValueElement = Expression();
    jj_consume_token(ROUND_END);
        variableSymbol = variableSymbolElement.getSymbol();

        variableValueSymbol = variableValueElement.getSymbol();
        try {
                variableSymbol.setValue(variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol);
                attributes.put(Constants.NAME, variableSymbol.getName());
                controllerNode.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol));
                currentNode.appendChild(controllerNode);

                currentNode = controllerNode;

                currentNode.appendChild(variableValueElement);
                currentNode = savedCurrentNode;
        } catch(ImmutableSymbolException e) {
                {if (true) throw new CompilationException(e.getMessage());}
        } catch(TypeMismatchException e) {
                {if (true) throw new CompilationException(e.getMessage());}
        } catch(IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
        }
    Block();
            currentNode = parentNode;
  }

  final public void DoWhile() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, iterate = null, till = null;
    jj_consume_token(DO);
                iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
                currentNode.appendChild(iterate);
                currentNode = iterate;
    Block();
    jj_consume_token(WHILE);
        till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
        currentNode.appendChild(till);
        currentNode = till;
    jj_consume_token(ROUND_START);
    MultiConditions();
    jj_consume_token(ROUND_END);
    jj_consume_token(STMT_TERMINATOR);
                         currentNode = parentNode;
  }

  final public void WhileDo() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, iterate = null, till = null;
    jj_consume_token(WHILE);
        iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
        currentNode.appendChild(iterate);
        currentNode = iterate;

        till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
        currentNode.appendChild(till);
        currentNode = till;
    jj_consume_token(ROUND_START);
    MultiConditions();
    jj_consume_token(ROUND_END);
         currentNode = iterate;
    Block();
            currentNode = parentNode;
  }

  final public void Return() throws ParseException, CompilationException {
        UXMLElement returnExpression = null, returnElement = null;
        String requiredReturnType = null, foundReturnType = null;
        Symbol returnSymbol = null;
    jj_consume_token(RETURN);
    returnExpression = Expression();
                returnElement = UXMLElementFactory.generateElement(Constants.RETURN, null, null);
                returnSymbol = returnExpression.getSymbol();
                returnSymbol = (returnSymbol instanceof FunctionType)? ((FunctionType)returnSymbol).getReturnValue():returnSymbol;
                returnElement.appendChild(returnExpression);
                currentNode.appendChild(returnElement);

                // Try to set the return symbol into the return value of currentfunction. 
                // If the return-type is not compatible then error will be thrown
                try {
                        requiredReturnType = DataTypeFinder.getDataType(currentProcedure.getReturnValue());
                        foundReturnType = DataTypeFinder.getDataType(returnSymbol);
                        if(requiredReturnType.equals(foundReturnType)) {
                                Symbol returnValue = currentProcedure.getReturnValue();
                                if(returnValue instanceof ArrayType)
                                        ((ArrayType) returnValue).copyArray(returnSymbol);
                        }
                        else
                                {if (true) throw new TypeMismatchException(foundReturnType,requiredReturnType);}
                        isReturnStmtPresent = true;
                  } catch(TypeMismatchException e) {
                          {if (true) throw new CompilationException("Function '" + currentProcedure.getName()
                                          + "' should return '" + requiredReturnType + "' and not '"  + foundReturnType + "'.",e.getMessage());}
                  } catch(SymbolNotDefinedException e) {System.err.println(e.getMessage());}
    jj_consume_token(STMT_TERMINATOR);
  }

  final public void Print() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement print, expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRINT:
      t = jj_consume_token(PRINT);
      break;
    case PRINTLN:
      t = jj_consume_token(PRINTLN);
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                print = UXMLElementFactory.generateElement(t.image, null, null);
    jj_consume_token(ROUND_START);
    expression = Expression();
                        print.appendChild(expression);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_13;
      }
      jj_consume_token(COMMA);
      expression = Expression();
                                print.appendChild(expression);
    }
    jj_consume_token(ROUND_END);
    jj_consume_token(STMT_TERMINATOR);
                currentNode.appendChild(print);
  }

  final public UXMLElement FunctionCall() throws ParseException, CompilationException {
        UXMLElement argumentElement = null, functionElement = null, call = null, variableElement = null;
        String functionElementName = null, functionName = null;
        Symbol argumentSymbol = null, functionType = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
        FunctionType functionSymbol = null;
        ClassType classType = null, classAccessed = null;
        boolean isConstructorCall = false;
        OOVariableAccess ooVariableAccess = null;
                call = UXMLElementFactory.generateElement(Constants.CALL, attributes, null);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CALL:
      jj_consume_token(CALL);
      break;
    case NEW:
      jj_consume_token(NEW);
                          isConstructorCall = true;
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    ooVariableAccess = VariableAccess(true);
                functionElement = ooVariableAccess.getVariableElement();
                classAccessed = ooVariableAccess.getClassUsed();
                functionElementName = functionElement.getElementName();

                // If constructor call, then function name would be '#new#'
                if(isConstructorCall) {
                        try {
                        classType = (ClassType)functionElement.getSymbol();
                        functionName = Constants.CONSTRUCTOR;                   // Set the method name to be '#new'
                        // If this is a constructor call, functionType contains an instance of class type
                        // Hence set it in functionElement.
                        functionElement.setSymbol(classType);
                        // Since functionType has to be a class-type, extract the constructor list from current class

                        functionType = classType.getSymbol(Constants.CONSTRUCTOR);
                        } catch(SymbolNotDefinedException e) {{if (true) throw new CompilationException(e.getMessage());}}
                        // If class-cast, it means function-type is not of class-type and hence throw compilation exception
                        catch(ClassCastException e)
                        {{if (true) throw new CompilationException("Constructor call is allowed for class-type and not '" + functionType.getType() +"'.");}}

                } else {
                        functionType = functionElement.getSymbol();
                        functionType = functionElement.getSymbol();
                        functionName = functionType.getName();
                }
                // Normal function call
                if(Constants.VARIABLE.equals(functionElementName)){
                        if(isConstructorCall) {
                                attributes.clear();
                                attributes.put(Constants.NAME,Constants.CONSTRUCTOR);
                                call.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                                call.appendChild(functionElement);
                        }
                        call.appendChild(functionElement);
                }
                // If array entry is present instead of function i.e. call a[1] is not allowed.
                else if(Constants.OPERATOR.equals(functionElementName))
                {{if (true) throw new CompilationException("Expected function type, but received " + functionType.getType());}}
                // If this is field, then replace the outermost element with variable, since outermost element is actually function name.
                else if(Constants.FIELD.equals(functionElementName)) {
                        attributes.clear();
                        attributes.put(Constants.NAME,functionElement.getAttributeValue(Constants.NAME));
                        variableElement = UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null);
                        call.appendChild(variableElement);
                        call.appendChild(functionElement.getFirstChild());
                }
    jj_consume_token(ROUND_START);
    argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                // Check if expression is void and if yes, then no-argument function call is made
                if(!Constants.VOID.equals(argumentSymbol.getType())) {
                        actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                        call.appendChild(argumentElement);
                }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_14;
      }
      jj_consume_token(COMMA);
      argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                call.appendChild(argumentElement);
    }
    jj_consume_token(ROUND_END);
                try {

                        // If this is the recursive call, then just extract the current Procedure
                        if(functionName.equals(currentProcedureName))
                                functionSymbol = currentProcedure;
                        else {

                                if(!(functionType instanceof OverloadedFunctionType))
                                        {if (true) throw new CompilationException("Type mismatch \n Found    : '" + functionName + DataTypeFinder.getDataType(functionType) + "' \n Required : '" + functionName + "'");}

                                // Get the function - Old code
                                //functionSymbol = ((OverloadedFunctionType) functionType).getFunction(actualArgs);

                                // Extract the correct function Type from class accessed
                                functionSymbol = classAccessed.lookupFunction(functionName,actualArgs);
                        }
                } catch (SymbolNotDefinedException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                if(isConstructorCall) call.setSymbol(classType);
                else call.setSymbol(functionSymbol);
                {if (true) return call;}
    throw new Error("Missing return statement in function");
  }

  final public UXMLElement SuperClassCall() throws ParseException, CompilationException {
        UXMLElement argumentElement = null, functionElement = null, call = null, variableElement = null;
        String functionElementName = null, functionName = Constants.SUPER_CLASS;
        Symbol argumentSymbol = null, functionType = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
        FunctionType functionSymbol = null;
        boolean isConstructorCall = false;
                call = UXMLElementFactory.generateElement(Constants.CALL, attributes, null);
    jj_consume_token(SUPER_CALL);
                attributes.clear();
                attributes.put(Constants.NAME,Constants.SUPER_CLASS);
                call.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                attributes.clear();
                attributes.put(Constants.NAME,Constants.THIS);
                call.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                try {
                        functionType = currentClass.getSymbol(Constants.CONSTRUCTOR);
                } catch(SymbolNotDefinedException e) {{if (true) throw new CompilationException(e.getMessage());}}
    jj_consume_token(ROUND_START);
    argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                // Check if expression is void and if yes, then no-argument function call is made
                if(!Constants.VOID.equals(argumentSymbol.getType())) {
                        actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                        call.appendChild(argumentElement);
                }
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[31] = jj_gen;
        break label_15;
      }
      jj_consume_token(COMMA);
      argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                call.appendChild(argumentElement);
    }
    jj_consume_token(ROUND_END);
    jj_consume_token(STMT_TERMINATOR);
                try {
                        // If this is the recursive call, then just extract the current Procedure
                        if(functionName.equals(currentProcedureName))
                                functionSymbol = currentProcedure;
                        else {

                                if(!(functionType instanceof OverloadedFunctionType))
                                        {if (true) throw new CompilationException("Type mismatch \n Found    : '" + functionName + DataTypeFinder.getDataType(functionType) + "' \n Required : '" + functionName + "'");}

                                // Get the function - Old code
                                //functionSymbol = ((OverloadedFunctionType) functionType).getFunction(actualArgs);

                                // Extract the correct function Type from class accessed
                                functionSymbol = currentClass.lookupFunction(functionName,actualArgs);

                        }
                } catch (SymbolNotDefinedException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                call.setSymbol(functionSymbol);
                {if (true) return call;}
    throw new Error("Missing return statement in function");
  }

// isFunctionCall - If function call
// Access Variable
  final public OOVariableAccess VariableAccess(boolean isFunctionCall) throws ParseException, CompilationException {
        UXMLElement variableSymbolElement = null, fieldAccessElement = null, fieldElement = null;
        String variableName = null;
        Token t = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        Symbol variableSymbol = null,fieldAccessSymbol = null;
        ArrayList<UXMLElement> fieldAccessList = new ArrayList<UXMLElement>();
        ClassType classAccessed = currentClass;
    t = jj_consume_token(ID);
                variableName = t.image;
                // If this is a function call, then simply store the current procedure.
                // This trick is to enable recursive calls. 
                if(isFunctionCall && variableName.equals(currentProcedureName))
                        variableSymbol = currentProcedure;
                // If the reference is 'this' then it means current class
                else if(Constants.THIS.equals(variableName))
                        variableSymbol = currentClass;
                else {
                        try {
                                variableSymbol = Environment.getSymbol(variableName);
                        } catch(SymbolNotDefinedException e)
                        {
                                try { variableSymbol = classAccessed.getSymbol(variableName); }
                                catch (SymbolNotDefinedException f) {{if (true) throw new CompilationException(f.getMessage());} }
                        }
                }
                attributes.clear();
                attributes.put(Constants.NAME, variableName);
                variableSymbolElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol);
    variableSymbolElement = ArrayAccess(variableSymbolElement);
                fieldAccessList.add(variableSymbolElement);
                variableSymbol = variableSymbolElement.getSymbol();
                // If this is a constructor call, then variableSymbol will contain the classtype
                if(variableSymbol instanceof ClassType)
                        classAccessed = (ClassType)variableSymbol;
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PERIOD:
        ;
        break;
      default:
        jj_la1[32] = jj_gen;
        break label_16;
      }
      jj_consume_token(PERIOD);
                // If this is accessed using '.', it means variableSymbol accessed earlier was a class-type.
                if(variableSymbol instanceof ClassType)
                        classAccessed = (ClassType)variableSymbol;
                else
                        {if (true) throw new CompilationException("Expected classType, but received " + variableSymbol.getType());}
                // Add the field access elements in the array list

      t = jj_consume_token(ID);
                variableName = t.image;
                // If this is a function call, then simply store the current procedure.
                // This trick is to enable recursive calls
                if(isFunctionCall && variableName.equals(currentProcedureName))
                        variableSymbol = currentProcedure;
                else {
                        try {
                                variableSymbol = Environment.getSymbol(variableName);
                        } catch(SymbolNotDefinedException e)
                        {
                                try { variableSymbol = classAccessed.getSymbol(variableName); }
                                catch (SymbolNotDefinedException f) {{if (true) throw new CompilationException(f.getMessage());} }
                        }
                }
                attributes.clear();
                attributes.put(Constants.NAME, variableName);
                variableSymbolElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol);
      variableSymbolElement = ArrayAccess(variableSymbolElement);
                fieldAccessList.add(variableSymbolElement);
                variableSymbol = variableSymbolElement.getSymbol();
    }
                // If size of fieldAccessList > 1, it means that this is a field access
                variableSymbolElement = fieldAccessList.get(0);
                for(int fieldAccessNo = 1; fieldAccessNo < fieldAccessList.size(); fieldAccessNo++) {
                        fieldAccessElement = fieldAccessList.get(fieldAccessNo);
                        fieldAccessSymbol = fieldAccessElement.getSymbol();
                        attributes.clear();

                        // If this is an operator, the 'variable' element by 'field
                        if(Constants.OPERATOR.equals(fieldAccessElement.getElementName())) {
                                UXMLElement operatorChild = fieldAccessElement.getFirstChild();
                                attributes.put(Constants.NAME,operatorChild.getAttributeValue(Constants.NAME));
                                fieldElement = UXMLElementFactory.generateElement(Constants.FIELD, attributes, fieldAccessSymbol);
                                fieldElement.appendChild(variableSymbolElement); // Append the variable to the current field element
                                // Replace the 'variable' element with 'field' element
                                fieldAccessElement.replaceChild(fieldElement,operatorChild);
                                variableSymbolElement = fieldAccessElement;
                        }
                        else {
                                attributes.put(Constants.NAME,fieldAccessElement.getAttributeValue(Constants.NAME));
                                fieldElement = UXMLElementFactory.generateElement(Constants.FIELD, attributes, fieldAccessSymbol);
                                fieldElement.appendChild(variableSymbolElement);
                                variableSymbolElement = fieldElement;
                        }
                }
//		ooVariableAccess.setClassUsed(classAccessed);
//		ooVariableAccess.setVariableElement(variableSymbolElement);
                {if (true) return new OOVariableAccess(classAccessed,variableSymbolElement);}//ooVariableAccess;

    throw new Error("Missing return statement in function");
  }

/**
 * E -> T1 E_L
 */
  final public UXMLElement Expression() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Expression_Left(Term1());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * E_L -> (& | | | ^ ) T1 E_L
 */
  final public UXMLElement Expression_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AMPERSAND:
    case BIT_OR:
    case BIT_XOR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
        t = jj_consume_token(AMPERSAND);
                           t.image = "$";
        break;
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_XOR:
        t = jj_consume_token(BIT_XOR);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Term1();
                 rhsSymbol = currentRHS.getSymbol();
                 try {
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Expression_Left(currentLHS);
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T1 -> T2 T1_L
 */
  final public UXMLElement Term1() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Term1_Left(Term2());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T1_L -> (+ | -) T2 T1_L
 */
  final public UXMLElement Term1_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Term2();
                 try {
                         rhsSymbol = currentRHS.getSymbol();
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Term1_Left(currentLHS);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T2 -> F T2_L
 */
  final public UXMLElement Term2() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Term2_Left(Factor());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T2_L -> (* | / | %) F T2_L
 */
  final public UXMLElement Term2_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        String operatorName = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
    case DIVIDE:
    case MOD:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        t = jj_consume_token(ASTERISK);
        break;
      case DIVIDE:
        t = jj_consume_token(DIVIDE);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Factor();
                 try {
                         rhsSymbol = currentRHS.getSymbol();
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         // Make sure that div doesn't give divide by zero error
                         try {
                                 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         } catch(RuntimeException e)
                         {
                                 Symbol param1 = operands.get(0);
                                 Symbol param2 = operands.get(1);
                                 if(param1.getDataType() == DATA_TYPE.FLOAT || param2.getDataType() == DATA_TYPE.FLOAT)
                                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes,
                                                         SymbolMachine.generate(Constants.BLANK, Constants.FLOAT, true));
                                 else
                                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes,
                                                         SymbolMachine.generate(Constants.BLANK, Constants.INT, true));
                         }
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Term2_Left(currentLHS);
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/** 
 * F -> (E) | VariableAccess() | Constant() | <VOID> | FunctionCall()
 */
  final public UXMLElement Factor() throws ParseException, CompilationException {
        Token t = null;
        String typeCast = null;
        Symbol value = null;
        UXMLElement expressionValue = null, returnFactorValue = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        OOVariableAccess ooVariableAccess = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BLOCK_START:
      jj_consume_token(BLOCK_START);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
        break;
      case CHAR:
        t = jj_consume_token(CHAR);
        break;
      case BOOL:
        t = jj_consume_token(BOOL);
        break;
      case STRING:
        t = jj_consume_token(STRING);
        break;
      case CLASS:
        jj_consume_token(CLASS);
        t = jj_consume_token(ID);
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                                                                        typeCast = t.image;
      jj_consume_token(BLOCK_END);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROUND_START:
      jj_consume_token(ROUND_START);
      expressionValue = Expression();
                                                               returnFactorValue =  expressionValue ;
      jj_consume_token(ROUND_END);
      break;
    case ID:
      ooVariableAccess = VariableAccess(false);
                                expressionValue = ooVariableAccess.getVariableElement();
                                value = expressionValue.getSymbol();

                                // Skip the creation of 'variable' element if this is an array and field access  
                                if((!(Constants.OPERATOR.equals(expressionValue.getElementName()) &&
                                                                Constants.VALUE_AT_INDEX.equals(expressionValue.getAttributeValue(Constants.VALUE)))) &&
                                !(Constants.FIELD.equals(expressionValue.getElementName()))) {
                                        attributes.clear();
                                        attributes.put(Constants.NAME, expressionValue.getSymbol().getName());
                                        expressionValue = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,expressionValue.getSymbol());
                                }
                                returnFactorValue = expressionValue;
      break;
    case INT_CONSTANT:
    case FLOAT_CONSTANT:
    case STRING_CONSTANT:
    case BOOL_CONSTANT:
    case CHAR_CONSTANT:
      value = Constants();
                                        returnFactorValue =  new UXMLElement(null,value);
      break;
    case CALL:
    case NEW:
      expressionValue = FunctionCall();
                                                     returnFactorValue = expressionValue;
      break;
    case VOID:
      jj_consume_token(VOID);
                          try { returnFactorValue =  new UXMLElement(null,SymbolMachine.generate(Constants.BLANK,Constants.VOID, false));  } catch(Exception e ){}
      break;
    default:
      jj_la1[41] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                try {
                        if(typeCast != null) {
                                attributes.clear();
                                attributes.put(Constants.TYPE, typeCast);
                                expressionValue = UXMLElementFactory.generateElement(Constants.CAST ,attributes, SymbolMachine.cast(returnFactorValue.getSymbol(), typeCast));
                                expressionValue.appendChild(returnFactorValue);
                                returnFactorValue = expressionValue;
                        }
                } catch(TypeMismatchException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch (SymbolNotDefinedException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch (IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                {if (true) return returnFactorValue;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public JTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[42];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x3e0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6000000,0x6000000,0xf0000000,0xf0000000,0x0,0x0,0x0,0x0,0x0,0x0,0xe00000,0xe00000,0x30000,0x30000,0x1c0000,0x1c0000,0x0,0x0,0x3e0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0xc0002000,0x400000,0x8000000,0x400000,0x2000,0x8000000,0x4000,0x48000,0xc0003000,0xc0003000,0x8000000,0x8000000,0x4000000,0x10000,0x100a0fc8,0xc0002000,0x48000,0x8000000,0xc0002000,0x100a0fc8,0x100a0fc8,0x20,0x0,0x0,0x3,0x3,0xc00,0x8000000,0x20200,0x8000000,0x8000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0xc0002000,0x100000,0x1020200,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x7,0x0,0x0,0x0,0x0,0x20,0xf,0x0,0x0,0x7,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x28,};
   }

  /** Constructor with InputStream. */
  public J(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public J(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 42; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 42; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public J(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new JTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 42; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 42; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public J(JTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 42; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(JTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 42; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[72];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 42; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 72; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
