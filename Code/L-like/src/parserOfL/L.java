/* Generated By:JavaCC: Do not edit this line. L.java */
package parserOfL;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Scanner;

import compiler.components.*;
import compiler.dataTypes.*;
import compiler.exceptions.*;
import compiler.operator.*;
import compiler.util.*;
import compiler.util.Constants.DATA_TYPE;
import compiler.uXMLGenerator.*;

import xvHandler.Executor;
import xvHandler.CodeAnalysis;
import xvHandler.ProcedureCallSeq;

import parserOfL.exceptions.*;

@SuppressWarnings("all")
public class L implements LConstants {

        private static UXMLElement currentNode = null;
        private static FunctionType currentFunctionType = null;
        private static int nestedLevelOfFunction = 0; // Represents the nested level of a procedure
        private static boolean isVarDeclaration = false;
        private static FunctionType currentFunction = null;
        private static String currentFunctionName = null;
        private static boolean isFunctionCallRequired = true;
        private static boolean skipFunctionCall = false;

        public static void main(String args[]) throws ParseException {
                FileInputStream io = null;
                String codeAnalysisFlag = null;

                String fileName = null;
            if(args.length == 0) {
                Scanner in = new Scanner(System.in);
                System.out.print("Enter the file name @ src/sampleLLikeProgs/");
                fileName = in.nextLine();
                while(fileName.trim().length() == 0)
                        fileName = in.nextLine();
                codeAnalysisFlag = in.nextLine();
                args = new String[1];
                args[0] = fileName;
            }
            else  {
                fileName = args[0];
                if(args.length > 1)
                        codeAnalysisFlag = args[1];
            }

            try {
                io = new FileInputStream("src/sampleLLikeProgs/" + fileName + ".Llike");
                L parser = new L(io);

                // Initialize the environment with ignore dynamic variable flag
                Environment.initialize(new ProcedureCallSeq(), true);
                // Initialize the uXMLDocument generator
                currentNode = UXMLElementFactory.initialize("Llike", Constants.STATIC);

                Environment.currentActivationRecord.enterTheBlock();
                parser.LLike();
                Environment.currentActivationRecord.leaveTheBlock();

                // Save the uXML document
                UXMLElementFactory.done(fileName);

                if("-analysis".equals(codeAnalysisFlag))
                        CodeAnalysis.main(args);
                else
                        Executor.main(args);

            } catch (FileNotFoundException fe) {
                System.err.println("File '" + fileName + "' not found.");
                System.exit(1);
            } catch(ParseException e) {
                String message = e.getMessage();
                int startIndex = message.indexOf("line ") + 5;
                int endIndex = message.indexOf(",");
                String lineNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("column ") + 7;
                endIndex = message.indexOf(".");
                String columnNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("\"") + 1;
                endIndex = message.lastIndexOf("\" at line");
                String keyword = message.substring(startIndex, endIndex).replaceAll("\"","").trim();

                System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
                StringBuffer expectedTokens = new StringBuffer("Expected tokens : ");
                String tokenValue = null;
                tokenValue = tokenImage[e.expectedTokenSequences[0][0]];
                tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                expectedTokens.append(tokenValue);
                for(int tokenId = 1; tokenId < e.expectedTokenSequences.length;tokenId++) {
                        tokenValue = tokenImage[e.expectedTokenSequences[tokenId][0]];
                        tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                        expectedTokens.append(", ")
                                .append(tokenValue);
                }
                System.err.println(expectedTokens.toString());
            } catch(TokenMgrError e) {
                String message = e.getMessage();
                        int startIndex = message.indexOf("line ") + 5;
                        int endIndex = message.indexOf(",");
                        String lineNo = message.substring(startIndex, endIndex).trim();

                        startIndex = message.indexOf("column ") + 7;
                        endIndex = message.indexOf(".");
                        String columnNo = message.substring(startIndex, endIndex).trim();

                        startIndex = message.indexOf("\"") + 1;
                        endIndex = message.indexOf("\"",startIndex);
                        String keyword = message.substring(startIndex, endIndex).trim();

                        System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
            }
            catch(CompilationException e) {
                System.err.println(e.getMessage());
            }
  }



        /**
	 * Scope Start
	 */
        private static void ScopeStart() /*throws CompilationException :*/
        {
                UXMLElement block = null;

                nestedLevelOfFunction++; // Increase the nested level

                // Execute the calling sequence of a caller - 
//	        Environment.callSequenceProcessor.callAction_caller(nestedLevelOfFunction);
//        Environment.currentActivationRecord.enterTheBlock();
        }

        /**
	 * Scope End
	 */
        private static void ScopeEnd() /*throws CompilationException : {}*/
        {
//		Environment.currentActivationRecord.leaveTheBlock();
//			Environment.callSequenceProcessor.returnAction_caller();
                nestedLevelOfFunction--; // Decrease the nested level
        }

/**
 * Constants
 */
  final public Symbol Constants() throws ParseException, CompilationException {
                                                  Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_CONSTANT:
        t = jj_consume_token(INT_CONSTANT);
                                        {if (true) return new ConstantValue(Constants.INT,t.image);}
        break;
      case FLOAT_CONSTANT:
        t = jj_consume_token(FLOAT_CONSTANT);
                                           {if (true) return new ConstantValue(Constants.FLOAT,t.image);}
        break;
      case CHAR_CONSTANT:
        t = jj_consume_token(CHAR_CONSTANT);
                        String ch = t.image.substring(1,2);
                        {if (true) return new ConstantValue(Constants.CHAR,ch);}
        break;
      case STRING_CONSTANT:
        t = jj_consume_token(STRING_CONSTANT);
                        String str = t.image;
                        str = str.substring(1, str.length() - 1);
                        {if (true) return new ConstantValue(Constants.STRING,str);}
        break;
      case BOOL_CONSTANT:
        t = jj_consume_token(BOOL_CONSTANT);
                                         {if (true) return new ConstantValue(Constants.BOOLEAN,t.image);}
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Conditional operators
 */
  final public String Conditional_Operators() throws ParseException, CompilationException {
        Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NT_EQ:
      t = jj_consume_token(NT_EQ);
      break;
    case LT:
      t = jj_consume_token(LT);
                                  t.image = "(";
      break;
    case LT_EQ:
      t = jj_consume_token(LT_EQ);
                                                                  t.image = "(=";
      break;
    case GT_EQ:
      t = jj_consume_token(GT_EQ);
                                                                                                   t.image = ")=";
      break;
    case GT:
      t = jj_consume_token(GT);
                                                                                                                                  t.image = ")";
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

/**
 * Built-in functions
 */
  final public UXMLElement BuiltInFunctions() throws ParseException, CompilationException {
        Token t = null; Symbol value = null;
        UXMLElement functionNameElement = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      /* Arithematic */
                      t = jj_consume_token(PLUS);
      break;
    case MINUS:
      t = jj_consume_token(MINUS);
      break;
    case MULTIPLY:
      t = jj_consume_token(MULTIPLY);
      break;
    case DIVIDE:
      t = jj_consume_token(DIVIDE);
      break;
    case MOD:
      t = jj_consume_token(MOD);
      break;
    case BIT_OR:
      t = jj_consume_token(BIT_OR);
      break;
    case BIT_XOR:
      t = jj_consume_token(BIT_XOR);
      break;
    case BIT_COMPLEMENT:
      t = jj_consume_token(BIT_COMPLEMENT);
      break;
    case MAP:
      /* Functional */
                      // If map/reduce, then immediate function should be just appended and hence it is not a function call.
                      t = jj_consume_token(MAP);
                            skipFunctionCall = true;
      break;
    case REDUCE:
      t = jj_consume_token(REDUCE);
                                                                         skipFunctionCall = true;
      break;
    case SETQ:
      /* Assignment */
                      t = jj_consume_token(SETQ);
                            t.image = "=";
      break;
    case ID:
      /* Call to defun function name */
                      t = jj_consume_token(ID);
                        try {
                                if(t.image.equals(currentFunctionName)) // If current function
                                        value = currentFunction;
                                else
                                        value = Environment.getSymbol(t.image);
                        } catch(SymbolNotDefinedException e) {{if (true) throw new CompilationException(e.getMessage());}}
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                        attributes.put(Constants.NAME,t.image);
                        functionNameElement = UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, value);
                        {if (true) return functionNameElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * Llike program
 */
  final public void LLike() throws ParseException, CompilationException {
        UXMLElement block = null, expressionElement = null, printElement = null, fatherOfLastElement = null;
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_CONSTANT:
      case FLOAT_CONSTANT:
      case STRING_CONSTANT:
      case BOOL_CONSTANT:
      case CHAR_CONSTANT:
      case START:
      case ID:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
      expressionElement = Expression();
    }
                // Add the print statement to last evaluated statement
                fatherOfLastElement = expressionElement.getParent();
                printElement = UXMLElementFactory.generateElement(Constants.PRINT, null, null);
                printElement.appendChild(expressionElement);
                fatherOfLastElement.appendChild(printElement);
  }

/**
 * Variable declaration
 */
  final public UXMLElement VarDeclaration() throws ParseException, CompilationException {
        UXMLElement savedCurrentNode = currentNode, block = null, expressionElement = null;
    jj_consume_token(LET);
    jj_consume_token(START);
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      jj_consume_token(START);
      ValueBinding();
      jj_consume_token(END);
    }
    jj_consume_token(END);
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_CONSTANT:
      case FLOAT_CONSTANT:
      case STRING_CONSTANT:
      case BOOL_CONSTANT:
      case CHAR_CONSTANT:
      case START:
      case ID:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
      expressionElement = Expression();
    }
                currentNode = savedCurrentNode;
                {if (true) return expressionElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * Defines the value binding that is used in variable declaration during 'let' function call.
 */
  final public void ValueBinding() throws ParseException, CompilationException {
        Token t = null;
        String variableName = null;
        UXMLElement variableElement = null, valueElement = null;
        Symbol variable, value = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
    t = jj_consume_token(ID);
                   variableName = t.image;
    valueElement = Expression();
                value = valueElement.getSymbol();
                try {
                        variable = SymbolMachine.generate(variableName, value.getType(), true); // non-mutable
                        Environment.currentActivationRecord.addSymbol(variable); // Add in symbol table
                } catch(IllegalSymbolValueException e) {{if (true) throw new CompilationException(e.getMessage());}}
                attributes.clear();
                attributes.put(Constants.NAME, variableName);
                attributes.put(Constants.TYPE, value.getType());
                attributes.put(Constants.MUTABLE, "yes"); // non-mutable
                variableElement = UXMLElementFactory.generateElement(Constants.VAR, attributes, variable);
                variableElement.appendChild(valueElement);
                currentNode.appendChild(variableElement);
  }

/**
 * Expression
 */
  final public UXMLElement Expression() throws ParseException, CompilationException {
        Symbol value = null; Token t = null;
        UXMLElement returnFactorValue = null, procedureNode = null, call = null, savedCurrentNode = currentNode, returnElement = null
        , expressionElement = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START:
      jj_consume_token(START);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START:
      case SETQ:
      case MAP:
      case REDUCE:
      case PLUS:
      case MINUS:
      case MULTIPLY:
      case DIVIDE:
      case MOD:
      case BIT_OR:
      case BIT_XOR:
      case BIT_COMPLEMENT:
      case ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SETQ:
        case MAP:
        case REDUCE:
        case PLUS:
        case MINUS:
        case MULTIPLY:
        case DIVIDE:
        case MOD:
        case BIT_OR:
        case BIT_XOR:
        case BIT_COMPLEMENT:
        case ID:
          procedureNode = BuiltInFunctions();
                                                        call = UXMLElementFactory.generateElement(Constants.CALL, null, null);
                                                        returnFactorValue = call;
                                                        call.appendChild(procedureNode);
                                                        currentNode = currentNode.appendChild(call);
          break;
        case START:
          procedureNode = LambdaFunction();
                                                        UXMLElement childOfCall = currentNode.getFirstChild();

                                                        // If currentNode is 'map' or 'reduce', then don't append the function
                                                        // to 'call' element, instead directly append it to current node.
                                                        // By this the function will be appended to the sibling <variable name='map'/>
                                                        // or <variable name='reduce'/>
                                                        if(Constants.CALL.equals(currentNode.getElementName()) && childOfCall != null && Constants.VARIABLE.equals(childOfCall.getElementName())
                                                                        &&
                                                        (Constants.MAP.equals(childOfCall.getAttributeValue(Constants.NAME)) ||
                                                                                Constants.REDUCE.equals(childOfCall.getAttributeValue(Constants.NAME)))) {

                                                                returnFactorValue = procedureNode;
                                                                currentNode = currentNode.appendChild(procedureNode);

                                                        }
                                                        else {
                                                                call = UXMLElementFactory.generateElement(Constants.CALL, null, null);
                                                                returnFactorValue = call;
                                                                call.appendChild(procedureNode);
                                                                currentNode = currentNode.appendChild(call);
                                                        }
          break;
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INT_CONSTANT:
          case FLOAT_CONSTANT:
          case STRING_CONSTANT:
          case BOOL_CONSTANT:
          case CHAR_CONSTANT:
          case START:
          case ID:
            ;
            break;
          default:
            jj_la1[7] = jj_gen;
            break label_4;
          }
          Expression();
        }
        break;
      case IF:
        /* Condition */
                                        returnFactorValue = Cond();
                                                            currentNode.appendChild(returnFactorValue);
        break;
      case LET:
        /* Variable Declaration */
                                        returnFactorValue = VarDeclaration();
        break;
      case DEFUN:
        /* Function definition call */
                                        returnFactorValue = DefunFunction();
                                                                      currentNode.appendChild(returnFactorValue);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(END);
      break;
    case INT_CONSTANT:
    case FLOAT_CONSTANT:
    case STRING_CONSTANT:
    case BOOL_CONSTANT:
    case CHAR_CONSTANT:
      value = Constants();
                        returnFactorValue = new UXMLElement(null,value);
                        currentNode.appendChild(returnFactorValue);
      break;
    case ID:
      t = jj_consume_token(ID);
                        attributes.clear();
                        attributes.put(Constants.NAME, t.image);
                        try {
                                // If variable declaration then generate the variable, else get it from symbol table.
                                if(isVarDeclaration) {
                                        value = SymbolMachine.generate(t.image,Constants.INT, true); // HARD_CODING
                                        attributes.put(Constants.TYPE, Constants.INT);                           // HARD_CODING
                                        attributes.put(Constants.MUTABLE, Constants.YES);
                                        returnFactorValue = UXMLElementFactory.generateElement(Constants.VAR, attributes,value );
                                }
                                else {
                                        value = Environment.getSymbol(t.image);
                                        returnFactorValue = UXMLElementFactory.generateElement(Constants.VARIABLE, attributes,value );
                                }
                        } catch(SymbolNotDefinedException e) {{if (true) throw new CompilationException(e.getMessage());}}
                        catch(IllegalSymbolValueException e) {{if (true) throw new CompilationException(e.getMessage());}}

                        currentNode.appendChild(returnFactorValue);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                currentNode = savedCurrentNode;
                if(isVarDeclaration && value != null)
                        Environment.currentActivationRecord.addSymbol(value);
                {if (true) return returnFactorValue;}
    throw new Error("Missing return statement in function");
  }

/**
 * Condition
 */
  final public UXMLElement Cond() throws ParseException, CompilationException {
        UXMLElement savedCurrentNode = currentNode, block = null, returnElement = null, expressionElement = null;
        UXMLElement call = UXMLElementFactory.generateElement(Constants.CALL, null, null);
        String operatorName = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
    jj_consume_token(IF);
    jj_consume_token(START);
    operatorName = Conditional_Operators();
                attributes.put(Constants.NAME, operatorName);
                call.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                currentNode = call;
    /* Arguments to the if-condition */
            expressionElement = Expression();
                                           call.appendChild(expressionElement);
    expressionElement = Expression();
                                           call.appendChild(expressionElement);
    jj_consume_token(END);
                block = call.appendChild(UXMLElementFactory.generateElement(Constants.BLOCK,null,null));
                block = block.appendChild(UXMLElementFactory.generateElement(Constants.RETURN,null,null));
    /* true */
            expressionElement = Expression();
                block.appendChild(expressionElement);
                returnElement = expressionElement;
                call.setSymbol(expressionElement.getSymbol()); // Set the return value
                block = call.appendChild(UXMLElementFactory.generateElement(Constants.BLOCK,null,null));
                block = block.appendChild(UXMLElementFactory.generateElement(Constants.RETURN,null,null));
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT_CONSTANT:
    case FLOAT_CONSTANT:
    case STRING_CONSTANT:
    case BOOL_CONSTANT:
    case CHAR_CONSTANT:
    case START:
    case ID:
      expressionElement = Expression();
                                             block.appendChild(expressionElement);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
                currentNode = savedCurrentNode;
                {if (true) return call;}
    throw new Error("Missing return statement in function");
  }

/**
 * Function definition of a Defun function.
 */
  final public UXMLElement DefunFunction() throws ParseException, CompilationException {
        UXMLElement functionBodyElement = null;
        Token t = null;
                ScopeStart();
    jj_consume_token(DEFUN);
    t = jj_consume_token(ID);
    /* Function name */
            functionBodyElement = FunctionDefinition(t.image);
                {if (true) return functionBodyElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * Function definition of a Lambda function.
 */
  final public UXMLElement LambdaFunction() throws ParseException, CompilationException {
        UXMLElement functionBodyElement = null;
                ScopeStart();
    jj_consume_token(START);
    jj_consume_token(LAMBDA);
    functionBodyElement = FunctionDefinition(Constants.LAMBDA);
    jj_consume_token(END);
                {if (true) return functionBodyElement;}
    throw new Error("Missing return statement in function");
  }

/**
 * Function Definition of a function (lambda/defun)
 */
  final public UXMLElement FunctionDefinition(String procedureName) throws ParseException, CompilationException {
        Token t = null;
        Symbol returnValue = null;
        FunctionType functionType = null;
        UXMLElement returnValueElement = null, procedureNode = null, functionBlock = null, automaticElement = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
                functionType = new FunctionType(procedureName, true, Constants.VOID);
                currentFunction = functionType; currentFunctionName = procedureName; // save current function.
                functionType.setNestedLevel(nestedLevelOfFunction);
                Environment.currentActivationRecord.addSymbol(functionType);
                attributes.clear();
                attributes.put(Constants.NAME, procedureName);
                procedureNode = UXMLElementFactory.generateElement(Constants.FUNCTION , attributes, null);
                automaticElement = UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null);
                procedureNode.appendChild(automaticElement);
    jj_consume_token(START);
    FormalParameters(automaticElement);
    jj_consume_token(END);
                functionBlock = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
    returnValueElement = Expression();
                // Set the return type
                returnValue = returnValueElement.getSymbol();
                functionType.setReturnType(Constants.VOID);
                functionType.setReturnValue(returnValue);
                // Lastly, set the function body
                functionBlock.appendChild(returnValueElement);
                procedureNode.appendChild(functionBlock); // Append the function block 

                ScopeEnd();
                {if (true) return procedureNode;}
    throw new Error("Missing return statement in function");
  }

/**
 * Formal parameters of the function.
 */
  final public void FormalParameters(UXMLElement automaticElement) throws ParseException, CompilationException {
        UXMLElement expressionElement = null;
          isVarDeclaration = true;
    expressionElement = Expression();
                                            automaticElement.appendChild(expressionElement);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_5;
      }
      jj_consume_token(COMMA);
      expressionElement = Expression();
                                                   automaticElement.appendChild(expressionElement);
    }
          isVarDeclaration = false;
  }

  /** Generated Token Manager. */
  public LTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[12];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x1f00,0xf0000000,0xffd0000,0x3f00,0x2000,0x3f00,0xffd2000,0x3f00,0xfffa000,0x3f00,0x3f00,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x1,0x10,0x10,0x0,0x10,0x10,0x10,0x12,0x10,0x10,0x8,};
   }

  /** Constructor with InputStream. */
  public L(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public L(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new LTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public L(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new LTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public L(LTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(LTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[39];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 12; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 39; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
