/* Generated By:JavaCC: Do not edit this line. C.java */
package parserOfC;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Scanner;

import compiler.components.Environment;
import compiler.components.Operators;
import compiler.components.Symbol;
import compiler.dataTypes.DataTypeFinder;
import compiler.dataTypes.SymbolMachine;
import compiler.dataTypes.ConstantValue;
import compiler.dataTypes.PointerType;
import compiler.dataTypes.FunctionType;
import compiler.dataTypes.OverloadedFunctionType;
import compiler.dataTypes.ArrayType;

import compiler.exceptions.IllegalSymbolValueException;
import compiler.exceptions.ImmutableSymbolException;
import compiler.exceptions.OperatorNotFoundException;
import compiler.exceptions.TypeMismatchException;
import compiler.exceptions.SymbolNotDefinedException;
import compiler.exceptions.ImmutableSymbolException;

import compiler.uXMLGenerator.*;
import compiler.operator.Operator;
import compiler.util.Clone;
import compiler.util.Constants;
import compiler.util.Constants.DATA_TYPE;

import parserOfC.exceptions.CompilationException;

//import parserOfC.visitor.GenerateuXMLCode;
import xvHandler.Executor;
import xvHandler.CodeAnalysis;
import xvHandler.ProcedureCallSeq;


@SuppressWarnings("all")
public class C implements CConstants {

  private static UXMLElement currentNode = null;
  private static boolean globalVariableDeclaration = false;
  private static String currentReturnType = null;
  private static FunctionType currentFunction = null;
  private static boolean isReturnStmtPresent = false;

  public static void main(String args[]) throws ParseException {

        FileInputStream io = null;
        String codeAnalysisFlag = null;

        String fileName = null;
    if(args.length == 0) {
        Scanner in = new Scanner(System.in);
        System.out.print("Enter the file name @ src/sampleCLikeProgs/");
        fileName = in.nextLine();
        while(fileName.trim().length() == 0)
                fileName = in.nextLine();
        codeAnalysisFlag = in.nextLine();
        args = new String[1];
        args[0] = fileName;
    }
    else {
        fileName = args[0];
        if(args.length > 1)
                codeAnalysisFlag = args[1];
    }

    try {
        io = new FileInputStream("src/sampleCLikeProgs/" + fileName + ".Clike");
        C parser = new C(io);

        // Initialize the environment with ignore dynamic variable flag
        Environment.initialize(new ProcedureCallSeq(), true);
        // Initialize the uXMLDocument generator
        currentNode = UXMLElementFactory.initialize("Clike", Constants.STATIC);


        //GenerateuXMLCode cProgramConverter = new GenerateuXMLCode();

        Environment.currentActivationRecord.enterTheBlock();
        //cProgram.accept(cProgramConverter);
        /*Node cProgram = */parser.CLike();
        Environment.currentActivationRecord.leaveTheBlock();

        // Save the uXML document
        UXMLElementFactory.done(fileName);

        // System.out.println("Calling backend..."); 
        // args = new String[1];
        // args[0] = fileName;
        if("-analysis".equals(codeAnalysisFlag))
                CodeAnalysis.main(args);
        else
                Executor.main(args);



    } catch (FileNotFoundException fe) {
        System.err.println("File '" + fileName + "' not found.");
        System.exit(1);
    } catch(ParseException e) {
        String message = e.getMessage();
        int startIndex = message.indexOf("line ") + 5;
        int endIndex = message.indexOf(",");
        String lineNo = message.substring(startIndex, endIndex).trim();

        startIndex = message.indexOf("column ") + 7;
        endIndex = message.indexOf(".");
        String columnNo = message.substring(startIndex, endIndex).trim();

        startIndex = message.indexOf("\"") + 1;
        endIndex = message.lastIndexOf("\" at line");
        String keyword = message.substring(startIndex, endIndex).replaceAll("\"","").trim();

        System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
        StringBuffer expectedTokens = new StringBuffer("Expected tokens : ");
        String tokenValue = null;
        tokenValue = tokenImage[e.expectedTokenSequences[0][0]];
        tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
        expectedTokens.append(tokenValue);
        for(int tokenId = 1; tokenId < e.expectedTokenSequences.length;tokenId++) {
                tokenValue = tokenImage[e.expectedTokenSequences[tokenId][0]];
                tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
                expectedTokens.append(", ")
                        .append(tokenValue);
        }
        System.err.println(expectedTokens.toString());
    } catch(TokenMgrError e) {
        String message = e.getMessage();
                int startIndex = message.indexOf("line ") + 5;
                int endIndex = message.indexOf(",");
                String lineNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("column ") + 7;
                endIndex = message.indexOf(".");
                String columnNo = message.substring(startIndex, endIndex).trim();

                startIndex = message.indexOf("\"") + 1;
                endIndex = message.indexOf("\"",startIndex);
                String keyword = message.substring(startIndex, endIndex).trim();

                System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
    }
    catch(CompilationException e) {
        System.err.println(e.getMessage());
    }
  }

/**
 * processPointer(pointer, dataType)
 * 
 * Takes the data-type and return the pointer type symbol generated
 * 
 */
 private static PointerType processPointer(PointerType pointer, String dataType, boolean valueMutableStatus) throws CompilationException {
         String pointerType= null;
         HashMap<String, String> attributes = new HashMap<String, String>();
         try {
                // If this is a single pointer i.e. int * or char *, then set reference type of 
                // pointer as 'int' or 'char', whatever is applicable.
                if(pointer == null) {
                        pointer = (PointerType)SymbolMachine.generate(Constants.BLANK, Constants.POINTER, valueMutableStatus);
                        pointer.setReferenceType(dataType);
                        pointer.setPointee(SymbolMachine.generate(Constants.BLANK,dataType, valueMutableStatus));
                }
                // If this is a multiple pointer i.e. int ** or char **, then set reference type of 
                // pointer as that of previously read pointer type i.e. 'int*' or 'char*', whatever is applicable.
                else {
                        // Get the previous pointerType 
                        pointerType = pointer.getName();
                        pointer = (PointerType)SymbolMachine.generate(Constants.BLANK, pointerType, valueMutableStatus);
                        pointer.setReferenceType(pointerType);
                        pointer.setPointee(SymbolMachine.generate(Constants.BLANK,pointerType, valueMutableStatus));
                }

                // Set the pointer name as data-type. This will let us reuse the already defined pointer-type
                // instead of redefining the pointer-type in furture variable declaration.
                try {
                        pointer.setName(DataTypeFinder.getDataType(pointer));
                } catch(SymbolNotDefinedException e ) {}

                // Create the 'pointer-type' element only if it's not already defined
                if(!Environment.currentActivationRecord.isSymbolPresent(pointer.getName()) &&
                                !Environment.isSymbolPresentInGlobalScope(pointer.getName())) {
                        // Set the attributes of pointer-type
                        attributes.put(Constants.NAME,pointer.getName());
                        attributes.put(Constants.REF_TYPE, pointerType == null? dataType : pointerType);
                        currentNode.appendChild(UXMLElementFactory.generateElement(Constants.POINTER_TYPE,attributes,pointer));
                        // Add the pointer-type in symbol table
                        // If this is a global variable declaration, then add in global symbol table
                        if(globalVariableDeclaration)
                                Environment.addGlobalSymbol(pointer);
                        else
                                Environment.currentActivationRecord.addSymbol(pointer);
                }
                return pointer;
         } catch(Exception e) {
                 throw new CompilationException(e.getMessage());
         }
 }

// Define the proto-types of constructs that will be used in rules
  final public String DataType() throws ParseException, CompilationException {
        Token t = null;
        String funcPtrReturnType = null;
        Symbol functionPointer;
        UXMLElement functionPointerElement = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
    case FLOAT:
    case CHAR:
    case BOOL:
    case STRUCT:
    case VOID:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
        break;
      case CHAR:
        t = jj_consume_token(CHAR);
        break;
      case BOOL:
        t = jj_consume_token(BOOL);
        break;
      case STRUCT:
        t = jj_consume_token(STRUCT);
        break;
      case VOID:
        t = jj_consume_token(VOID);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                {if (true) return t.image;}
      break;
    case FUNC_PTR:
      jj_consume_token(FUNC_PTR);
      functionPointerElement = FunctionPointer();
                functionPointer = functionPointerElement.getSymbol();
                // Change return-type to function signature 
                funcPtrReturnType = functionPointer.getName();

                if(!Environment.currentActivationRecord.isSymbolPresent(funcPtrReturnType) &&
                                !Environment.isSymbolPresentInGlobalScope(funcPtrReturnType)) {
                         // Specify if the function type is already defined or not
                        // If already defined, then use the same function-type name while defining pointer-type
                        // else declare the function-type element before declaring the pointer-type
                        currentNode.appendChild(functionPointerElement);
                        if(globalVariableDeclaration)
                                Environment.addGlobalSymbol(functionPointer);
                        else
                                Environment.currentActivationRecord.addSymbol(functionPointer);
                }
                {if (true) return funcPtrReturnType;}
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Symbol Constant() throws ParseException, CompilationException {
                                                 Token t = null;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT_CONSTANT:
        t = jj_consume_token(INT_CONSTANT);
                                        {if (true) return new ConstantValue(Constants.INT,t.image);}
        break;
      case FLOAT_CONSTANT:
        t = jj_consume_token(FLOAT_CONSTANT);
                                           {if (true) return new ConstantValue(Constants.FLOAT,t.image);}
        break;
      case CHAR_CONSTANT:
        t = jj_consume_token(CHAR_CONSTANT);
                        String ch = t.image.substring(1,2);
                        {if (true) return new ConstantValue(Constants.CHAR,ch);}
        break;
      case STRING_CONSTANT:
        t = jj_consume_token(STRING_CONSTANT);
                        String str = t.image;
                        str = str.substring(1, str.length() - 1);
                        {if (true) return new ConstantValue(Constants.STRING,str);}
        break;
      case BOOL_CONSTANT:
        t = jj_consume_token(BOOL_CONSTANT);
                                         {if (true) return new ConstantValue(Constants.BOOLEAN,t.image);}
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Variable access - Also used for address of/value of feature
 *  (& | (*)+)? ID ( [ INT_CONSTANT ] )*
 *  
 *  isFunctionName specifies whether this is a function call or normal expression
 */
  final public UXMLElement Variable(boolean isFunctionName) throws ParseException, CompilationException {
        Token t = null;
        Symbol variableSymbol = null, argumentSymbol = null;
        FunctionType functionSymbol = null;
        String operatorName = null, functionName = null, variableName = null;
        UXMLElement parentNode = currentNode, innerMostPointer = null, multiPointer = null, pointer = null,
        variableSymbolElement = null,call = null,argumentElement = null, arrayElementNode = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
        int valueOfCount = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
    case AMPERSAND:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
        jj_consume_token(AMPERSAND);
                     operatorName = "@";
        break;
      case ASTERISK:
        label_1:
        while (true) {
          jj_consume_token(ASTERISK);
                        operatorName = "#";
                        attributes.clear();
                        attributes.put(Constants.VALUE, operatorName);
                        valueOfCount++;
                        if(multiPointer == null) {
                                // TODO: Swap the name of multiPointer and innerMostPointer
                                multiPointer = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
                                // Need to save the inner most pointer, because variable is going to be the child element of inner most 
                                // pointer
                                innerMostPointer = multiPointer;
                        } else
                                multiPointer = multiPointer.appendChild(UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null));
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASTERISK:
            ;
            break;
          default:
            jj_la1[3] = jj_gen;
            break label_1;
          }
        }
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    t = jj_consume_token(ID);
                try {
                variableName = t.image;
                variableSymbol = Environment.getSymbol(variableName);
                attributes.clear();
                attributes.put(Constants.NAME, variableSymbol.getName());
                variableSymbolElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol);
                } catch(SymbolNotDefinedException e) {{if (true) throw new CompilationException(e.getMessage());}}
    variableSymbolElement = ArrayAccess(variableSymbolElement);
                variableSymbol = variableSymbolElement.getSymbol();
                try {

                        // If this is pointer operation
                        if(operatorName != null) {
                                attributes = new HashMap<String, String>();
                                attributes.put(Constants.VALUE, operatorName);
                                operands.add(variableSymbol);
                                pointer = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));

                                // If this is valueOf operator, then append the variable to pointer variable
                                if(innerMostPointer != null) {
                                        Symbol valueOfPointer = pointer.getSymbol();
                                        // Apply * operation multiple times to get the final value 
                                        while(valueOfCount != 1) {
                                                operands.clear();
                                                operands.add(valueOfPointer);
                                                valueOfPointer = Operator.execute(operatorName, operands);
                                                valueOfCount--;
                                        }

                                        // Append the variable to the inner most pointer node
                                        multiPointer.appendChild(variableSymbolElement);
                                        if(!isFunctionName)
                                                currentNode.appendChild(innerMostPointer);
                                        // return the symbol after executing pointer operation
                                        innerMostPointer.setSymbol(valueOfPointer);
                                        variableSymbolElement = innerMostPointer;
                                }
                                else {
                                        pointer.appendChild(variableSymbolElement);
                                        if(!isFunctionName)
                                                currentNode.appendChild(pointer);
                                        // return the symbol after executing pointer operation
                                        variableSymbolElement = pointer;
                                }
                        }
                        {if (true) return variableSymbolElement;}
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(OperatorNotFoundException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
    throw new Error("Missing return statement in function");
  }

// Rules start
  final public void CLike() throws ParseException, CompilationException {
    Program();
  }

/**
 * Program
 */
  final public void Program() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, functionNode = null, block = null, callToMain = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
                globalVariableDeclaration = true;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
      case INT:
      case FLOAT:
      case CHAR:
      case BOOL:
      case STRUCT:
      case VOID:
      case FUNC_PTR:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_2;
      }
      VarDeclaration();
    }
                globalVariableDeclaration = false;
    label_3:
    while (true) {
      FunctionDefinition();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FUNCTION:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
    }
                callToMain = UXMLElementFactory.generateElement(Constants.CALL, null, null);
                attributes.put(Constants.NAME, "main");
                callToMain.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
                block.appendChild(callToMain);
                // Restore the current Node
                currentNode = parentNode;
  }

/**
 * {
 *  ...statements...
 * }
 */
  final public void CodeBlock() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, block = null;
    ScopeStart();
                block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                currentNode = block;
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
      case INT:
      case FLOAT:
      case CHAR:
      case BOOL:
      case STRUCT:
      case VOID:
      case FUNC_PTR:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
      VarDeclaration();
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
      case AMPERSAND:
      case IF:
      case DO:
      case WHILE:
      case FOR:
      case CALL:
      case PRINT:
      case PRINTLN:
      case RETURN:
      case STMT_TERMINATOR:
      case ID:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      Statement();
    }
    ScopeEnd();
                // Restore the 
                currentNode = parentNode;
  }

/**
 * Scope start
 * {
 */
  final public void ScopeStart() throws ParseException {
    jj_consume_token(BLOCK_START);
                Environment.currentActivationRecord.enterTheBlock();
  }

/**
 * Scope end
 * }
 */
  final public void ScopeEnd() throws ParseException {
    jj_consume_token(BLOCK_END);
                Environment.currentActivationRecord.leaveTheBlock();
  }

/**
 * Statements
 * Variable declaration, assignment, if, for
 */
  final public void Statement() throws ParseException, CompilationException {
                                                UXMLElement funcCall = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
    case AMPERSAND:
    case ID:
      Assignment();
      break;
    case IF:
      If();
      break;
    case FOR:
      For();
      break;
    case DO:
      DO_WHILE();
      break;
    case WHILE:
      WHILE_DO();
      break;
    case PRINT:
    case PRINTLN:
      Print();
      break;
    case CALL:
      funcCall = FunctionCall();
      jj_consume_token(STMT_TERMINATOR);
                                                                                                                        currentNode.appendChild(funcCall);
      break;
    case RETURN:
      Return();
      break;
    case STMT_TERMINATOR:
      jj_consume_token(STMT_TERMINATOR);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

/**
 * Function 
 * function returnType ([int_constant])? (*)* functionName ( ((const)? dataType (*)* variableName (, (const)? dataType (*)* variableName)* )? )
 * 	CodeBlock()
 * 
 */
  final public void FunctionDefinition() throws ParseException, CompilationException {
        Token t = null;
        String  paramType = null, paramName = null, functionName = null;
        UXMLElement parentNode = currentNode, functionNode = null, savedCurrentNode = null, arrayElement = null;
        PointerType pointer = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> formalParams = new ArrayList<Symbol>();
        Symbol paramSymbol = null;
        FunctionType functionType = null;
        boolean mutable = true, ptrMutable = true;
    try {
      jj_consume_token(FUNCTION);
      currentReturnType = DataType();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASTERISK:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
        jj_consume_token(ASTERISK);
                pointer = processPointer(pointer, currentReturnType, true);
      }
      arrayElement = CreateArray(Constants.BLANK,pointer == null?SymbolMachine.generate(Constants.BLANK, currentReturnType, true) : pointer ,true);
                currentReturnType = arrayElement.getSymbol().getType();
      t = jj_consume_token(ID);
                functionName = t.image;
                // Make the function as non-mutable
                currentFunction = new FunctionType(functionName, false, currentReturnType);
                currentFunction.setReturnValue(arrayElement.getSymbol());
                // Nested level of function will be '0' since nested functions are not allowed in Clike
                currentFunction.setNestedLevel(0);
                attributes.put(Constants.NAME, functionName);
                functionNode = UXMLElementFactory.generateElement(Constants.FUNCTION, attributes,currentFunction );
                currentNode.appendChild(functionNode);
                currentNode = functionNode;

                // Execute the calling sequence of a caller - 
                // Nested level of function will be '0' since nested functions are not allowed in Clike
        Environment.callSequenceProcessor.callAction_caller(0);
        // There may be the case that arguments to the function are function-pointers or like that which
        // are needed to add in symbol table, for that the method call 'enterTheBlock()' is necessary so that
        // symbol table will be created.
        Environment.currentActivationRecord.enterTheBlock();
      jj_consume_token(ROUND_START);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
        jj_consume_token(CONST);
                         mutable = false; pointer = null;
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case FLOAT:
      case CHAR:
      case BOOL:
      case STRUCT:
      case VOID:
      case FUNC_PTR:
        paramType = DataType();
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASTERISK:
            ;
            break;
          default:
            jj_la1[13] = jj_gen;
            break label_7;
          }
          jj_consume_token(ASTERISK);
                     pointer = processPointer(pointer, paramType, mutable);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST:
          jj_consume_token(CONST);
                  ptrMutable = false;
          break;
        default:
          jj_la1[14] = jj_gen;
          ;
        }
                if(pointer != null) {
                        /*try {
				paramType = DataTypeFinder.getDataType(pointer);
			} catch(SymbolNotDefinedException e) {}*/
                        paramType = pointer.getName();
                        pointer.setMutableStatus(ptrMutable);
                }
        t = jj_consume_token(ID);
                paramName = t.image;
                // Create automatic-Var and append all the parameters to it
                savedCurrentNode = currentNode;
                currentNode = currentNode.appendChild(UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null));
                paramSymbol = SymbolMachine.generate(paramName, paramType, mutable);


                /* added - start */

                // Set the pointer type, else 'pointer' will be saved
                  if(pointer != null) {
                          paramSymbol.setType(paramType);
                  }
        arrayElement = CreateArray(paramName, paramSymbol, mutable);
                  paramSymbol = arrayElement.getSymbol();

                  // Set the name of the variable
                  paramSymbol.setName(paramName);

                  /* added - end */

                  currentFunction.addSymbol(paramSymbol);
                  attributes.clear();

                  attributes.put(Constants.NAME, paramName);
                  attributes.put(Constants.TYPE, paramSymbol.getType());

                  // If this is a pointer
                  if(pointer == null || ( paramSymbol != null && paramSymbol instanceof ArrayType)
                                  /*Constants.ARRAY_TYPE.equals(arrayElement.getElementName())*/)
                          attributes.put(Constants.MUTABLE, mutable? "yes" : "no" );
                  else {
                          attributes.put(Constants.PTR_MUTABLE, ptrMutable? "yes" : "no");
                          attributes.put(Constants.VALUE_MUTABLE, mutable? "yes" : "no" ); // hence value is set depending on mutable status.  
                  }
                  currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[15] = jj_gen;
            break label_8;
          }
          jj_consume_token(COMMA);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CONST:
            jj_consume_token(CONST);
                                 mutable = false; pointer = null;
            break;
          default:
            jj_la1[16] = jj_gen;
            ;
          }
          paramType = DataType();
          label_9:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case ASTERISK:
              ;
              break;
            default:
              jj_la1[17] = jj_gen;
              break label_9;
            }
            jj_consume_token(ASTERISK);
                     pointer = processPointer(pointer, paramType, mutable);
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CONST:
            jj_consume_token(CONST);
                  ptrMutable = false;
            break;
          default:
            jj_la1[18] = jj_gen;
            ;
          }
                if(pointer != null) {
                        paramType = pointer.getName();
                        pointer.setMutableStatus(ptrMutable);
                }
          t = jj_consume_token(ID);
                paramName = t.image;
                paramSymbol = SymbolMachine.generate(paramName, paramType, mutable);

                /* added - start */

                // Set the pointer type, else 'pointer' will be saved
                if(pointer != null) {
                        paramSymbol.setType(paramType);
                }
          arrayElement = CreateArray(paramName, paramSymbol, mutable);
                paramSymbol = arrayElement.getSymbol();

                // Set the name of the variable
                paramSymbol.setName(paramName);

                /* added - end */

                currentFunction.addSymbol(paramSymbol);

                attributes.clear();

                attributes.put(Constants.NAME, paramName);
                attributes.put(Constants.TYPE, paramSymbol.getType());

                // If this is a pointer
                 if(pointer == null || ( paramSymbol != null && paramSymbol instanceof ArrayType)
                                  /*Constants.ARRAY_TYPE.equals(arrayElement.getElementName())*/)
                          attributes.put(Constants.MUTABLE, mutable? "yes" : "no" );
                  else {
                          attributes.put(Constants.PTR_MUTABLE, ptrMutable? "yes" : "no");
                          attributes.put(Constants.VALUE_MUTABLE, mutable? "yes" : "no" ); // hence value is set depending on mutable status.  
                  }
                 currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
        }
                // Restore the currentNode
                // If savedCurrentNode is null, it means that there were no parameters to the function
                // and there is no need to restore the currentNode
                if(savedCurrentNode != null)
                        currentNode = savedCurrentNode;
        break;
      default:
        jj_la1[19] = jj_gen;
        ;
      }
                attributes.clear();
                attributes.put(Constants.TYPE, currentReturnType);
                // Append the return type
                currentNode.appendChild(UXMLElementFactory.generateElement(Constants.RETURNS, attributes, null));

                // Save the function in global symbol table
                Environment.addGlobalSymbol(currentFunction);
      jj_consume_token(ROUND_END);
      jj_consume_token(BLOCK_START);
                // Copy the formal params in current symbol table
                for(Symbol formalArg : currentFunction.getFormalParameters())
                        Environment.currentActivationRecord.addSymbol(formalArg);

                UXMLElement block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
                currentNode.appendChild(block);
                savedCurrentNode = currentNode;
                currentNode = block;
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST:
        case INT:
        case FLOAT:
        case CHAR:
        case BOOL:
        case STRUCT:
        case VOID:
        case FUNC_PTR:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_10;
        }
        VarDeclaration();
      }
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASTERISK:
        case AMPERSAND:
        case IF:
        case DO:
        case WHILE:
        case FOR:
        case CALL:
        case PRINT:
        case PRINTLN:
        case RETURN:
        case STMT_TERMINATOR:
        case ID:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_11;
        }
        Statement();
      }
      ScopeEnd();
                // If function is defined to return a value and return statement is not present in function definition
                // or if function is defined to return void and if return statement is present 
                // then throw error  
                if(!Constants.VOID.equals(currentFunction.getReturnType()) && !isReturnStmtPresent)
                        {if (true) throw new CompilationException("'" + currentFunction.getName() + "' should return a value of type '"
                                        + currentFunction.getReturnType() + "'.");}
                else if(Constants.VOID.equals(currentFunction.getReturnType())&& isReturnStmtPresent )
                        {if (true) throw new CompilationException("'" + currentFunction.getName() + "' declared as 'void' should not return a value.");}
                else
                        isReturnStmtPresent = false;
                // Restore the currentNode 
                currentNode = parentNode;
                // Function done
                Environment.callSequenceProcessor.returnAction_caller();

                // Save the function in global symbol table
//		Environment.addGlobalSymbol(currentFunction);

    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
  }

/**
 * Return statement
 * 
 * return expression() ;
 */
  final public void Return() throws ParseException, CompilationException {
        UXMLElement returnExpression = null, returnElement = null;
        String requiredReturnType = null, foundReturnType = null;
        Symbol returnSymbol = null;
    jj_consume_token(RETURN);
    returnExpression = Expression();
                returnElement = UXMLElementFactory.generateElement(Constants.RETURN, null, null);
                returnSymbol = returnExpression.getSymbol();
                returnSymbol = (returnSymbol instanceof FunctionType)? ((FunctionType)returnSymbol).getReturnValue():returnSymbol;
                returnElement.appendChild(returnExpression);
                currentNode.appendChild(returnElement);

                // Try to set the return symbol into the return value of currentfunction. 
                // If the return-type is not compatible then error will be thrown
                try {
                        requiredReturnType = DataTypeFinder.getDataType(currentFunction.getReturnValue());
                        foundReturnType = DataTypeFinder.getDataType(returnSymbol);
                        if(requiredReturnType.equals(foundReturnType)) {
                                Symbol returnValue = currentFunction.getReturnValue();
                                if(returnValue instanceof ArrayType)
                                        ((ArrayType) returnValue).copyArray(returnSymbol);
                        }
                        else
                                {if (true) throw new TypeMismatchException(foundReturnType,requiredReturnType);}
                        isReturnStmtPresent = true;
                  } catch(TypeMismatchException e) {
                          {if (true) throw new CompilationException("Function '" + currentFunction.getName()
                                          + "' should return '" + requiredReturnType + "' and not '"  + foundReturnType + "'.",e.getMessage());}
                  } catch(SymbolNotDefinedException e) {System.err.println(e.getMessage());}
    jj_consume_token(STMT_TERMINATOR);
  }

/**
 * Function pointer
 * defined_functionType | ( datatype() ( (datatype() (, datatype())*)? ))
 * 
 * eg. funcptr fun1 (int (float, float)) // Define the type 
 *     funcptr fun1 sample;  // Declare function pointer 'sample' of type 'fun1'
 * 
 */
  final public UXMLElement FunctionPointer() throws ParseException, CompilationException {
        Token t = null;
        String returnType = null, functionName = null, functionPtrType = null, paramType = null, functionPtrName = null, operatorName = null,
        functionPtrVarName = null, newVariableName = null;
        int valueOfCount = 0;
        boolean mutable = true;
        Symbol paramSymbol = null, functionPointer = null, variableSymbol = null;
        FunctionType functionType = null;
        UXMLElement functionTypeElement = null, automaticVarElement = null, returnElement = null, functionPtrElement = null,
        arrayElement = null;
        PointerType pointer = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
      case ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST:
          jj_consume_token(CONST);
                                  mutable = false;
          break;
        default:
          jj_la1[22] = jj_gen;
          ;
        }
        // Function pointer name
                                t = jj_consume_token(ID);
                                functionPtrName = t.image;
                                functionPointer = Environment.getSymbol(functionPtrName);
                                {if (true) return new UXMLElement(null, functionPointer);}
        break;
      case ROUND_START:
        jj_consume_token(ROUND_START);
        returnType = DataType();
                        functionType = new FunctionType(Constants.BLANK, false, returnType);
                        attributes.clear();
                        attributes.put(Constants.TYPE, returnType);
                        // Append the return type
                        returnElement = UXMLElementFactory.generateElement(Constants.RETURNS, attributes, null);
        jj_consume_token(ROUND_START);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case FLOAT:
        case CHAR:
        case BOOL:
        case STRUCT:
        case VOID:
        case FUNC_PTR:
          paramType = DataType();
                        automaticVarElement = UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null);
                        paramSymbol = SymbolMachine.generate(Constants.BLANK, paramType, false);
                        automaticVarElement.appendChild(new UXMLElement(null, paramSymbol));
                        functionType.addSymbol(paramSymbol);
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[23] = jj_gen;
              break label_12;
            }
            jj_consume_token(COMMA);
            paramType = DataType();
                        paramSymbol = SymbolMachine.generate(Constants.BLANK, paramType, false);
                        automaticVarElement.appendChild(new UXMLElement(null, paramSymbol));
                        functionType.addSymbol(paramSymbol);
          }
          break;
        default:
          jj_la1[24] = jj_gen;
          ;
        }
        jj_consume_token(ROUND_END);
        jj_consume_token(ROUND_END);
                        // Set the name as signature of the function
                        functionName = functionType.getSignature();
                        functionType.setName(functionName);
                        // Set the attributes of function-type
                        attributes.clear();
                        attributes.put(Constants.NAME, functionName);
                        functionTypeElement = UXMLElementFactory.generateElement(Constants.FUNCTION_TYPE, attributes, functionType);
                        if(automaticVarElement != null)
                                functionTypeElement.appendChild(automaticVarElement);
                        functionTypeElement.appendChild(returnElement);
                        {if (true) return functionTypeElement;}
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    } catch (SymbolNotDefinedException e) {
        {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Function call
 * In case there are no arguments to the function, user need to specify 'void' 
 * eg. call_func(void) 
 * CALL Variable() ((expression (, expression)*)?)
 */
  final public UXMLElement FunctionCall() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement argumentElement = null, call = null, function = null;
        String functionName = null;
        Symbol argumentSymbol = null, functionType = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
        FunctionType functionSymbol = null;
    jj_consume_token(CALL);
    //	t = <ID>
            function = Variable(true);
                functionType = function.getSymbol();
                functionName = functionType.getName();
                call = UXMLElementFactory.generateElement(Constants.CALL, null, null);
                attributes.clear();
                if(!(Constants.OPERATOR.equals(function.getElementName()) &&
                                                Constants.VALUE_OF.equals(function.getAttributeValue(Constants.VALUE))))
                {

                        attributes.put(Constants.NAME, functionName);
                        call.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,functionType));
                } else {
                        call.appendChild(function);
                }
    jj_consume_token(ROUND_START);
    argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                // Check if expression is void and if yes, then no-argument function call is made
                if(!Constants.VOID.equals(argumentSymbol.getType())) {
                        actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                        call.appendChild(argumentElement);
                }
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_13;
      }
      jj_consume_token(COMMA);
      argumentElement = Expression();
                argumentSymbol = argumentElement.getSymbol();
                actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
                call.appendChild(argumentElement);
    }
    jj_consume_token(ROUND_END);
                try {
                        // If the function is called using function pointer, then name could be blank
                        if(!Constants.BLANK.equals(functionName)) {
                                argumentSymbol = Environment.getSymbol(functionName);

                                if(!(argumentSymbol instanceof OverloadedFunctionType))
                                        {if (true) throw new CompilationException("Type mismatch \n Found    : '" + functionName + DataTypeFinder.getDataType(argumentSymbol) + "' \n Required : '" + functionName + "'");}
                                // Get the function
                                functionSymbol = ((OverloadedFunctionType) argumentSymbol).getFunction(actualArgs);
                        }
                        // in that case, simply set the return type as that of function just obtained.
                        else {
                                functionSymbol = (FunctionType)functionType;
                        }
                } catch (SymbolNotDefinedException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                call.setSymbol(functionSymbol);
                {if (true) return call;}
    throw new Error("Missing return statement in function");
  }

/** 
 * Variable Declaration
 * (const)? datatype() (*)* ID ([INT_CONSTANT])* ( = value )? (, (*)* ID (= value)?)* ;
 */
  final public void VarDeclaration() throws ParseException, CompilationException {
        Token t = null;
        String pointerType = null, dataType = null, newVariableName = null;
        Symbol variableSymbol = null, variableValueSymbol = null, baseDataType = null;
        UXMLElement savedCurrentNode = currentNode, parentNode = currentNode,variableValueElement = null, arrayElement = null;
        boolean mutable = true, ptrMutable = true;
        PointerType pointer = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
        jj_consume_token(CONST);
                         mutable = false;
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      dataType = DataType();
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASTERISK:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_14;
        }
        jj_consume_token(ASTERISK);
                        pointer = processPointer(pointer, dataType, mutable);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONST:
        jj_consume_token(CONST);
                    ptrMutable = false;
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
      t = jj_consume_token(ID);
                  newVariableName = t.image;
                  variableSymbol = SymbolMachine.generate(Constants.BLANK, pointer != null? pointer.getName() : dataType, mutable);

                  // Set the pointer type, else 'pointer' will be saved
                  if(pointer != null) {
                          variableSymbol.setType(pointer.getName());
                          pointer.setMutableStatus(ptrMutable);
                  }
      arrayElement = CreateArray(newVariableName, variableSymbol, mutable);
                  variableSymbol = arrayElement.getSymbol();

                  // Set the name of the variable
                  variableSymbol.setName(newVariableName);
                  attributes.clear();

                  attributes.put(Constants.NAME, newVariableName);
                  attributes.put(Constants.TYPE, variableSymbol.getType());

                  // If this is a pointer
                  if(pointer == null ||( variableSymbol != null && variableSymbol instanceof ArrayType)
                                  /*Constants.ARRAY_TYPE.equals(arrayElement.getElementName())*/)
                          attributes.put(Constants.MUTABLE, mutable? "yes" : "no" );
                  else {
                          attributes.put(Constants.PTR_MUTABLE, ptrMutable? "yes" : "no");
                          attributes.put(Constants.VALUE_MUTABLE, mutable? "yes" : "no" ); // hence value is set depending on mutable status.  
                  }

                  // Since assignment could be there, hence save the current node
                  savedCurrentNode = currentNode;
                  currentNode = currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, variableSymbol));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        variableValueElement = Expression();
                  variableValueSymbol = variableValueElement.getSymbol();
                  // Make it mutable so that initial value can be stored
                  variableSymbol.setMutableStatus(true);
                  variableSymbol.setValue(variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol);
                  currentNode.appendChild(variableValueElement);
                  // Set it back to the mutable status as defined in source program
                  // If this is an instanceof pointertype, then set the ptrMutable
                  variableSymbol.setMutableStatus(variableSymbol instanceof PointerType? ptrMutable : mutable);
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
                  currentNode = savedCurrentNode;
                  // Store the variable in symbol table
                        // If this is a global variable declaration, then add in global symbol table
                        if(globalVariableDeclaration)
                                Environment.addGlobalSymbol(variableSymbol);
                        else
                                Environment.currentActivationRecord.addSymbol(variableSymbol);
      label_15:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_15;
        }
        jj_consume_token(COMMA);
                // Reset the pointer to null
                pointer = null;
                attributes = new HashMap<String,String>();
                currentNode = savedCurrentNode;
                pointerType = null;
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASTERISK:
            ;
            break;
          default:
            jj_la1[32] = jj_gen;
            break label_16;
          }
          jj_consume_token(ASTERISK);
                        pointer = processPointer(pointer, dataType, mutable);
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONST:
          jj_consume_token(CONST);
                   ptrMutable = false;
          break;
        default:
          jj_la1[33] = jj_gen;
          ;
        }
        t = jj_consume_token(ID);
                  newVariableName = t.image;
                  variableSymbol = SymbolMachine.generate(Constants.BLANK, pointer != null? pointer.getName() : dataType, mutable);

                  // Set the pointer type, else 'pointer' will be saved
                  if(pointer != null) {
                          variableSymbol.setType(pointer.getName());
                          pointer.setMutableStatus(ptrMutable);
                  }
        arrayElement = CreateArray(newVariableName, variableSymbol, mutable);
                  variableSymbol = arrayElement.getSymbol();

                  // Set the name of the variable
                  variableSymbol.setName(newVariableName);
                  attributes.clear();

                  attributes.put(Constants.NAME, newVariableName);
                  attributes.put(Constants.TYPE, variableSymbol.getType());

                  // If this is a pointer
                  if(pointer == null || ( variableSymbol != null && variableSymbol instanceof ArrayType)
                                  /*Constants.ARRAY_TYPE.equals(arrayElement.getElementName())*/)
                          attributes.put(Constants.MUTABLE, mutable? "yes" : "no" );
                  else {
                          attributes.put(Constants.PTR_MUTABLE, ptrMutable? "yes" : "no");
                          attributes.put(Constants.VALUE_MUTABLE, mutable? "yes" : "no" ); // hence value is set depending on mutable status.  
                  }

                 // Since assignment could be there, hence save the current node
                 savedCurrentNode = currentNode;
                 currentNode = currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, variableSymbol));
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGN:
          jj_consume_token(ASSIGN);
          variableValueElement = Expression();
                variableValueSymbol = variableValueElement.getSymbol();

                  // Make it mutable so that initial value can be stored
                  variableSymbol.setMutableStatus(true);
                  variableSymbol.setValue(variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol);
                  currentNode.appendChild(variableValueElement);
                  // Set it back to the mutable status as defined in source program
                  variableSymbol.setMutableStatus(mutable);
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
                currentNode = savedCurrentNode;
                // Store the variable in symbol table
                // If this is a global variable declaration, then add in global symbol table
                if(globalVariableDeclaration)
                        Environment.addGlobalSymbol(variableSymbol);
                else
                        Environment.currentActivationRecord.addSymbol(variableSymbol);
      }
      jj_consume_token(STMT_TERMINATOR);
                // Restore the node
                currentNode = parentNode;
    } catch (IllegalSymbolValueException e) {
          {if (true) throw new CompilationException(e.getMessage());}
    } catch (ImmutableSymbolException e) {
          {if (true) throw new CompilationException(e.getMessage());}
    } catch (TypeMismatchException e) {
          {if (true) throw new CompilationException(e.getMessage());}
    }
  }

/**
 * Returns the array definition
 * ( [ INT_CONSTANT ] )*
 */
  final public UXMLElement CreateArray(String variableName, Symbol baseElement, boolean mutable) throws ParseException, CompilationException {
        Token t = null;
        ArrayList<ArrayType> arrayDimProcessor = new ArrayList<ArrayType>();
        ArrayType arrayElement = null;
        int dimSize;
        HashMap<String, String> attributes = new HashMap<String, String>();
        UXMLElement arrayNodeElement = null, dimElement = null;
        StringBuffer dimType = new StringBuffer();
                attributes.put(Constants.NAME, variableName );
                attributes.put(Constants.TYPE, baseElement.getType());
                arrayNodeElement = UXMLElementFactory.generateElement(Constants.ARRAY_TYPE, attributes, null);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SQUARE_START:
        ;
        break;
      default:
        jj_la1[35] = jj_gen;
        break label_17;
      }
      jj_consume_token(SQUARE_START);
      t = jj_consume_token(INT_CONSTANT);
                dimSize = Integer.parseInt(t.image);
                dimType.append(t.image);
                try {
                        arrayElement = (ArrayType)SymbolMachine.generate(Constants.BLANK, Constants.ARRAY, true);
                } catch(IllegalSymbolValueException e) {} // Exception won't come since we are passing ARRAY

                attributes.clear();
                attributes.put(Constants.SIZE, String.valueOf(dimSize));
                dimElement = UXMLElementFactory.generateElement(Constants.DIM, attributes, null);
                arrayNodeElement.appendChild(dimElement);
                arrayElement.setSize(dimSize);
                arrayDimProcessor.add(arrayElement);
      jj_consume_token(SQUARE_END);
    }
                try {
                        for(int dim = arrayDimProcessor.size() - 1; dim >= 0; dim--) {
                                arrayElement = arrayDimProcessor.get(dim);
                                arrayElement.setValue(baseElement);
                                arrayElement.setMutableStatus(mutable);
                                baseElement = arrayElement;
                        }

                        // If there was an array declaration, then add the array in symtab
                        if(arrayDimProcessor.size() > 0) {
                                String arrayType = DataTypeFinder.getDataType(baseElement)+ dimType.toString();
                                baseElement.setType(arrayType);
                                baseElement.setName(arrayType);
                                // Change the name of array to arrayType
                                arrayNodeElement.setAttributeValue(Constants.NAME, arrayType );

                                // Add the array-type in  symbol table
                                if(!Environment.currentActivationRecord.isSymbolPresent(arrayType) &&
                                                        !Environment.isSymbolPresentInGlobalScope(arrayType)) {
                                        currentNode.appendChild(arrayNodeElement);

                                        // If this is the first time occurance of aray-type then change the type to ARRAY
                                        baseElement.setType(Constants.ARRAY);
                                        // Add the array-type in symbol table
                                        // If this is a global variable declaration, then add in global symbol table
                                        if(globalVariableDeclaration)
                                                Environment.addGlobalSymbol(baseElement);
                                        else
                                                Environment.currentActivationRecord.addSymbol(baseElement);

                                        baseElement = Clone.deepCopySymbol(baseElement);

                                        // Since we changed the type to Array, revert it back to the array-type
                                        baseElement.setType(arrayType);
                                }
                        }
                        arrayNodeElement.setSymbol(baseElement);
                        {if (true) return arrayNodeElement;}
                } catch(ImmutableSymbolException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(TypeMismatchException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(SymbolNotDefinedException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
    throw new Error("Missing return statement in function");
  }

/**
 * Array Access
 *  ([ Expression() ])* 
 */
  final public UXMLElement ArrayAccess(UXMLElement variableElement) throws ParseException, CompilationException {
        Token t = null;
        int index = 0;
        HashMap<String, String> attributes = new HashMap<String, String> ();
        attributes.put(Constants.VALUE, "[]");
        UXMLElement operator = null,
        indexElement = null,returnElement = operator;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        Symbol arrayElementAtIndex = null;
    try {
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SQUARE_START:
          ;
          break;
        default:
          jj_la1[36] = jj_gen;
          break label_18;
        }
        jj_consume_token(SQUARE_START);
        indexElement = Expression();
                        operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
                        operator.appendChild(variableElement);
                        operator.appendChild(indexElement);
                        operands.clear();
                        operands.add(variableElement.getSymbol());
                        operands.add(indexElement.getSymbol());
                        arrayElementAtIndex = Operator.execute("[]", operands);
                        operator.setSymbol(arrayElementAtIndex);
                        variableElement = operator;
        jj_consume_token(SQUARE_END);
      }
                        {if (true) return variableElement;}
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    } catch (OperatorNotFoundException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Assignment statement
 */
  final public void Assignment() throws ParseException, CompilationException {
        UXMLElement parentNode = null;
        Symbol variableSymbol = null, variableValueSymbol = null;
        UXMLElement variableSymbolElement = null, variableValueElement = null, assignment = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
    variableSymbolElement = Variable(false);
    jj_consume_token(ASSIGN);
    variableValueElement = Expression();
                variableSymbol = variableSymbolElement.getSymbol();
                variableValueSymbol = variableValueElement.getSymbol();
                variableValueSymbol = variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol;
                try {
                        // Check if the data-type of pointers are same or not
                        if(variableSymbol.getDataType() == DATA_TYPE.POINTER) {
                                String lhsPtrType = DataTypeFinder.getDataType(variableSymbol);
                                String rhsPtrType = DataTypeFinder.getDataType(variableValueSymbol);
                                if(!lhsPtrType.equals(rhsPtrType))
                                        {if (true) throw new CompilationException(new TypeMismatchException(rhsPtrType,lhsPtrType).getMessage());}
                        }
                        if(variableSymbol instanceof ArrayType)
                                ((ArrayType)variableSymbol).copyArray(variableValueSymbol);
                        else
                                variableSymbol.setValue(variableValueSymbol);

                } catch(ImmutableSymbolException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
        } catch(TypeMismatchException e) {
                {if (true) throw new CompilationException(e.getMessage());}
        } catch(IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
        } catch(SymbolNotDefinedException e) {
                {if (true) throw new CompilationException(e.getMessage());}
        }
                assignment = UXMLElementFactory.generateElement(Constants.ASSIGN, null ,null);
                attributes.put(Constants.NAME, variableSymbol.getName());
                if(variableValueElement.getElement() == null)
                        assignment.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol));
                else
                        assignment.appendChild(variableSymbolElement);
                assignment.appendChild(variableValueElement);
                currentNode.appendChild(assignment);
    jj_consume_token(STMT_TERMINATOR);
  }

/**
 * TODO: unary operator
 * expression() (( == | != | > | < | >= | <= ) expression())?
 */
  final public UXMLElement Condition() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement lhsExpression = null, rhsExpression = null, condition = null;
        Symbol lhsSymbol = null, rhsSymbol = null;
        String operatorName = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        HashMap<String,String> attributes = new HashMap<String, String>();
    lhsExpression = Expression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQ:
    case NT_EQ:
    case LT:
    case LT_EQ:
    case GT_EQ:
    case GT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NT_EQ:
        t = jj_consume_token(NT_EQ);
        break;
      case LT:
        t = jj_consume_token(LT);
                                              t.image = "(";
        break;
      case LT_EQ:
        t = jj_consume_token(LT_EQ);
                                                                             t.image = "(=";
        break;
      case GT:
        t = jj_consume_token(GT);
                                                                                                         t.image = ")";
        break;
      case GT_EQ:
        t = jj_consume_token(GT_EQ);
                                                                                                                                       t.image = ")=";
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                operatorName = t.image;
      rhsExpression = Expression();
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
                lhsSymbol = lhsExpression.getSymbol();
                try {
                        // Unary operator
                        if(operatorName == null)
                        {
                                operatorName = "==";
                                attributes.clear();
                                attributes.put(Constants.VALUE, operatorName);
                                operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                                condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                                condition.appendChild(lhsExpression);
                                currentNode.appendChild(condition);
                                currentNode = condition;
                                {if (true) return condition;}
                        }
                        // Binary operator
                        else {
                                rhsSymbol = rhsExpression.getSymbol();
                                attributes.clear();
                                attributes.put(Constants.VALUE, operatorName);
                                operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                                operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                                condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                                condition.appendChild(lhsExpression);
                                condition.appendChild(rhsExpression);
                                currentNode.appendChild(condition);
                                currentNode = condition;
                                {if (true) return condition;}
                        }
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(OperatorNotFoundException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
    throw new Error("Missing return statement in function");
  }

/**
 * TODO: NOT
 * Condition (( && | || ) Condition)* 
 */
  final public void MultipleConditions() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement parentNode = currentNode, savedCurrentNode = currentNode, not = null, condition = null, lhsCondition = null,rhsCondition = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        Symbol lhsSymbol = null, rhsSymbol = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    try {
      /*(
      			t = <NOT> {operatorName = t.image;}
      		)? */
                      lhsCondition = Condition();
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
        case OR:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_19;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          t = jj_consume_token(AND);
                           t.image = "$$";
          break;
        case OR:
          t = jj_consume_token(OR);
          break;
        default:
          jj_la1[40] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                        operatorName = t.image;
        /*(<NOT>)?*/
                        rhsCondition = Condition();
                        lhsSymbol = lhsCondition.getSymbol();
                        rhsSymbol = rhsCondition.getSymbol();
                        attributes.clear();
                        attributes.put(Constants.VALUE, operatorName);
                        operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                        operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                        condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                        condition.appendChild(lhsCondition);
                        condition.appendChild(rhsCondition);

                        currentNode = savedCurrentNode;
                        currentNode.appendChild(condition);

                        savedCurrentNode = currentNode;
                        lhsCondition = condition;
      }
                        if(condition != null)
                                currentNode = condition;
    } catch (IllegalSymbolValueException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    } catch (OperatorNotFoundException e) {
                {if (true) throw new CompilationException(e.getMessage());}
    }
  }

/**
 * if ( expression() (== expression())? ) 
 * {
 * 	... statements ...
 * } 
 * else if (expression() )
 * {
 * 	... statements ...
 * }
 * else {
 *  ... statements ...
 * }
 */
  final public void If() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode;
    jj_consume_token(IF);
    jj_consume_token(ROUND_START);
    MultipleConditions();
    jj_consume_token(ROUND_END);
    CodeBlock();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      CodeBlock();
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
                // Restore the node
                currentNode = parentNode;
  }

/**
 * for(assign() ; condition() ; expression() )
 * {
 * 		statements...
 * }
 */
  final public void For() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, for_loop = null, controllerNode = null, savedCurrentNode = null;
        Symbol variableSymbol = null, variableValueSymbol = null;
        UXMLElement variableSymbolElement = null, variableValueElement = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
    jj_consume_token(FOR);
                for_loop = UXMLElementFactory.generateElement(Constants.FOR_LOOP, null, null);
                currentNode.appendChild(for_loop);
                currentNode = for_loop;
    jj_consume_token(ROUND_START);
                controllerNode = UXMLElementFactory.generateElement(Constants.FROM, null, null);
                currentNode.appendChild(controllerNode);
                savedCurrentNode = currentNode;
                currentNode = controllerNode;
    Assignment();
                currentNode = savedCurrentNode;

                controllerNode = UXMLElementFactory.generateElement(Constants.TILL, null, null);
                currentNode.appendChild(controllerNode);
                savedCurrentNode = currentNode;
                currentNode = controllerNode;
    MultipleConditions();
    jj_consume_token(STMT_TERMINATOR);
                currentNode = savedCurrentNode;

                controllerNode = UXMLElementFactory.generateElement(Constants.STEP, null, null);
                currentNode.appendChild(controllerNode);

                savedCurrentNode = currentNode;
                currentNode = controllerNode;
    variableSymbolElement = Variable(false);
                controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
    jj_consume_token(ASSIGN);
    variableValueElement = Expression();
                variableSymbol = variableSymbolElement.getSymbol();

                variableValueSymbol = variableValueElement.getSymbol();
                try {
                        variableSymbol.setValue(variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol);
                        attributes.put(Constants.NAME, variableSymbol.getName());
                        controllerNode.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol));
                        currentNode.appendChild(controllerNode);

                        currentNode = controllerNode;

                        currentNode.appendChild(variableValueElement);
                        currentNode = savedCurrentNode;
                } catch(ImmutableSymbolException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(TypeMismatchException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch(IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
    jj_consume_token(ROUND_END);
    CodeBlock();
                // Restore the node
                currentNode = parentNode;
  }

/**
 * do {
 * 	...statements...
 * } while (condition) ;
 */
  final public void DO_WHILE() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, iterate = null, till = null;
    jj_consume_token(DO);
                iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
                currentNode.appendChild(iterate);
                currentNode = iterate;
    CodeBlock();
    jj_consume_token(WHILE);
                till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
                currentNode.appendChild(till);
                currentNode = till;
    jj_consume_token(ROUND_START);
    MultipleConditions();
    jj_consume_token(ROUND_END);
    jj_consume_token(STMT_TERMINATOR);
                // Restore the node
                currentNode = parentNode;
  }

/**
 * while(condition) {
 * 	...statements...
 * }
 */
  final public void WHILE_DO() throws ParseException, CompilationException {
        UXMLElement parentNode = currentNode, iterate = null, till = null;
    jj_consume_token(WHILE);
                iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
                currentNode.appendChild(iterate);
                currentNode = iterate;

                till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
                currentNode.appendChild(till);
                currentNode = till;
    jj_consume_token(ROUND_START);
    MultipleConditions();
    jj_consume_token(ROUND_END);
                currentNode = iterate;
    CodeBlock();
                // Restore the node
                currentNode = parentNode;
  }

/**
 * print(1, 2, "hello");
 * Prints : ( '_' is space)
 * 1_2_hello_"\n"
 * 
 * println(1,2,"hello");
 * Prints :
 * 1"\n"
 * 2"\n"
 * hello"\n"
 * 
 */
  final public void Print() throws ParseException, CompilationException {
        Token t = null;
        UXMLElement print, expression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRINT:
      t = jj_consume_token(PRINT);
      break;
    case PRINTLN:
      t = jj_consume_token(PRINTLN);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                print = UXMLElementFactory.generateElement(t.image, null, null);
    jj_consume_token(ROUND_START);
    expression = Expression();
                        print.appendChild(expression);
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_20;
      }
      jj_consume_token(COMMA);
      expression = Expression();
                                print.appendChild(expression);
    }
    jj_consume_token(ROUND_END);
    jj_consume_token(STMT_TERMINATOR);
                currentNode.appendChild(print);
  }

/**
 * E -> T1 E_L
 */
  final public UXMLElement Expression() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Expression_Left(Term1());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * E_L -> (& | | | ^ | >> | <<) T1 E_L
 */
  final public UXMLElement Expression_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AMPERSAND:
    case BIT_OR:
    case BIT_XOR:
    case BIT_LEFT_SHIFT:
    case BIT_RIGHT_SHIFT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AMPERSAND:
        t = jj_consume_token(AMPERSAND);
                           t.image = "$";
        break;
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_XOR:
        t = jj_consume_token(BIT_XOR);
        break;
      case BIT_RIGHT_SHIFT:
        t = jj_consume_token(BIT_RIGHT_SHIFT);
                                                                                                   t.image = "))";
        break;
      case BIT_LEFT_SHIFT:
        t = jj_consume_token(BIT_LEFT_SHIFT);
                                                                                                                                            t.image = "((";
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Term1();
                 rhsSymbol = currentRHS.getSymbol();
                 try {
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
        //			 currentLHS = "(" + currentLHS + currentOperator + currentRHS + ")";
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Expression_Left(currentLHS);
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T1 -> T2 T1_L
 */
  final public UXMLElement Term1() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Term1_Left(Term2());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T1_L -> (+ | -) T2 T1_L
 */
  final public UXMLElement Term1_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
        String operatorName = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Term2();
                 try {
                         rhsSymbol = currentRHS.getSymbol();
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Term1_Left(currentLHS);
      break;
    default:
      jj_la1[47] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T2 -> F T2_L
 */
  final public UXMLElement Term2() throws ParseException, CompilationException {
        UXMLElement restOfExpression = null;
    restOfExpression = Term2_Left(Factor());
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/**
 * T2_L -> (* | / | %) F T2_L
 */
  final public UXMLElement Term2_Left(UXMLElement currentLHS) throws ParseException, CompilationException {
        Token t = null;
        UXMLElement currentRHS = null,restOfExpression = null;
        UXMLElement operator = null;
        Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
        HashMap<String,String> attributes = new HashMap<String, String>();
        String operatorName = null;
        ArrayList<Symbol> operands = new ArrayList<Symbol>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASTERISK:
    case DIVIDE:
    case MOD:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASTERISK:
        t = jj_consume_token(ASTERISK);
        break;
      case DIVIDE:
        t = jj_consume_token(DIVIDE);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                 operatorName = t.image;
      currentRHS = Factor();
                 try {
                         rhsSymbol = currentRHS.getSymbol();
                         attributes.put(Constants.VALUE,operatorName);
                         operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
                         operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
                         // Make sure that div doesn't give divide by zero error
                         try {
                                 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
                         } catch(RuntimeException e)
                         {
                                 Symbol param1 = operands.get(0);
                                 Symbol param2 = operands.get(1);
                                 if(param1.getDataType() == DATA_TYPE.FLOAT || param2.getDataType() == DATA_TYPE.FLOAT)
                                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes,
                                                         SymbolMachine.generate(Constants.BLANK, Constants.FLOAT, true));
                                 else
                                         operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes,
                                                         SymbolMachine.generate(Constants.BLANK, Constants.INT, true));
                         }
                         currentNode.appendChild(operator);
                         operator.appendChild(currentLHS);
                         operator.appendChild(currentRHS);
                         currentLHS = operator;
        //		 currentLHS = "(" + currentLHS + currentOperator + currentRHS + ")";
                 } catch(IllegalSymbolValueException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 } catch(OperatorNotFoundException e) {
                         {if (true) throw new CompilationException(e.getMessage());}
                 }
      restOfExpression = Term2_Left(currentLHS);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
                if(restOfExpression == null)
                        restOfExpression = currentLHS;
                {if (true) return restOfExpression;}
    throw new Error("Missing return statement in function");
  }

/** 
 * F -> (E) | Variable() | Constant() | <VOID> | FunctionCall()
 */
  final public UXMLElement Factor() throws ParseException, CompilationException {
        Token t = null;
        String typeCast = null;
        Symbol value = null;
        FunctionType functionSymbol = null;
        UXMLElement expressionValue = null, returnFactorValue = null;
        HashMap<String, String> attributes = new HashMap<String, String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BLOCK_START:
      jj_consume_token(BLOCK_START);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
        break;
      case CHAR:
        t = jj_consume_token(CHAR);
        break;
      case BOOL:
        t = jj_consume_token(BOOL);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                                     typeCast = t.image;
      jj_consume_token(BLOCK_END);
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ROUND_START:
      jj_consume_token(ROUND_START);
      expressionValue = Expression();
      jj_consume_token(ROUND_END);
                                                                   returnFactorValue =  expressionValue ;
      break;
    case ASTERISK:
    case AMPERSAND:
    case ID:
      expressionValue = Variable(false);
                value = expressionValue.getSymbol();
                // In order to generate a variable here, the expressionValue should not contain any pointer-type
                // symbol or it should not contain an 'operator' element with '#' value.

                // If value is of type PointerType then Variable() returned an addressOf a variable. It will be handled to wherever
                // the Expression() is called
                // If expressionValue contains 'operator with value="#" ' ,then value might contain the symbol (integer,char,etc) because
                // operation '#' is performed in Variable() method. However variable is not to be generated here, but in the caller 
                // of Expression(). That's why, skip these 2 conditions.
                // Similarly argument holds for '[]' operation is present
                if((!(value instanceof PointerType) &&
                                !(Constants.OPERATOR.equals(expressionValue.getElementName()) &&
                                                Constants.VALUE_OF.equals(expressionValue.getAttributeValue(Constants.VALUE))
                                )) &&
                                (!(Constants.OPERATOR.equals(expressionValue.getElementName()) &&
                                                Constants.VALUE_AT_INDEX.equals(expressionValue.getAttributeValue(Constants.VALUE))))) {
                        attributes.clear();
                        attributes.put(Constants.NAME, expressionValue.getSymbol().getName());
                        expressionValue = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,expressionValue.getSymbol());
                }
                returnFactorValue = expressionValue;
      break;
    case INT_CONSTANT:
    case FLOAT_CONSTANT:
    case STRING_CONSTANT:
    case BOOL_CONSTANT:
    case CHAR_CONSTANT:
      value = Constant();
                               returnFactorValue =  new UXMLElement(null,value);
      break;
    case VOID:
      jj_consume_token(VOID);
                  try { returnFactorValue =  new UXMLElement(null,SymbolMachine.generate(Constants.BLANK,Constants.VOID, false));  } catch(Exception e ){}
      break;
    case CALL:
      expressionValue = FunctionCall();
                                             returnFactorValue = expressionValue;
      break;
    default:
      jj_la1[52] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                try {
                        if(typeCast != null) {
                                attributes.put(Constants.TYPE, typeCast);
                                expressionValue = UXMLElementFactory.generateElement(Constants.CAST ,attributes, SymbolMachine.cast(returnFactorValue.getSymbol(), typeCast));
                                expressionValue.appendChild(returnFactorValue);
                                returnFactorValue = expressionValue;
                        }
                } catch(TypeMismatchException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch (SymbolNotDefinedException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                } catch (IllegalSymbolValueException e) {
                        {if (true) throw new CompilationException(e.getMessage());}
                }
                {if (true) return returnFactorValue;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public CTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[53];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x3e0,0x40000,0x240000,0x240000,0x0,0x0,0x0,0x240000,0x240000,0x40000,0x0,0x40000,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x240000,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x60000000,0x60000000,0x0,0x0,0x0,0x6e00000,0x6e00000,0x30000,0x30000,0x1c0000,0x1c0000,0x0,0x0,0x2403e0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0xf8000000,0xf8000000,0x0,0x0,0x0,0x0,0xf8008000,0x10000,0xf8008000,0x4027e40,0x4027e40,0x0,0x8000,0x0,0x8000,0x2000000,0x8000,0x0,0x8000,0xf8000000,0xf8008000,0x4027e40,0x8000,0x2000000,0xf8000000,0x408000,0x2000000,0x8000,0x0,0x8000,0x1000000,0x2000000,0x0,0x8000,0x1000000,0x100000,0x100000,0x3f,0x3f,0x0,0x0,0x80,0x6000,0x2000000,0x0,0x0,0x0,0x0,0x0,0x0,0x78000000,0x40000,0x401000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x1,0x3,0x0,0x0,0x0,0x0,0x3,0x0,0x3,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x3,0x4,0x0,0x0,0x3,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5,};
   }

  /** Constructor with InputStream. */
  public C(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public C(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public C(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new CTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public C(CTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(CTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 53; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[69];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 53; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 69; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
