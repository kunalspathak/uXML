/**
 * JavaCC file
 */
  
options {
  JDK_VERSION = "1.6";
}

PARSER_BEGIN(C)   
package parserOfC;
 
import java.io.File;
import java.io.FileReader;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader; 
import java.io.LineNumberReader;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Scanner;

import compiler.components.Environment;
import compiler.components.Operators;
import compiler.components.Symbol;
import compiler.dataTypes.DataTypeFinder;
import compiler.dataTypes.SymbolMachine;
import compiler.dataTypes.ConstantValue;
import compiler.dataTypes.PointerType;
import compiler.dataTypes.FunctionType;
import compiler.dataTypes.OverloadedFunctionType;
import compiler.dataTypes.ArrayType;

import compiler.exceptions.IllegalSymbolValueException;
import compiler.exceptions.ImmutableSymbolException;
import compiler.exceptions.OperatorNotFoundException;
import compiler.exceptions.TypeMismatchException;
import compiler.exceptions.SymbolNotDefinedException;
import compiler.exceptions.ImmutableSymbolException;

import compiler.uXMLGenerator.*;
import compiler.operator.Operator;
import compiler.util.Clone;
import compiler.util.Constants;
import compiler.util.Constants.DATA_TYPE;

import parserOfC.exceptions.CompilationException;

//import parserOfC.visitor.GenerateuXMLCode;
import xvHandler.Executor;
import xvHandler.CodeAnalysis;
import xvHandler.ProcedureCallSeq;
 
 
public class C {  
	 
  private static UXMLElement currentNode = null;	
  private static boolean globalVariableDeclaration = false;
  private static String currentReturnType = null;
  private static FunctionType currentFunction = null;
  private static boolean isReturnStmtPresent = false;
	
  public static void main(String args[]) throws ParseException {
	 
	FileInputStream io = null; 
	String codeAnalysisFlag = null;
	LineNumberReader loc = null;
    
	String fileName = null;
	String filePath = null;
    if(args.length == 0) {
    	Scanner in = new Scanner(System.in);
    	System.out.print("Enter the file name @ src" +File.separator + "sampleCLikeProgs" + File.separator);
    	fileName = in.nextLine();
    	while(fileName.trim().length() == 0)
    		fileName = in.nextLine();
    	codeAnalysisFlag = in.nextLine();
    	args = new String[1];
    	args[0] = fileName;
    }
    else {
        fileName = args[0]; 
        if(args.length > 1)
        	codeAnalysisFlag = args[1];
    }
    
    try {
    	filePath = "src" + File.separator + "sampleCLikeProgs" + File.separator + fileName + ".Clike";
    	io = new FileInputStream(filePath);
    	C parser = new C(io);
    	
    	// Initialize the environment with ignore dynamic variable flag
    	Environment.initialize(new ProcedureCallSeq(), true);
    	// Initialize the uXMLDocument generator
    	currentNode = UXMLElementFactory.initialize("Clike", Constants.STATIC);
    	
        
        //GenerateuXMLCode cProgramConverter = new GenerateuXMLCode();
        
        Environment.currentActivationRecord.enterTheBlock();
        //cProgram.accept(cProgramConverter);
        /*Node cProgram = */parser.CLike();
        Environment.currentActivationRecord.leaveTheBlock(); 
        
        // Save the uXML document
        UXMLElementFactory.done(fileName);
        
        // System.out.println("Calling backend..."); 
        // args = new String[1];
        // args[0] = fileName;
        if("-analysis".equals(codeAnalysisFlag)) {
        	loc = new LineNumberReader(new FileReader(filePath));
        	while (loc.readLine() != null) {}
        	CodeAnalysis.main(args, loc.getLineNumber()); 
        }
        else
        	Executor.main(args);
        
        
         
    } catch (FileNotFoundException fe) {
    	System.err.println("File '" + fileName + "' not found.");
    	System.exit(1);
    } catch(IOException ie) {
    	System.err.println("Error reading file '" + fileName + "'.");
    	System.exit(1);
    } catch(ParseException e) {
        String message = e.getMessage();
        int startIndex = message.indexOf("line ") + 5;
        int endIndex = message.indexOf(",");
        String lineNo = message.substring(startIndex, endIndex).trim();

        startIndex = message.indexOf("column ") + 7;
        endIndex = message.indexOf(".");
        String columnNo = message.substring(startIndex, endIndex).trim();

        startIndex = message.indexOf("\"") + 1;
        endIndex = message.lastIndexOf("\" at line");
        String keyword = message.substring(startIndex, endIndex).replaceAll("\"","").trim();
        
        System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
        StringBuffer expectedTokens = new StringBuffer("Expected tokens : ");
        String tokenValue = null;
        tokenValue = tokenImage[e.expectedTokenSequences[0][0]];
    	tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
    	expectedTokens.append(tokenValue);
        for(int tokenId = 1; tokenId < e.expectedTokenSequences.length;tokenId++) {
        	tokenValue = tokenImage[e.expectedTokenSequences[tokenId][0]];
        	tokenValue = "'" + tokenValue.substring(1, tokenValue.length() - 1) + "'";
        	expectedTokens.append(", ")
        		.append(tokenValue);
        }
    	System.err.println(expectedTokens.toString());
    } catch(TokenMgrError e) {
    	String message = e.getMessage();
		int startIndex = message.indexOf("line ") + 5;
		int endIndex = message.indexOf(",");
		String lineNo = message.substring(startIndex, endIndex).trim();
		
		startIndex = message.indexOf("column ") + 7;
		endIndex = message.indexOf(".");
		String columnNo = message.substring(startIndex, endIndex).trim();
		
		startIndex = message.indexOf("\"") + 1;
		endIndex = message.indexOf("\"",startIndex);
		String keyword = message.substring(startIndex, endIndex).trim();
		
		System.err.println("Compilation Error : Unexpected keyword '" + keyword +  "' at line " + lineNo + ", column " + columnNo);
    }
    catch(CompilationException e) {
    	System.err.println(e.getMessage());
    }
  }
  
/**
 * processPointer(pointer, dataType)
 * 
 * Takes the data-type and return the pointer type symbol generated
 * 
 */
 private static PointerType processPointer(PointerType pointer, String dataType, boolean valueMutableStatus) throws CompilationException {
	 String pointerType= null; 
	 HashMap<String, String> attributes = new HashMap<String, String>();
	 try {
		// If this is a single pointer i.e. int * or char *, then set reference type of 
		// pointer as 'int' or 'char', whatever is applicable.
		if(pointer == null) {
			pointer = (PointerType)SymbolMachine.generate(Constants.BLANK, Constants.POINTER, valueMutableStatus);
			pointer.setReferenceType(dataType); 
			pointer.setPointee(SymbolMachine.generate(Constants.BLANK,dataType, valueMutableStatus));
		} 
		// If this is a multiple pointer i.e. int ** or char **, then set reference type of 
		// pointer as that of previously read pointer type i.e. 'int*' or 'char*', whatever is applicable.
		else {
			// Get the previous pointerType 
			pointerType = pointer.getName();
			pointer = (PointerType)SymbolMachine.generate(Constants.BLANK, pointerType, valueMutableStatus);
			pointer.setReferenceType(pointerType);
			pointer.setPointee(SymbolMachine.generate(Constants.BLANK,pointerType, valueMutableStatus));
		}
		
		// Set the pointer name as data-type. This will let us reuse the already defined pointer-type
		// instead of redefining the pointer-type in furture variable declaration.
		try {
			pointer.setName(DataTypeFinder.getDataType(pointer));
		} catch(SymbolNotDefinedException e ) {}
		
		// Create the 'pointer-type' element only if it's not already defined
		if(!Environment.currentActivationRecord.isSymbolPresent(pointer.getName()) && 
				!Environment.isSymbolPresentInGlobalScope(pointer.getName())) {
			// Set the attributes of pointer-type
			attributes.put(Constants.NAME,pointer.getName());
			attributes.put(Constants.REF_TYPE, pointerType == null? dataType : pointerType);
			currentNode.appendChild(UXMLElementFactory.generateElement(Constants.POINTER_TYPE,attributes,pointer));
			// Add the pointer-type in symbol table
			// If this is a global variable declaration, then add in global symbol table
			if(globalVariableDeclaration)
				Environment.addGlobalSymbol(pointer);
			else
				Environment.currentActivationRecord.addSymbol(pointer);
		}
		return pointer;
	 } catch(Exception e) {
		 throw new CompilationException(e.getMessage());
	 }
 }

}

PARSER_END(C)

SKIP : { " " | "\r" | "\t" | "\n" }

/* Constants */
TOKEN: { < INT_CONSTANT : ( < DIGIT > ) + > }
TOKEN: { < FLOAT_CONSTANT : ( < DIGIT > ) + "." ( < DIGIT > ) + > }
TOKEN: { < STRING_CONSTANT : "\"" (~["\""])+ "\"" > }
TOKEN: { < BOOL_CONSTANT : "true" | "false" > }
TOKEN: { < CHAR_CONSTANT : "'" ~["'"] "'" > }

/* Comments */
//Cited from : http://en.wikibooks.org/wiki/Compiler_Construction
SPECIAL_TOKEN : {<"/*"> : InsideComment}
<InsideComment> SPECIAL_TOKEN :
{
	<"*/"> : DEFAULT
}
<InsideComment> MORE: {<~[]>}

SPECIAL_TOKEN : {<"//"> : InsideNewComment}
<InsideNewComment> SPECIAL_TOKEN :
{
	<"\n" | "\r"> : DEFAULT
}
<InsideNewComment> MORE: {<~[]>}

/* OPERATORS */
TOKEN : { < PLUS: "+" > }	
TOKEN : { < MINUS: "-" > }
TOKEN : { < ASTERISK: "*" > }
TOKEN : { < DIVIDE: "/" > } 
TOKEN : { <MOD: "%" > }
TOKEN : { < AMPERSAND : "&" > }
TOKEN : { < BIT_OR : "|" > } 
TOKEN : { < BIT_XOR : "^" > }
TOKEN : { < BIT_COMPLEMENT : "~" > }
TOKEN : { < BIT_LEFT_SHIFT : "<<" > } 
TOKEN : { < BIT_RIGHT_SHIFT : ">>" > } 
TOKEN : { < INCREMENT : "++" > }
TOKEN : { < DECREMENT : "--" > }

/* Logical Operators */
// TODO
TOKEN: { < AND : "&&" > }
TOKEN: { < OR : "||" > }
TOKEN: { < NOT: "!" > }

/* Conditional Operators */
TOKEN: { < EQ : "==" > }
TOKEN: { < NT_EQ : "!=" > }
TOKEN: { < LT: "<" > }
TOKEN: { < LT_EQ : "<=" > }
TOKEN: { < GT_EQ : ">=" > }
TOKEN: { < GT: ">" > }

/* Keywords */
TOKEN : { < IF : "if" > } 
TOKEN : { < ELSE : "else" > } 
TOKEN : { < ELSEIF : "elseif" > } 
TOKEN : { < DO : "do" > } 
TOKEN : { < WHILE : "while" > } 
TOKEN : { < FOR : "for" > }
TOKEN : { <CALL : "call" > }
TOKEN : { <PRINT : "print"> }
TOKEN : { <PRINTLN : "println"> }
TOKEN : { <CONST : "const"> }
TOKEN : { <FUNCTION : "function"> }
TOKEN : { <RETURN : "return"> }
TOKEN : { < BLOCK_START : "{" > } 
TOKEN : { < BLOCK_END : "}" > } 
TOKEN : { < SQUARE_START : "[" > } 
TOKEN : { < SQUARE_END : "]" > } 
TOKEN : { < ROUND_START : "(" > } 
TOKEN : { < ROUND_END : ")" > } 
TOKEN : { < ASSIGN : "=" > } 
TOKEN : { < COMMA : "," >} 
TOKEN : { < STMT_TERMINATOR : ";" > }

/* Data types */
TOKEN : { < INT : "int" > } 
TOKEN : { < FLOAT : "float" > } 
TOKEN : { < CHAR : "char" > } 
TOKEN : { < BOOL : "boolean" >  } 
TOKEN : { < STRUCT : "struct" > }
TOKEN : { < VOID : "void" > } 
TOKEN : { < FUNC_PTR : "funcptr"> }
TOKEN : { <ID : ("_" | <ALPHA>)("_" | <DIGIT> | <ALPHA>)* > }

TOKEN : {<ALPHA : ["a" - "z"] | ["A" - "Z"]>}
TOKEN : {<DIGIT : ["0" - "9"]>}

// Define the proto-types of constructs that will be used in rules
String DataType() throws CompilationException : 
{
	Token t = null; 
	String funcPtrReturnType = null;
	Symbol functionPointer;
	UXMLElement functionPointerElement = null;
}
{
	(t = < INT > | t = < FLOAT > | t = < CHAR > | t = < BOOL > | t = < STRUCT > | t = <VOID>  )
	{
		return t.image;
	}
	|
	<FUNC_PTR>
	functionPointerElement = FunctionPointer()
	{
		functionPointer = functionPointerElement.getSymbol();
		// Change return-type to function signature 
		funcPtrReturnType = functionPointer.getName();
		
		if(!Environment.currentActivationRecord.isSymbolPresent(funcPtrReturnType) && 
				!Environment.isSymbolPresentInGlobalScope(funcPtrReturnType)) {
			 // Specify if the function type is already defined or not
			// If already defined, then use the same function-type name while defining pointer-type
			// else declare the function-type element before declaring the pointer-type
			currentNode.appendChild(functionPointerElement);
			if(globalVariableDeclaration)
				Environment.addGlobalSymbol(functionPointer);
			else
				Environment.currentActivationRecord.addSymbol(functionPointer);
		}
		return funcPtrReturnType;
	}
}

Symbol Constant() throws CompilationException : {Token t = null;}
{
	try {
		(t = < INT_CONSTANT > { return new ConstantValue(Constants.INT,t.image);} 
		| t = < FLOAT_CONSTANT > { return new ConstantValue(Constants.FLOAT,t.image);}
		| t = < CHAR_CONSTANT > 
		{
			String ch = t.image.substring(1,2);
			return new ConstantValue(Constants.CHAR,ch);
		}
		| t = < STRING_CONSTANT > 
		{ 
			String str = t.image;
			str = str.substring(1, str.length() - 1);
			return new ConstantValue(Constants.STRING,str);
		}
		| t = < BOOL_CONSTANT >{ return new ConstantValue(Constants.BOOLEAN,t.image);}
		)
	} catch(IllegalSymbolValueException e) {
		throw new CompilationException(e.getMessage());
	}
}

/**
 * Variable access - Also used for address of/value of feature
 *  (& | (*)+)? ID ( [ INT_CONSTANT ] )*
 *  
 *  isFunctionName specifies whether this is a function call or normal expression
 */
UXMLElement Variable(boolean isFunctionName) throws CompilationException : 
{
	Token t = null;
	Symbol variableSymbol = null, argumentSymbol = null;
	FunctionType functionSymbol = null;
	String operatorName = null, functionName = null, variableName = null;
	UXMLElement parentNode = currentNode, innerMostPointer = null, multiPointer = null, pointer = null, 
	variableSymbolElement = null,call = null,argumentElement = null, arrayElementNode = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
	int valueOfCount = 0;
}
{
	(
	// Address of
	<AMPERSAND> {operatorName = "@";} | 
	(	
		// Multiple pointer		
		<ASTERISK> 
		{
			operatorName = "#";
			attributes.clear();
			attributes.put(Constants.VALUE, operatorName);
			valueOfCount++;
			if(multiPointer == null) {
				// TODO: Swap the name of multiPointer and innerMostPointer
				multiPointer = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null);
				// Need to save the inner most pointer, because variable is going to be the child element of inner most 
				// pointer
				innerMostPointer = multiPointer;
			} else
				multiPointer = multiPointer.appendChild(UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, null));
		} 
	)+
	)?
	t = <ID> 
	{
		try {
		variableName = t.image;
		variableSymbol = Environment.getSymbol(variableName);
		attributes.clear();
		attributes.put(Constants.NAME, variableSymbol.getName());
		variableSymbolElement = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol);
		} catch(SymbolNotDefinedException e) {throw new CompilationException(e.getMessage());}
	}
	variableSymbolElement = ArrayAccess(variableSymbolElement) 
	{	
		variableSymbol = variableSymbolElement.getSymbol(); 
		try {
			
			// If this is pointer operation
			if(operatorName != null) {
				attributes = new HashMap<String, String>();
				attributes.put(Constants.VALUE, operatorName);
				operands.add(variableSymbol);
				pointer = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
				
				// If this is valueOf operator, then append the variable to pointer variable
				if(innerMostPointer != null) {
					Symbol valueOfPointer = pointer.getSymbol();
					// Apply * operation multiple times to get the final value 
					while(valueOfCount != 1) {
						operands.clear();
						operands.add(valueOfPointer);
						valueOfPointer = Operator.execute(operatorName, operands);
						valueOfCount--;
					}
					
					// Append the variable to the inner most pointer node
					multiPointer.appendChild(variableSymbolElement);
					if(!isFunctionName)
						currentNode.appendChild(innerMostPointer);
					// return the symbol after executing pointer operation
					innerMostPointer.setSymbol(valueOfPointer);
					variableSymbolElement = innerMostPointer;
				}
				else {
					pointer.appendChild(variableSymbolElement);
					if(!isFunctionName)
						currentNode.appendChild(pointer);
					// return the symbol after executing pointer operation
					variableSymbolElement = pointer;
				}
			} 
			return variableSymbolElement;
		} catch(IllegalSymbolValueException e) {
			throw new CompilationException(e.getMessage());
		} catch(OperatorNotFoundException e) {
			throw new CompilationException(e.getMessage());
		}
	}
	
}

// Rules start
 
void CLike() throws CompilationException : {}
{
	Program()
}

/**
 * Program
 */
void Program() throws CompilationException : 
{
	UXMLElement parentNode = currentNode, functionNode = null, block = null, callToMain = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
}
{
	// Global scope start
	{
		block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
		currentNode.appendChild(block);
		currentNode = block;
		globalVariableDeclaration = true;
	}
	(VarDeclaration())*
	{
		globalVariableDeclaration = false;
	}
	(FunctionDefinition())+
	{
		callToMain = UXMLElementFactory.generateElement(Constants.CALL, null, null);
		attributes.put(Constants.NAME, "main");
		callToMain.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE, attributes, null));
		block.appendChild(callToMain);
	}
	// Global scope end
	{
		// Restore the current Node
		currentNode = parentNode;
	}
}

/**
 * {
 *  ...statements...
 * }
 */
void CodeBlock() throws CompilationException : 
{
	UXMLElement parentNode = currentNode, block = null;
} 
{
	ScopeStart()
	{
		block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
		currentNode.appendChild(block);
		currentNode = block;
	}
		(VarDeclaration())*
		(Statement())*
	ScopeEnd()
	{
		// Restore the 
		currentNode = parentNode;
	}
}

/**
 * Scope start
 * {
 */
void ScopeStart() : {}
{
	<BLOCK_START>	
	{
		Environment.currentActivationRecord.enterTheBlock();
	}
}

/**
 * Scope end
 * }
 */
void ScopeEnd() : {}
{
	<BLOCK_END>	
	{
		Environment.currentActivationRecord.leaveTheBlock();
	}
}

/**
 * Statements
 * Variable declaration, assignment, if, for
 */
void Statement() throws CompilationException : {UXMLElement funcCall = null;}
{
	Assignment()  | If() | For() | DO_WHILE() | WHILE_DO() | Print() | funcCall = FunctionCall() <STMT_TERMINATOR> {currentNode.appendChild(funcCall);}| Return() | <STMT_TERMINATOR>
}

/**
 * Function 
 * function returnType ([int_constant])? (*)* functionName ( ((const)? dataType (*)* variableName (, (const)? dataType (*)* variableName)* )? )
 * 	CodeBlock()
 * 
 */
void FunctionDefinition() throws CompilationException : 
{
	Token t = null;
	String  paramType = null, paramName = null, functionName = null;
	UXMLElement parentNode = currentNode, functionNode = null, savedCurrentNode = null, arrayElement = null;
	PointerType pointer = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> formalParams = new ArrayList<Symbol>();
	Symbol paramSymbol = null;
	FunctionType functionType = null;
	boolean mutable = true, ptrMutable = true;
}
{
	try { 
	<FUNCTION>
	currentReturnType = DataType() 
	(<ASTERISK>
	{
		pointer = processPointer(pointer, currentReturnType, true);
	}
	)*
	arrayElement = CreateArray(Constants.BLANK,pointer == null?SymbolMachine.generate(Constants.BLANK, currentReturnType, true) : pointer ,true)
	{
		currentReturnType = arrayElement.getSymbol().getType();
	}
	t = <ID> 
	{
		functionName = t.image;
		// Make the function as non-mutable
		currentFunction = new FunctionType(functionName, false, currentReturnType);
		currentFunction.setReturnValue(arrayElement.getSymbol());
		// Nested level of function will be '0' since nested functions are not allowed in Clike
		currentFunction.setNestedLevel(0);
		attributes.put(Constants.NAME, functionName);
		functionNode = UXMLElementFactory.generateElement(Constants.FUNCTION, attributes,currentFunction );
		currentNode.appendChild(functionNode);
		currentNode = functionNode;
		
		// Execute the calling sequence of a caller - 
		// Nested level of function will be '0' since nested functions are not allowed in Clike
        Environment.callSequenceProcessor.callAction_caller(0);
        // There may be the case that arguments to the function are function-pointers or like that which
        // are needed to add in symbol table, for that the method call 'enterTheBlock()' is necessary so that
        // symbol table will be created.
        Environment.currentActivationRecord.enterTheBlock();
	} 
	<ROUND_START> 
	(
		<CONST> {mutable = false; pointer = null;}
	)?
	(paramType = DataType()
	(<ASTERISK> {pointer = processPointer(pointer, paramType, mutable);} )*
	(<CONST> {ptrMutable = false;})?
	{
		if(pointer != null) {
			/*try {
				paramType = DataTypeFinder.getDataType(pointer);
			} catch(SymbolNotDefinedException e) {}*/
			paramType = pointer.getName();
			pointer.setMutableStatus(ptrMutable);
		}  
	}
	t = <ID> 
	{
		paramName = t.image;
		// Create automatic-Var and append all the parameters to it
		savedCurrentNode = currentNode;
		currentNode = currentNode.appendChild(UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null));
		paramSymbol = SymbolMachine.generate(paramName, paramType, mutable);
		
		
		/* added - start */
		
		// Set the pointer type, else 'pointer' will be saved
		  if(pointer != null) {
			  paramSymbol.setType(paramType);
		  }
	  }
	  arrayElement = CreateArray(paramName, paramSymbol, mutable)
	  {
		  
		  paramSymbol = arrayElement.getSymbol();
		  
		  // Set the name of the variable
		  paramSymbol.setName(paramName);
		  
		  /* added - end */
		
		  currentFunction.addSymbol(paramSymbol);
		  attributes.clear();	
		
		  attributes.put(Constants.NAME, paramName);
		  attributes.put(Constants.TYPE, paramSymbol.getType());
		  
		  // If this is a pointer
		  if(pointer == null || ( paramSymbol != null && paramSymbol instanceof ArrayType) 
				  /*Constants.ARRAY_TYPE.equals(arrayElement.getElementName())*/)
			  attributes.put(Constants.MUTABLE, mutable? "yes" : "no" );
		  else {
			  attributes.put(Constants.PTR_MUTABLE, ptrMutable? "yes" : "no"); 
			  attributes.put(Constants.VALUE_MUTABLE, mutable? "yes" : "no" ); // hence value is set depending on mutable status.  
		  }
		  currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
	  } 
	
	(<COMMA> 
	(
			<CONST> {mutable = false; pointer = null;}
	)?
	paramType = DataType()
	(<ASTERISK> {pointer = processPointer(pointer, paramType, mutable);} )*
	(<CONST> {ptrMutable = false;})?
	{
		if(pointer != null) {
			paramType = pointer.getName();
			pointer.setMutableStatus(ptrMutable);
		}  
	}
	t = <ID>
	{
		paramName = t.image;
		paramSymbol = SymbolMachine.generate(paramName, paramType, mutable);
		
		/* added - start */
				
		// Set the pointer type, else 'pointer' will be saved
		if(pointer != null) {
			paramSymbol.setType(paramType);
		}
	}
	arrayElement = CreateArray(paramName, paramSymbol, mutable)
	{
		paramSymbol = arrayElement.getSymbol();
				  
		// Set the name of the variable
		paramSymbol.setName(paramName);
		
		/* added - end */

		currentFunction.addSymbol(paramSymbol);
		
		attributes.clear();
		
		attributes.put(Constants.NAME, paramName);
		attributes.put(Constants.TYPE, paramSymbol.getType());
		  
		// If this is a pointer
		 if(pointer == null || ( paramSymbol != null && paramSymbol instanceof ArrayType) 
				  /*Constants.ARRAY_TYPE.equals(arrayElement.getElementName())*/)
			  attributes.put(Constants.MUTABLE, mutable? "yes" : "no" );
		  else {
			  attributes.put(Constants.PTR_MUTABLE, ptrMutable? "yes" : "no"); 
			  attributes.put(Constants.VALUE_MUTABLE, mutable? "yes" : "no" ); // hence value is set depending on mutable status.  
		  }
		 currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, paramSymbol));
	}
	)*
	{
		// Restore the currentNode
		// If savedCurrentNode is null, it means that there were no parameters to the function
		// and there is no need to restore the currentNode
		if(savedCurrentNode != null)
			currentNode = savedCurrentNode;
	}
	)?
	{
		attributes.clear();
		attributes.put(Constants.TYPE, currentReturnType);
		// Append the return type
		currentNode.appendChild(UXMLElementFactory.generateElement(Constants.RETURNS, attributes, null));
		
		// Save the function in global symbol table
		Environment.addGlobalSymbol(currentFunction);
	}
	<ROUND_END>
	<BLOCK_START>
	{
		// Copy the formal params in current symbol table
		for(Symbol formalArg : currentFunction.getFormalParameters())
			Environment.currentActivationRecord.addSymbol(formalArg);
		
		UXMLElement block = UXMLElementFactory.generateElement(Constants.BLOCK, null, null);
		currentNode.appendChild(block);
		savedCurrentNode = currentNode;
		currentNode = block;
	}
	(VarDeclaration())*
	(Statement())*
	ScopeEnd()
	{
		// If function is defined to return a value and return statement is not present in function definition
		// or if function is defined to return void and if return statement is present 
		// then throw error  
		if(!Constants.VOID.equals(currentFunction.getReturnType()) && !isReturnStmtPresent)
			throw new CompilationException("'" + currentFunction.getName() + "' should return a value of type '" 
					+ currentFunction.getReturnType() + "'.");
		else if(Constants.VOID.equals(currentFunction.getReturnType())&& isReturnStmtPresent )
			throw new CompilationException("'" + currentFunction.getName() + "' declared as 'void' should not return a value.");
		else
			isReturnStmtPresent = false;
		// Restore the currentNode 
		currentNode = parentNode;
		// Function done
		Environment.callSequenceProcessor.returnAction_caller();
		
		// Save the function in global symbol table
//		Environment.addGlobalSymbol(currentFunction);

	}
	} catch(IllegalSymbolValueException e ) {
		throw new CompilationException(e.getMessage());
	}
}

/**
 * Return statement
 * 
 * return expression() ;
 */
void Return() throws CompilationException : 
{
	UXMLElement returnExpression = null, returnElement = null;
	String requiredReturnType = null, foundReturnType = null;
	Symbol returnSymbol = null;
} 
{
	<RETURN>
	returnExpression = Expression()
	{
		returnElement = UXMLElementFactory.generateElement(Constants.RETURN, null, null);
		returnSymbol = returnExpression.getSymbol();
		returnSymbol = (returnSymbol instanceof FunctionType)? ((FunctionType)returnSymbol).getReturnValue():returnSymbol;
		returnElement.appendChild(returnExpression);
		currentNode.appendChild(returnElement);
		
		// Try to set the return symbol into the return value of currentfunction. 
		// If the return-type is not compatible then error will be thrown
		try {
			requiredReturnType = DataTypeFinder.getDataType(currentFunction.getReturnValue());
			foundReturnType = DataTypeFinder.getDataType(returnSymbol);
			if(requiredReturnType.equals(foundReturnType)) {
				Symbol returnValue = currentFunction.getReturnValue();
				if(returnValue instanceof ArrayType)
					((ArrayType) returnValue).copyArray(returnSymbol);
			}
			else
				throw new TypeMismatchException(foundReturnType,requiredReturnType);
			isReturnStmtPresent = true;
		  } catch(TypeMismatchException e) {
			  throw new CompilationException("Function '" + currentFunction.getName()
					  + "' should return '" + requiredReturnType + "' and not '"  + foundReturnType + "'.",e.getMessage());
		  } catch(SymbolNotDefinedException e) {System.err.println(e.getMessage());}
	}
	<STMT_TERMINATOR>
}

/**
 * Function pointer
 * defined_functionType | ( datatype() ( (datatype() (, datatype())*)? ))
 * 
 * eg. funcptr fun1 (int (float, float)) // Define the type 
 *     funcptr fun1 sample;  // Declare function pointer 'sample' of type 'fun1'
 * 
 */
UXMLElement FunctionPointer() throws CompilationException : 
{
	Token t = null;
	String returnType = null, functionName = null, functionPtrType = null, paramType = null, functionPtrName = null, operatorName = null, 
	functionPtrVarName = null, newVariableName = null;
	int valueOfCount = 0;
	boolean mutable = true;
	Symbol paramSymbol = null, functionPointer = null, variableSymbol = null;
	FunctionType functionType = null;
	UXMLElement functionTypeElement = null, automaticVarElement = null, returnElement = null, functionPtrElement = null,
	arrayElement = null;
	PointerType pointer = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
}
{
	try {
		// Old code
		// functionPtrElement = Variable(true) { return functionPtrElement; }
		(
		// 1. Function pointer variable declaration
		(
			(<CONST> {mutable = false;})?
			// Function pointer name
			t = <ID> 
			{
				functionPtrName = t.image;
				functionPointer = Environment.getSymbol(functionPtrName);
				return new UXMLElement(null, functionPointer);
			}
		)
		|
		// 2. Function pointer's definition 
		(<ROUND_START> returnType = DataType() 
		{
			functionType = new FunctionType(Constants.BLANK, false, returnType);
			attributes.clear();
			attributes.put(Constants.TYPE, returnType);
			// Append the return type
			returnElement = UXMLElementFactory.generateElement(Constants.RETURNS, attributes, null);
		}
		<ROUND_START> 
		(paramType = DataType() 
		{ 
			automaticVarElement = UXMLElementFactory.generateElement(Constants.AUTOMATIC_VAR, null, null);
			paramSymbol = SymbolMachine.generate(Constants.BLANK, paramType, false);
			automaticVarElement.appendChild(new UXMLElement(null, paramSymbol));
			functionType.addSymbol(paramSymbol); 
		}  
		(<COMMA> 
		paramType = DataType() 
		{ 
			paramSymbol = SymbolMachine.generate(Constants.BLANK, paramType, false);
			automaticVarElement.appendChild(new UXMLElement(null, paramSymbol));
			functionType.addSymbol(paramSymbol); 
		}
		)*)? 
		<ROUND_END> <ROUND_END>
		{
			// Set the name as signature of the function
			functionName = functionType.getSignature();
			functionType.setName(functionName);
			// Set the attributes of function-type
			attributes.clear();
			attributes.put(Constants.NAME, functionName);
			functionTypeElement = UXMLElementFactory.generateElement(Constants.FUNCTION_TYPE, attributes, functionType);
			if(automaticVarElement != null)
				functionTypeElement.appendChild(automaticVarElement);
			functionTypeElement.appendChild(returnElement);
			return functionTypeElement;
		}
		)
		)
	} catch (IllegalSymbolValueException e) {
		throw new CompilationException(e.getMessage());
    } catch (SymbolNotDefinedException e) {
    	throw new CompilationException(e.getMessage());
    }
}

/**
 * Function call
 * In case there are no arguments to the function, user need to specify 'void' 
 * eg. call_func(void) 
 * CALL Variable() ((expression (, expression)*)?)
 */
UXMLElement FunctionCall() throws CompilationException : 
{
	Token t = null;
	UXMLElement argumentElement = null, call = null, function = null;
	String functionName = null;
	Symbol argumentSymbol = null, functionType = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> actualArgs = new ArrayList<Symbol>();
	FunctionType functionSymbol = null;
}
{
	<CALL>
//	t = <ID>
	function = Variable(true)
	{
		functionType = function.getSymbol();
		functionName = functionType.getName();
		call = UXMLElementFactory.generateElement(Constants.CALL, null, null);
		attributes.clear();
		if(!(Constants.OPERATOR.equals(function.getElementName()) && 
						Constants.VALUE_OF.equals(function.getAttributeValue(Constants.VALUE)))) 
		{
			
			attributes.put(Constants.NAME, functionName);
			call.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,functionType));
		} else {
			call.appendChild(function);	
		}
	} 
	<ROUND_START> 
	(argumentElement = Expression() 
	{
		argumentSymbol = argumentElement.getSymbol();
		// Check if expression is void and if yes, then no-argument function call is made
		if(!Constants.VOID.equals(argumentSymbol.getType())) {
			actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
			call.appendChild(argumentElement);
		}
	} 
	(<COMMA> 
	argumentElement = Expression()
	{
		argumentSymbol = argumentElement.getSymbol();
		actualArgs.add(argumentSymbol instanceof FunctionType? ((FunctionType)(argumentSymbol)).getReturnValue() : argumentSymbol);
		call.appendChild(argumentElement);
	}
	
	)*) <ROUND_END>
	{
		try {
			// If the function is called using function pointer, then name could be blank
			if(!Constants.BLANK.equals(functionName)) {
				argumentSymbol = Environment.getSymbol(functionName);
				
				if(!(argumentSymbol instanceof OverloadedFunctionType))
					throw new CompilationException("Type mismatch \n Found    : '" + functionName + DataTypeFinder.getDataType(argumentSymbol) + "' \n Required : '" + functionName + "'");
				// Get the function
				functionSymbol = ((OverloadedFunctionType) argumentSymbol).getFunction(actualArgs);
			} 
			// in that case, simply set the return type as that of function just obtained.
			else {
				functionSymbol = (FunctionType)functionType;
			}
		} catch (SymbolNotDefinedException e) {
			throw new CompilationException(e.getMessage());
		}
		call.setSymbol(functionSymbol);
		return call;
	}
}

/** 
 * Variable Declaration
 * (const)? datatype() (*)* ID ([INT_CONSTANT])* ( = value )? (, (*)* ID (= value)?)* ;
 */
void VarDeclaration() throws CompilationException : 
{
	Token t = null;
	String pointerType = null, dataType = null, newVariableName = null; 
	Symbol variableSymbol = null, variableValueSymbol = null, baseDataType = null;
	UXMLElement savedCurrentNode = currentNode, parentNode = currentNode,variableValueElement = null, arrayElement = null;
	boolean mutable = true, ptrMutable = true;
	PointerType pointer = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
} 
{
  try {
	  (
		<CONST> {mutable = false;}
	  )?
	  dataType = DataType() 
	  (
		<ASTERISK>
		{
			pointer = processPointer(pointer, dataType, mutable);
		}
	  )*
	  (<CONST> {ptrMutable = false;})?
	  t = <ID> 
	  {
		  newVariableName = t.image;
		  variableSymbol = SymbolMachine.generate(Constants.BLANK, pointer != null? pointer.getName() : dataType, mutable);
		  
		  // Set the pointer type, else 'pointer' will be saved
		  if(pointer != null) {
			  variableSymbol.setType(pointer.getName());
			  pointer.setMutableStatus(ptrMutable);
		  }
	  }
	  arrayElement = CreateArray(newVariableName, variableSymbol, mutable)
	  {
		  variableSymbol = arrayElement.getSymbol();
		  
		  // Set the name of the variable
		  variableSymbol.setName(newVariableName);
		  attributes.clear();
		  
		  attributes.put(Constants.NAME, newVariableName);
		  attributes.put(Constants.TYPE, variableSymbol.getType());
		  
		  // If this is a pointer
		  if(pointer == null ||( variableSymbol != null && variableSymbol instanceof ArrayType) 
				  /*Constants.ARRAY_TYPE.equals(arrayElement.getElementName())*/)
			  attributes.put(Constants.MUTABLE, mutable? "yes" : "no" );
		  else {
			  attributes.put(Constants.PTR_MUTABLE, ptrMutable? "yes" : "no"); 
			  attributes.put(Constants.VALUE_MUTABLE, mutable? "yes" : "no" ); // hence value is set depending on mutable status.  
		  }
		  
		  // Since assignment could be there, hence save the current node
		  savedCurrentNode = currentNode;
		  currentNode = currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, variableSymbol));
	  }
	  // Set the initial value of a variable
	  (<ASSIGN> variableValueElement = Expression()  
		{ 
		  variableValueSymbol = variableValueElement.getSymbol();
		  // Make it mutable so that initial value can be stored
		  variableSymbol.setMutableStatus(true);
		  variableSymbol.setValue(variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol); 
		  currentNode.appendChild(variableValueElement);
		  // Set it back to the mutable status as defined in source program
		  // If this is an instanceof pointertype, then set the ptrMutable
		  variableSymbol.setMutableStatus(variableSymbol instanceof PointerType? ptrMutable : mutable);
		}
	  )?
	  {
		  currentNode = savedCurrentNode;
		  // Store the variable in symbol table
			// If this is a global variable declaration, then add in global symbol table
			if(globalVariableDeclaration)
				Environment.addGlobalSymbol(variableSymbol);
			else
				Environment.currentActivationRecord.addSymbol(variableSymbol);
	  }
	( <COMMA>
	{
		// Reset the pointer to null
		pointer = null;
		attributes = new HashMap<String,String>();
		currentNode = savedCurrentNode; 
		pointerType = null;
	}
	(
		<ASTERISK>
		{
			pointer = processPointer(pointer, dataType, mutable);
		}
	 )*
	 (<CONST> {ptrMutable = false;})?
	t = <ID> 
	{
		  newVariableName = t.image;
		  variableSymbol = SymbolMachine.generate(Constants.BLANK, pointer != null? pointer.getName() : dataType, mutable);
		  
		  // Set the pointer type, else 'pointer' will be saved
		  if(pointer != null) {
			  variableSymbol.setType(pointer.getName());
			  pointer.setMutableStatus(ptrMutable);
		  }
	 }
	 arrayElement = CreateArray(newVariableName, variableSymbol, mutable)
	  {
		  variableSymbol = arrayElement.getSymbol();
			  
		  // Set the name of the variable
		  variableSymbol.setName(newVariableName);
		  attributes.clear();
		  
		  attributes.put(Constants.NAME, newVariableName);
		  attributes.put(Constants.TYPE, variableSymbol.getType());

 		  // If this is a pointer
		  if(pointer == null || ( variableSymbol != null && variableSymbol instanceof ArrayType) 
				  /*Constants.ARRAY_TYPE.equals(arrayElement.getElementName())*/)
			  attributes.put(Constants.MUTABLE, mutable? "yes" : "no" );
		  else {
			  attributes.put(Constants.PTR_MUTABLE, ptrMutable? "yes" : "no"); 
			  attributes.put(Constants.VALUE_MUTABLE, mutable? "yes" : "no" ); // hence value is set depending on mutable status.  
		  }
		  
		 // Since assignment could be there, hence save the current node
		 savedCurrentNode = currentNode;
		 currentNode = currentNode.appendChild(UXMLElementFactory.generateElement(Constants.VAR, attributes, variableSymbol));
	   }
	  // Set the initial value of a variable
	(<ASSIGN> variableValueElement = Expression()
		{ 
		variableValueSymbol = variableValueElement.getSymbol();
		
		  // Make it mutable so that initial value can be stored
		  variableSymbol.setMutableStatus(true);
		  variableSymbol.setValue(variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol); 
		  currentNode.appendChild(variableValueElement);
		  // Set it back to the mutable status as defined in source program
		  variableSymbol.setMutableStatus(mutable);
		}		
	)? 
	{
		currentNode = savedCurrentNode;
		// Store the variable in symbol table
		// If this is a global variable declaration, then add in global symbol table
		if(globalVariableDeclaration)
			Environment.addGlobalSymbol(variableSymbol);
		else
			Environment.currentActivationRecord.addSymbol(variableSymbol);
	}
	)* 
	<STMT_TERMINATOR>
	{
		// Restore the node
		currentNode = parentNode;
	}
  } catch(IllegalSymbolValueException e) {
	  throw new CompilationException(e.getMessage());
  } catch(ImmutableSymbolException e) {
	  throw new CompilationException(e.getMessage());
  } catch(TypeMismatchException e) {
	  throw new CompilationException(e.getMessage());
  }
}

/**
 * Returns the array definition
 * ( [ INT_CONSTANT ] )*
 */
UXMLElement CreateArray(String variableName, Symbol baseElement, boolean mutable) throws CompilationException : 
{
	Token t = null;
	ArrayList<ArrayType> arrayDimProcessor = new ArrayList<ArrayType>();
	ArrayType arrayElement = null;
	int dimSize;
	HashMap<String, String> attributes = new HashMap<String, String>();
	UXMLElement arrayNodeElement = null, dimElement = null;
	StringBuffer dimType = new StringBuffer(); 
}
{
	{
		attributes.put(Constants.NAME, variableName );
		attributes.put(Constants.TYPE, baseElement.getType());
		arrayNodeElement = UXMLElementFactory.generateElement(Constants.ARRAY_TYPE, attributes, null);
	}
	(<SQUARE_START> 
	t = <INT_CONSTANT> 
	{ 
		dimSize = Integer.parseInt(t.image);
		dimType.append(t.image);
		try {
			arrayElement = (ArrayType)SymbolMachine.generate(Constants.BLANK, Constants.ARRAY, true);	
		} catch(IllegalSymbolValueException e) {} // Exception won't come since we are passing ARRAY
		
		attributes.clear();
		attributes.put(Constants.SIZE, String.valueOf(dimSize));
		dimElement = UXMLElementFactory.generateElement(Constants.DIM, attributes, null);
		arrayNodeElement.appendChild(dimElement);
		arrayElement.setSize(dimSize);
		arrayDimProcessor.add(arrayElement);
	}  
	<SQUARE_END>)*
	{
		try { 
			for(int dim = arrayDimProcessor.size() - 1; dim >= 0; dim--) {
				arrayElement = arrayDimProcessor.get(dim);
				arrayElement.setValue(baseElement);
				arrayElement.setMutableStatus(mutable);
				baseElement = arrayElement;
			}
			
			// If there was an array declaration, then add the array in symtab
			if(arrayDimProcessor.size() > 0) {
				String arrayType = DataTypeFinder.getDataType(baseElement)+ dimType.toString();
				baseElement.setType(arrayType);
				baseElement.setName(arrayType);
				// Change the name of array to arrayType
				arrayNodeElement.setAttributeValue(Constants.NAME, arrayType );
				
				// Add the array-type in  symbol table
				if(!Environment.currentActivationRecord.isSymbolPresent(arrayType) && 
							!Environment.isSymbolPresentInGlobalScope(arrayType)) {
					currentNode.appendChild(arrayNodeElement);
					  
					// If this is the first time occurance of aray-type then change the type to ARRAY
					baseElement.setType(Constants.ARRAY);
					// Add the array-type in symbol table
					// If this is a global variable declaration, then add in global symbol table
					if(globalVariableDeclaration)
						Environment.addGlobalSymbol(baseElement);
					else
						Environment.currentActivationRecord.addSymbol(baseElement);
					 
					baseElement = Clone.deepCopySymbol(baseElement);
					
					// Since we changed the type to Array, revert it back to the array-type
					baseElement.setType(arrayType);
				} 
			} 
			arrayNodeElement.setSymbol(baseElement);
			return arrayNodeElement;
		} catch(ImmutableSymbolException e) {
			throw new CompilationException(e.getMessage());
		} catch(TypeMismatchException e) {
			throw new CompilationException(e.getMessage());
		} catch(IllegalSymbolValueException e) {
			throw new CompilationException(e.getMessage());
		} catch(SymbolNotDefinedException e) {
			throw new CompilationException(e.getMessage());
		}
	}
}

/**
 * Array Access
 *  ([ Expression() ])* 
 */
UXMLElement ArrayAccess(UXMLElement variableElement) throws CompilationException :
{
	Token t = null;
	int index = 0;
	HashMap<String, String> attributes = new HashMap<String, String> ();
	attributes.put(Constants.VALUE, "[]");
	UXMLElement operator = null, 
	indexElement = null,returnElement = operator;
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	Symbol arrayElementAtIndex = null;
}
{
	try {
		(<SQUARE_START> 
		indexElement = Expression() 
		{
			operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, variableElement.getSymbol());
			operator.appendChild(variableElement);
			operator.appendChild(indexElement);
			operands.clear();
			operands.add(variableElement.getSymbol());
			operands.add(indexElement.getSymbol());
			arrayElementAtIndex = Operator.execute("[]", operands);
			operator.setSymbol(arrayElementAtIndex);
			variableElement = operator;
		}
		<SQUARE_END>
		)*
		{
			return variableElement;
		}
	} catch (IllegalSymbolValueException e) {
		throw new CompilationException(e.getMessage());
	} catch(OperatorNotFoundException e) {
		throw new CompilationException(e.getMessage());
	}

}

/**
 * Assignment statement
 */
void Assignment() throws CompilationException : 
{
	UXMLElement parentNode = null;
	Symbol variableSymbol = null, variableValueSymbol = null;
	UXMLElement variableSymbolElement = null, variableValueElement = null, assignment = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
}
{
	variableSymbolElement = Variable(false) 
	<ASSIGN> 
	variableValueElement = Expression()
	{
		variableSymbol = variableSymbolElement.getSymbol();
		variableValueSymbol = variableValueElement.getSymbol();
		variableValueSymbol = variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol;
		try {
			// Check if the data-type of pointers are same or not
			if(variableSymbol.getDataType() == DATA_TYPE.POINTER) {
				String lhsPtrType = DataTypeFinder.getDataType(variableSymbol);
				String rhsPtrType = DataTypeFinder.getDataType(variableValueSymbol);
				if(!lhsPtrType.equals(rhsPtrType))
					throw new CompilationException(new TypeMismatchException(rhsPtrType,lhsPtrType).getMessage());
			}
			if(variableSymbol instanceof ArrayType) 
				((ArrayType)variableSymbol).copyArray(variableValueSymbol);	
			else
				variableSymbol.setValue(variableValueSymbol);
			
		} catch(ImmutableSymbolException e) {
			throw new CompilationException(e.getMessage());
    	} catch(TypeMismatchException e) { 
    		throw new CompilationException(e.getMessage());
    	} catch(IllegalSymbolValueException e) {
    		throw new CompilationException(e.getMessage());
    	} catch(SymbolNotDefinedException e) {
    		throw new CompilationException(e.getMessage());
    	}
		assignment = UXMLElementFactory.generateElement(Constants.ASSIGN, null ,null);
		attributes.put(Constants.NAME, variableSymbol.getName());
		if(variableValueElement.getElement() == null)
			assignment.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol));
		else
			assignment.appendChild(variableSymbolElement);
		assignment.appendChild(variableValueElement);
		currentNode.appendChild(assignment);
	}
	<STMT_TERMINATOR>
}


/**
 * TODO: unary operator
 * expression() (( == | != | > | < | >= | <= ) expression())?
 */
UXMLElement Condition() throws CompilationException  : 
{
	Token t = null;
	UXMLElement lhsExpression = null, rhsExpression = null, condition = null;
	Symbol lhsSymbol = null, rhsSymbol = null;
	String operatorName = null;
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	HashMap<String,String> attributes = new HashMap<String, String>();
}
{
	lhsExpression = Expression() 
	(( t = <EQ> | t = <NT_EQ> | t = <LT> {t.image = "(";} | t = <LT_EQ> {t.image = "(=";}| t = <GT> {t.image = ")";} | t = <GT_EQ>{t.image = ")=";} ) 
	{ 
		operatorName = t.image;
	} 
	rhsExpression = Expression())?
	{
		lhsSymbol = lhsExpression.getSymbol();
		try {
			// Unary operator
			if(operatorName == null)
			{
				operatorName = "==";
				attributes.clear();
				attributes.put(Constants.VALUE, operatorName);
				operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
				condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
				condition.appendChild(lhsExpression);
				currentNode.appendChild(condition);
				currentNode = condition;
				return condition;
			}
			// Binary operator
			else {
				rhsSymbol = rhsExpression.getSymbol();
				attributes.clear();
				attributes.put(Constants.VALUE, operatorName);
				operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
				operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
				condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
				condition.appendChild(lhsExpression);
				condition.appendChild(rhsExpression);
				currentNode.appendChild(condition);
				currentNode = condition;
				return condition;
			}
		} catch(IllegalSymbolValueException e) {
			throw new CompilationException(e.getMessage());
		} catch(OperatorNotFoundException e) {
			throw new CompilationException(e.getMessage());
		}
	}
}

/**
 * TODO: NOT
 * Condition (( && | || ) Condition)* 
 */
void MultipleConditions() throws CompilationException : 
{
	Token t = null;
	UXMLElement parentNode = currentNode, savedCurrentNode = currentNode, not = null, condition = null, lhsCondition = null,rhsCondition = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	Symbol lhsSymbol = null, rhsSymbol = null;
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	String operatorName = null;
}
{
	try {
		/*(
			t = <NOT> {operatorName = t.image;}
		)? */
		lhsCondition = Condition()
		/*{
			// If NOT is used
			if(operatorName != null) {
				operands.add(lhsCondition.getSymbol());
				attributes.put(Constants.VALUE,t.image);
				not = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
				currentNode.appendChild(not);
				lhsCondition = currentNode;
			}
		}*/
		((
		t = <AND> {t.image = "$$";} 
		| t = <OR> 
		) 
		{
			operatorName = t.image;
		}
		/*(<NOT>)?*/
		rhsCondition = Condition()
		{
			lhsSymbol = lhsCondition.getSymbol();
			rhsSymbol = rhsCondition.getSymbol(); 
			attributes.clear();
			attributes.put(Constants.VALUE, operatorName);
			operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
			operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
			condition = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
			condition.appendChild(lhsCondition);
			condition.appendChild(rhsCondition);
			
			currentNode = savedCurrentNode;
			currentNode.appendChild(condition);
			
			savedCurrentNode = currentNode;
			lhsCondition = condition;
		}
			
		)*
		{
			if(condition != null)
				currentNode = condition;
		}
	} catch(IllegalSymbolValueException e) {
		throw new CompilationException(e.getMessage());
	} catch(OperatorNotFoundException e) {
		throw new CompilationException(e.getMessage());
	}
	/*try {
		(
			t = <NOT>
			{
				operatorName = t.image;
			}
		)? 
		lhsCondition  = Condition()
		{
			// If NOT operator is used
			if(operatorName != null) {
				operands.add(lhsCondition.getSymbol());
				attributes.put(Constants.VALUE,t.image);
				not = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
				currentNode.appendChild(not);
				currentNode = not;
			}
		}
				
		((<AND> | <OR>) Condition())?
		{
			currentNode = parentNode;
		}
	} catch(IllegalSymbolValueException e) {
		 throw new CompilationException(e.getMessage());
	 } catch(OperatorNotFoundException e) {
		 throw new CompilationException(e.getMessage());
	 }*/
}

/**
 * if ( expression() (== expression())? ) 
 * {
 * 	... statements ...
 * } 
 * else if (expression() )
 * {
 * 	... statements ...
 * }
 * else {
 *  ... statements ...
 * }
 */
void If() throws CompilationException  : 
{
	UXMLElement parentNode = currentNode;
}
{
	// If 
	<IF> <ROUND_START> MultipleConditions() <ROUND_END>
	CodeBlock()
		
	/*
	// elseif : TODO 
	( <ELSEIF> <ROUND_START> MultipleConditions() <ROUND_END>
		CodeBlock()
	)*
	*/
	
	// else
	(
		<ELSE>
		CodeBlock()
	)?
	{
		// Restore the node
		currentNode = parentNode;
	}
}


/**
 * for(assign() ; condition() ; expression() )
 * {
 * 		statements...
 * }
 */
void For() throws CompilationException  : 
{
	UXMLElement parentNode = currentNode, for_loop = null, controllerNode = null, savedCurrentNode = null;
	Symbol variableSymbol = null, variableValueSymbol = null;
	UXMLElement variableSymbolElement = null, variableValueElement = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
}
{
	<FOR> 
	{
		for_loop = UXMLElementFactory.generateElement(Constants.FOR_LOOP, null, null);
		currentNode.appendChild(for_loop);
		currentNode = for_loop;
	} 
	<ROUND_START>
	{
		controllerNode = UXMLElementFactory.generateElement(Constants.FROM, null, null);
		currentNode.appendChild(controllerNode);
		savedCurrentNode = currentNode;
		currentNode = controllerNode;
	}
	Assignment() 
	{
		currentNode = savedCurrentNode;
		
		controllerNode = UXMLElementFactory.generateElement(Constants.TILL, null, null);
		currentNode.appendChild(controllerNode);
		savedCurrentNode = currentNode;
		currentNode = controllerNode;
	}
	MultipleConditions() <STMT_TERMINATOR>
	{
		currentNode = savedCurrentNode;
		
		controllerNode = UXMLElementFactory.generateElement(Constants.STEP, null, null);
		currentNode.appendChild(controllerNode);
		
		savedCurrentNode = currentNode;
		currentNode = controllerNode;
	}
	variableSymbolElement = Variable(false)
	{
		controllerNode = UXMLElementFactory.generateElement(Constants.ASSIGN, null, null);
	}
	
	<ASSIGN> variableValueElement = Expression() 
	{
		variableSymbol = variableSymbolElement.getSymbol();
		
		variableValueSymbol = variableValueElement.getSymbol();
		try {
			variableSymbol.setValue(variableValueSymbol instanceof FunctionType? ((FunctionType)(variableValueSymbol)).getReturnValue() : variableValueSymbol);
			attributes.put(Constants.NAME, variableSymbol.getName());
			controllerNode.appendChild(UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,variableSymbol));
			currentNode.appendChild(controllerNode);
			
			currentNode = controllerNode;
			
			currentNode.appendChild(variableValueElement);
			currentNode = savedCurrentNode;
		} catch(ImmutableSymbolException e) {
			throw new CompilationException(e.getMessage());
		} catch(TypeMismatchException e) { 
			throw new CompilationException(e.getMessage());
		} catch(IllegalSymbolValueException e) {
			throw new CompilationException(e.getMessage());
		}
	}
	<ROUND_END>
	CodeBlock()
	{
		// Restore the node
		currentNode = parentNode;
	}
}

/**
 * do {
 * 	...statements...
 * } while (condition) ;
 */
void DO_WHILE() throws CompilationException  : 
{
	UXMLElement parentNode = currentNode, iterate = null, till = null;
}
{
	<DO>
	{
		iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
		currentNode.appendChild(iterate);
		currentNode = iterate;
	}
		CodeBlock() 
	<WHILE>
	{
		till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
		currentNode.appendChild(till);
		currentNode = till;
	}
	<ROUND_START> MultipleConditions() <ROUND_END> 
	<STMT_TERMINATOR>
	{
		// Restore the node
		currentNode = parentNode;
	}
}

/**
 * while(condition) {
 * 	...statements...
 * }
 */
void WHILE_DO() throws CompilationException  : 
{
	UXMLElement parentNode = currentNode, iterate = null, till = null;
}
{
	<WHILE>
	{
		iterate = UXMLElementFactory.generateElement(Constants.ITERATE, null, null);
		currentNode.appendChild(iterate);
		currentNode = iterate;
		
		till = UXMLElementFactory.generateElement(Constants.TILL, null, null);
		currentNode.appendChild(till);
		currentNode = till;
	}
	<ROUND_START> MultipleConditions() <ROUND_END>
	{
		currentNode = iterate;
	}
	CodeBlock()
	{
		// Restore the node
		currentNode = parentNode;
	}
}

/**
 * print(1, 2, "hello");
 * Prints : ( '_' is space)
 * 1_2_hello_"\n"
 * 
 * println(1,2,"hello");
 * Prints :
 * 1"\n"
 * 2"\n"
 * hello"\n"
 * 
 */
void Print() throws CompilationException : 
{
	Token t = null;
	UXMLElement print, expression;
}
{
	(t = <PRINT> | t = <PRINTLN>) 
	{
		print = UXMLElementFactory.generateElement(t.image, null, null);
	}
	<ROUND_START>
		expression = Expression()
		{
			print.appendChild(expression);
		}
		(
			<COMMA>
			expression = Expression()
			{
				print.appendChild(expression);
			}
		)*
	<ROUND_END>
	<STMT_TERMINATOR>
	{
		currentNode.appendChild(print);
	}
}

/**
 * E -> T1 E_L
 */
UXMLElement Expression() throws CompilationException  : 
{
	UXMLElement restOfExpression = null;
}
{
	restOfExpression = Expression_Left(Term1())
	{
		return restOfExpression;
	}
}

/**
 * E_L -> (& | | | ^ | >> | <<) T1 E_L
 */
UXMLElement Expression_Left(UXMLElement currentLHS) throws CompilationException  : 
{
	Token t = null;
	UXMLElement currentRHS = null,restOfExpression = null;
	UXMLElement operator = null;
	Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	String operatorName = null;
}
{
	[
	 (t = <AMPERSAND> {t.image = "$";} | t = <BIT_OR> | t = <BIT_XOR> | t = <BIT_RIGHT_SHIFT> {t.image = "))";} | t = <BIT_LEFT_SHIFT> {t.image = "((";})
	 {
		 operatorName = t.image;
	 }
	 currentRHS = Term1() 
	 {
		 rhsSymbol = currentRHS.getSymbol();
		 try {
			 attributes.put(Constants.VALUE,operatorName);
			 operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
			 operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
			 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
			 currentNode.appendChild(operator);
			 operator.appendChild(currentLHS);
			 operator.appendChild(currentRHS);
			 currentLHS = operator;
	//			 currentLHS = "(" + currentLHS + currentOperator + currentRHS + ")";
		 } catch(IllegalSymbolValueException e) {
			 throw new CompilationException(e.getMessage());
		 } catch(OperatorNotFoundException e) {
			 throw new CompilationException(e.getMessage());
		 }
	 }
	 restOfExpression = Expression_Left(currentLHS)
	]
	{
		if(restOfExpression == null)
			restOfExpression = currentLHS;
		return restOfExpression;
	 }
}


/**
 * T1 -> T2 T1_L
 */
UXMLElement Term1() throws CompilationException  : 
{
	UXMLElement restOfExpression = null;
}
{	
	restOfExpression = Term1_Left(Term2())
	{
		return restOfExpression;
	}
}

/**
 * T1_L -> (+ | -) T2 T1_L
 */
UXMLElement Term1_Left(UXMLElement currentLHS) throws CompilationException  :  
{
	Token t = null;
	UXMLElement currentRHS = null,restOfExpression = null;
	UXMLElement operator = null;
	Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
	String operatorName = null;
}
{
	[
	 (t  = <PLUS> | t  = <MINUS>)
	 {
		 operatorName = t.image;
	 }
	 
	 currentRHS = Term2()  
	 {

		 try {
			 rhsSymbol = currentRHS.getSymbol();
			 attributes.put(Constants.VALUE,operatorName);
			 operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
			 operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
			 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
			 currentNode.appendChild(operator);
			 operator.appendChild(currentLHS);
			 operator.appendChild(currentRHS);
			 currentLHS = operator;
		 } catch(IllegalSymbolValueException e) {
			 throw new CompilationException(e.getMessage());
		 } catch(OperatorNotFoundException e) {
			 throw new CompilationException(e.getMessage());
		 }
	 }
	 restOfExpression = Term1_Left(currentLHS)
	 
	 ]
	 {
		if(restOfExpression == null)
			restOfExpression = currentLHS;
		return restOfExpression;
	 }
}

/**
 * T2 -> F T2_L
 */
UXMLElement Term2() throws CompilationException  : 
{
	UXMLElement restOfExpression = null;
}
{
	restOfExpression = Term2_Left( Factor())
	{
		return restOfExpression;
	}
}

/**
 * T2_L -> (* | / | %) F T2_L
 */
UXMLElement Term2_Left(UXMLElement currentLHS) throws CompilationException  : 
{
	Token t = null;
	UXMLElement currentRHS = null,restOfExpression = null;
	UXMLElement operator = null;
	Symbol lhsSymbol = currentLHS.getSymbol(), rhsSymbol = null;
	HashMap<String,String> attributes = new HashMap<String, String>();
	String operatorName = null;
	ArrayList<Symbol> operands = new ArrayList<Symbol>();
}
{
	[
	 (t = <ASTERISK> | t = <DIVIDE > | t = <MOD>) 
	 {
		 operatorName = t.image;
	 }
	 currentRHS = Factor()  
	 {
		 try {
			 rhsSymbol = currentRHS.getSymbol();
			 attributes.put(Constants.VALUE,operatorName);
			 operands.add((lhsSymbol instanceof FunctionType)? ((FunctionType)lhsSymbol).getReturnValue() : lhsSymbol );
			 operands.add((rhsSymbol instanceof FunctionType)? ((FunctionType)rhsSymbol).getReturnValue() : rhsSymbol );
			 // Make sure that div doesn't give divide by zero error
			 try {
				 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, Operator.execute(operatorName, operands));
			 } catch(RuntimeException e) 
			 {
				 Symbol param1 = operands.get(0);
				 Symbol param2 = operands.get(1);
				 if(param1.getDataType() == DATA_TYPE.FLOAT || param2.getDataType() == DATA_TYPE.FLOAT)
					 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, 
							 SymbolMachine.generate(Constants.BLANK, Constants.FLOAT, true));
				 else 
					 operator = UXMLElementFactory.generateElement(Constants.OPERATOR, attributes, 
							 SymbolMachine.generate(Constants.BLANK, Constants.INT, true));
			 }
			 currentNode.appendChild(operator);
			 operator.appendChild(currentLHS);
			 operator.appendChild(currentRHS);
			 currentLHS = operator;
	//		 currentLHS = "(" + currentLHS + currentOperator + currentRHS + ")";
		 } catch(IllegalSymbolValueException e) {
			 throw new CompilationException(e.getMessage());
		 } catch(OperatorNotFoundException e) {
			 throw new CompilationException(e.getMessage());
		 }
	 }
	 restOfExpression = Term2_Left(currentLHS)
	 ]
	 {
		if(restOfExpression == null)
			restOfExpression = currentLHS;
		return restOfExpression;
	 }
} 

/** 
 * F -> (E) | Variable() | Constant() | <VOID> | FunctionCall()
 */
UXMLElement Factor() throws CompilationException  : 
{
	Token t = null;
	String typeCast = null;
	Symbol value = null;
	FunctionType functionSymbol = null;
	UXMLElement expressionValue = null, returnFactorValue = null;
	HashMap<String, String> attributes = new HashMap<String, String>();
}
{
	(<BLOCK_START> (t = < INT > | t = < FLOAT > | t = < CHAR > | t = < BOOL > ) {typeCast = t.image; } <BLOCK_END>)?
	(
	<ROUND_START> expressionValue = Expression() <ROUND_END> { returnFactorValue =  expressionValue ;  }
	| expressionValue = Variable(false) 
	{ 
		value = expressionValue.getSymbol();
		// In order to generate a variable here, the expressionValue should not contain any pointer-type
		// symbol or it should not contain an 'operator' element with '#' value.
		
		// If value is of type PointerType then Variable() returned an addressOf a variable. It will be handled to wherever
		// the Expression() is called
		// If expressionValue contains 'operator with value="#" ' ,then value might contain the symbol (integer,char,etc) because
		// operation '#' is performed in Variable() method. However variable is not to be generated here, but in the caller 
		// of Expression(). That's why, skip these 2 conditions.
		// Similarly argument holds for '[]' operation is present
		if((!(value instanceof PointerType) && 
				!(Constants.OPERATOR.equals(expressionValue.getElementName()) && 
						Constants.VALUE_OF.equals(expressionValue.getAttributeValue(Constants.VALUE))
				)) &&
				(!(Constants.OPERATOR.equals(expressionValue.getElementName()) && 
						Constants.VALUE_AT_INDEX.equals(expressionValue.getAttributeValue(Constants.VALUE))))) {
			attributes.clear();
			attributes.put(Constants.NAME, expressionValue.getSymbol().getName());
			expressionValue = UXMLElementFactory.generateElement(Constants.VARIABLE,attributes,expressionValue.getSymbol());
		}
		returnFactorValue = expressionValue;
		
	} 
	| value = Constant() { returnFactorValue =  new UXMLElement(null,value); }
	| <VOID> {try { returnFactorValue =  new UXMLElement(null,SymbolMachine.generate(Constants.BLANK,Constants.VOID, false));  } catch(Exception e ){}}
	| expressionValue = FunctionCall() { returnFactorValue = expressionValue; }
	)
	{
		try {
			if(typeCast != null) {
				attributes.put(Constants.TYPE, typeCast);
				expressionValue = UXMLElementFactory.generateElement(Constants.CAST ,attributes, SymbolMachine.cast(returnFactorValue.getSymbol(), typeCast));
				expressionValue.appendChild(returnFactorValue);
				returnFactorValue = expressionValue;
			}
		} catch(TypeMismatchException e) {
			throw new CompilationException(e.getMessage());
		} catch (SymbolNotDefinedException e) {
			throw new CompilationException(e.getMessage());
		} catch (IllegalSymbolValueException e) {
			throw new CompilationException(e.getMessage());
		}
		return returnFactorValue;
	}
	
}

	
/*UXMLElement Term(UXMLElement currentLHS) {
	currentLHS.getSymbol() -> will be used to check the return type of operator : Compilation errors 
	currentLHS.getElement() -> will be used to generate the uXML code : Generation of code
}*/